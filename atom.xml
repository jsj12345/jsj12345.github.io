<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JSJ-0513</title>
  
  <subtitle>about CS</subtitle>
  <link href="http://interaction2023.cn/atom.xml" rel="self"/>
  
  <link href="http://interaction2023.cn/"/>
  <updated>2025-03-19T12:43:46.534Z</updated>
  <id>http://interaction2023.cn/</id>
  
  <author>
    <name>荆树吉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构</title>
    <link href="http://interaction2023.cn/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://interaction2023.cn/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2024-11-08T09:38:54.817Z</published>
    <updated>2025-03-19T12:43:46.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a><strong>第一章 绪论</strong></h1><h2 id="1-0数据结构在学什么"><a href="#1-0数据结构在学什么" class="headerlink" title="1.0数据结构在学什么"></a>1.0数据结构在学什么</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108174722732.png" alt="image-20241108174722732"></p><p>数据结构在学什么？</p><h2 id="1-1数据结构的基本概念"><a href="#1-1数据结构的基本概念" class="headerlink" title="1.1数据结构的基本概念"></a>1.1数据结构的基本概念</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108174919164.png" alt="image-20241108174919164"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108175451336.png" alt="image-20241108175451336"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108175525061.png" alt="image-20241108175525061"></p><h2 id="1-2算法和算法评价"><a href="#1-2算法和算法评价" class="headerlink" title="1.2算法和算法评价"></a>1.2算法和算法评价</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108175701029.png" alt="image-20241108175701029"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180051207.png" alt="image-20241108180051207"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180158724.png" alt="image-20241108180158724"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180432547.png" alt="image-20241108180432547"></p><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1线性表的定义和基本操作"><a href="#2-1线性表的定义和基本操作" class="headerlink" title="2.1线性表的定义和基本操作"></a>2.1线性表的定义和基本操作</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180646358.png" alt="image-20241108180646358"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180813550.png" alt="image-20241108180813550"></p><h2 id="2-2线性表的顺序表示"><a href="#2-2线性表的顺序表示" class="headerlink" title="2.2线性表的顺序表示"></a>2.2线性表的顺序表示</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181153520.png" alt="image-20241108181153520"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181556403.png" alt="image-20241108181556403"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181804317.png" alt="image-20241108181804317"></p><h2 id="2-3顺序表的链式表示"><a href="#2-3顺序表的链式表示" class="headerlink" title="2.3顺序表的链式表示"></a>2.3顺序表的链式表示</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181937655.png" alt="image-20241108181937655"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182046854.png" alt="image-20241108182046854"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182232557.png" alt="image-20241108182232557"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182311322.png" alt="image-20241108182311322"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182544821.png" alt="image-20241108182544821"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182823312.png" alt="image-20241108182823312"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183145884.png" alt="image-20241108183145884"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183440275.png" alt="image-20241108183440275"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183621669.png" alt="image-20241108183621669"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183932454.png" alt="image-20241108183932454"></p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108184320710.png" alt="image-20241108184320710"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义双链表</span></span><br><span class="line"><span class="keyword">typedef</span> sturct dnode&#123;            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    elemtype data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dnode</span> *prior,*next;   <span class="comment">//前驱与后继指针</span></span><br><span class="line">&#125;dnode, *dlinklist;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initdlinklist</span><span class="params">(dlinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (dnode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(dnode));    <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    l-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testdlinklist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    dlinklist L;</span><br><span class="line">    <span class="built_in">initdlinklist</span>(L);</span><br><span class="line">    <span class="comment">//后续代码...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断双链表是否为空(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(dlinklist L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//双链表的插入</span></span><br><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insertnextdnode</span><span class="params">(dnode *p, dnode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>)                <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next !=<span class="literal">NULL</span>)                    <span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-&gt;next-&gt;prior=s;</span><br><span class="line">    s-&gt;prior=p;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//双链表的删除</span></span><br><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deletenextdnode</span><span class="params">(dnode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    dnode *q = p-&gt;next;                    <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//p没有后继</span></span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next !=<span class="literal">NULL</span>)                    <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环单链表：最后一个节点的指针指向第一个节点</p><p>循环双链表：表头节点的前驱指向表尾结点；表尾结点的后继指向头结点</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义静态链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10            <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;          <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    elemtype data;            <span class="comment">//存储数据元</span></span><br><span class="line">    <span class="type">int</span> next;                 <span class="comment">//下一个元素的数组下标素</span></span><br><span class="line">&#125;slinklist[maxsize],slist;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1栈的定义"><a href="#3-1栈的定义" class="headerlink" title="3.1栈的定义"></a>3.1栈的定义</h2><p>栈：是只允许在一端进行插入或删除操作的线性表</p><p>栈顶：允许插入和删除的一方</p><p>栈底：不允许插入与删除的一方</p><p>栈的特点：先进后出</p><h2 id="3-2栈的基本操作"><a href="#3-2栈的基本操作" class="headerlink" title="3.2栈的基本操作"></a>3.2栈的基本操作</h2><p>InitStack(&amp;S) ： 初始化 栈。构造一个空栈 S ， 分配内存空间 。</p><p>DestroyStack(&amp;S) ： 销毁 栈。销毁并 释放 栈 S 所占用的 内存空间 。</p><p>Push(&amp;S,x) ： 进栈 ，若栈 S 未满，则将 x 加入使之成为新栈顶。</p><p>Pop(&amp;S,&amp;x) ： 出栈 ，若栈 S 非空，则弹出栈顶元素，并用 x 返回。</p><p>GetTop(S, &amp;x) ： 读栈顶元素 。若栈 S 非空，则用 x 返回栈顶元素</p><p>其他常用操作：</p><p>StackEmpty(S) ：判断一个栈 S 是否为空。若 S 为空，则返回 true ，否则返回 false 。</p><p>顺序栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序栈的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10                <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    elemtype data[maxsize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;sqstack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(sqstack &amp;s)</span></span>&#123;</span><br><span class="line">    s.top=<span class="number">-1</span>;                     <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">stackempty</span><span class="params">(sqstack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)                <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(sqstack &amp;s, elemtype x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==maxsize<span class="number">-1</span>)          <span class="comment">//栈满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s.top=s.top+<span class="number">1</span>;</span><br><span class="line">    s.data[s.top]=x;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(sqstack &amp;s,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)                <span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=s.data[s.top--];           <span class="comment">//栈顶元素出栈，指针减一</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gettop</span><span class="params">(sqstack s,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)                  <span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=s.data[s.top];                <span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义共享栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10                <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    elemtype data[maxsize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;shstack</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(shstack &amp;s)</span></span>&#123;</span><br><span class="line">    s.top0=<span class="number">-1</span>;                    <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    s.top1=maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链栈的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">linknode</span>&#123;</span><br><span class="line">    elemtype data;                <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linknode</span> *next;        <span class="comment">//指针域</span></span><br><span class="line">&#125; *listack;                       <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="数据结构" scheme="http://interaction2023.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://interaction2023.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="http://interaction2023.cn/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://interaction2023.cn/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</id>
    <published>2024-10-01T01:58:39.767Z</published>
    <updated>2024-11-07T14:53:12.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络体系结构"><a href="#第一章-计算机网络体系结构" class="headerlink" title="第一章 计算机网络体系结构"></a>第一章 计算机网络体系结构</h1><h2 id="1-1计算机网络概述"><a href="#1-1计算机网络概述" class="headerlink" title="1.1计算机网络概述"></a>1.1计算机网络概述</h2><h3 id="1-1-1计算机网络的概念"><a href="#1-1-1计算机网络的概念" class="headerlink" title="1.1.1计算机网络的概念"></a>1.1.1计算机网络的概念</h3><table><thead><tr><th></th><th></th><th>由若干节结点（node）和链接这些节点的链路（link）组成。结点可以是计算机、集线器、交换机、路由器等</th></tr></thead><tbody><tr><td></td><td>计算机网络</td><td>主要功能：数据通信（信息共享）、资源共享</td></tr><tr><td></td><td>|路由器连接|</td><td></td></tr><tr><td></td><td>互连网（internet）</td><td>多个计算机网络通过路由器互相连接而成</td></tr><tr><td>计算机网络的概念</td><td>|世界上最大规模的互连网|</td><td>可使用任何通信协议</td></tr><tr><td></td><td>互联网（Internet）</td><td>或译为因特网。特指全世界最大的计算机网络，由各大ISP和国际机构组建</td></tr><tr><td></td><td></td><td>使用tcp&#x2F;ip协议族作为通信规则</td></tr><tr><td></td><td></td><td>ISP（Internet Service Provider），互联网服务提供商</td></tr><tr><td></td><td>其他拓展</td><td>集线器、交换机用于链接统一网络内的不同节点；路由器用于连接不同的网络</td></tr><tr><td></td><td></td><td>家用路由器&#x3D;路由器+交换机+其他功能</td></tr></tbody></table><h3 id="1-1-2计算机网络的组成与功能"><a href="#1-1-2计算机网络的组成与功能" class="headerlink" title="1.1.2计算机网络的组成与功能"></a>1.1.2计算机网络的组成与功能</h3><table><thead><tr><th></th><th></th><th></th><th><strong>主机，即端系统（end system）–如电脑手机物联网设备</strong></th><th><strong>内部安装网卡</strong></th></tr></thead><tbody><tr><td></td><td></td><td><strong>硬件</strong></td><td><strong>通信设备–如集线器，交换机，路由器</strong></td><td><strong>|将主机数据发到网络上</strong></td></tr><tr><td></td><td></td><td></td><td><strong>通信链路–如网线，光纤，同轴电缆</strong></td><td><strong>|接受来自网络的数据</strong></td></tr><tr><td></td><td><strong>从组成部分看</strong></td><td><strong>软件</strong></td><td><strong>方便用户使用，实现资源共享。如email客户端，聊天软件。网盘软件</strong></td><td><strong>|</strong></td></tr><tr><td></td><td></td><td></td><td><strong>规定计算机网络中的通信规则</strong></td><td><strong>|</strong></td></tr><tr><td></td><td></td><td><strong>协议</strong></td><td><strong>由硬件、软件共同实现，如：网络适配器+软件 实现网络通信协议</strong></td><td><strong>&lt;–|</strong></td></tr><tr><td></td><td></td><td></td><td><strong>工作方式：直接为用户服务（通信，资源共享）</strong></td><td></td></tr><tr><td></td><td></td><td><strong>边缘部分</strong></td><td><strong>主要有链接到互联网上的主机及其软件构成</strong></td><td></td></tr><tr><td><strong>计算机网络的组成</strong></td><td><strong>从工作方式看</strong></td><td></td><td><strong>工作方式：为边缘部分提供服务（连通性，交换服务）</strong></td><td></td></tr><tr><td></td><td></td><td><strong>核心部分</strong></td><td><strong>由大量网络和连接这些网络的路由器组成</strong></td><td></td></tr><tr><td></td><td></td><td></td><td><strong>计算机网络中运行应用程序，向用户提供可共享的硬件，软件和信息资源的部分</strong></td><td></td></tr><tr><td></td><td></td><td><strong>资源子网</strong></td><td><strong>主要由连接到互联网上的主机组成</strong></td><td></td></tr><tr><td></td><td><strong>从逻辑功能看</strong></td><td></td><td><strong>计算机网络中负责计算机间信息传输的部分。即把计算机和其他用户装置互联在一起的所有通信设备和介质的总称</strong></td><td></td></tr><tr><td></td><td></td><td><strong>通信子网</strong></td><td><strong>主要由 通信链路+通信设备+协议构成</strong></td><td></td></tr><tr><td></td><td></td><td></td><td><strong>注：主机内部实现信息传输的网络适配器&#x2F;底层协议 属于通信子网的范畴</strong></td><td></td></tr></tbody></table><table><thead><tr><th></th><th><strong>数据通信</strong></th><th><strong>实现计算机之间数据传输。是最基本最重要的功能</strong></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td><strong>如：智能音箱 请求服务器处理</strong></td></tr><tr><td></td><td><strong>资源共享</strong></td><td><strong>硬件、软件、数据资源</strong></td><td><strong>如：应用商店</strong></td></tr><tr><td><strong>计算机网络的功能</strong></td><td></td><td></td><td><strong>如：分享视频</strong></td></tr><tr><td></td><td><strong>分布式处理</strong></td><td><strong>将某个复杂任务分配给网络中多台计算机处理</strong></td><td><strong>如：大矩阵计算，mapreduce</strong></td></tr><tr><td></td><td><strong>提高可靠性</strong></td><td><strong>网络中各台计算机互为替代机</strong></td><td><strong>如：某网盘服务器集群网络，数据冗余备份</strong></td></tr><tr><td></td><td><strong>负载均衡</strong></td><td><strong>网络中各台计算机共同分担繁重工作</strong></td><td><strong>如：某游戏用多台服务器均衡处理玩家请求</strong></td></tr><tr><td></td><td><strong>其他</strong></td><td><strong>满足社会需求，生活需求</strong></td><td><strong>如远程办公，远程教育，娱乐等</strong></td></tr></tbody></table><h3 id="1-1-3三种交换方式"><a href="#1-1-3三种交换方式" class="headerlink" title="1.1.3三种交换方式"></a>1.1.3三种交换方式</h3><h4 id="1-1-3-1三种交换方式的优缺点"><a href="#1-1-3-1三种交换方式的优缺点" class="headerlink" title="1.1.3.1三种交换方式的优缺点"></a>1.1.3.1三种交换方式的优缺点</h4><p><strong>电路交换基本原理</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916103009214.png" alt="image-20240916103009214"></p><p><strong>电路交换的优点</strong>：</p><p>通信前从主叫端到被叫端建立一条专用的物理通路，在通信的全部时间内，两个用户始终占用端到端的线路资源。数据直送，传输速率高（电路交换更适用于（低频次。大量的传输数据）</p><p><strong>若应用于计算机网络有何缺点：</strong></p><p>建立释放连接需要额外的时间开销</p><p>线路被通信双方独占，利用率低</p><p>线路分配的灵活性差</p><p>交换节点不支持“差错控制”（无法发现传输过程中发生的数据错误）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机之间的数据往往是“突发式”传输，即往往会高频次，少量地传输数据。</span><br></pre></td></tr></table></figure><p><strong>报文交换的过程</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916104405988.png" alt="image-20240916104405988"></p><p><strong>报文交换的优点</strong></p><p>通信前无需建立连接</p><p>数据以“报文”为单位被交换节点间“存储转发：，通信线路可以灵活分配</p><p>在通信时间内，两个用户无需独占一整条物理线路。相比于电路交换，线路利用率高</p><p>交换节点中支持“差错控制”（通过校验技术）</p><p><strong>报文交换的缺点</strong></p><p>报文不定长，不方便存储转发管理</p><p>长报文的存储转发时间开销大、缓存开销大</p><p>长报文容易出错，重传代价高</p><p><strong>分组交换的原理：</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916104851576.png" alt="image-20240916104851576"></p><p><strong>分组交换的优点：</strong></p><p>通信前无需建立连接</p><p>数据以“分组”为单位被交换节点间“存储转发”，通信线路可以灵活分配</p><p>在通信时间内两个用户无需独占一条物理线路。相比于电路交换，线路利用率高</p><p>交换节点支持“差错控制”（通过校验技术）</p><p>相比于报文交换，分组交换改进了如下问题：</p><p>分组定长，方便存储转发管理</p><p>分组的存储转发时间开销小，缓存开销小</p><p>分组不易出错，重传代价低</p><p><strong>分组交换的缺点</strong></p><p>相比于报文交换，控制信息占比增加</p><p>想比于电路交换，依然存在存储转发时延</p><p>报文被拆分成多个分组，传输过程中可能出现失序，丢失等问题，增加处理的复杂<strong>度</strong></p><p><strong>虚电路交换技术</strong>原理</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916105651346.png" alt="image-20240916105651346"></p><h4 id="1-1-3-2三种交换方式的性能分析"><a href="#1-1-3-2三种交换方式的性能分析" class="headerlink" title="1.1.3.2三种交换方式的性能分析"></a>1.1.3.2三种交换方式的性能分<strong>析</strong></h4><p><strong>电路交换性能分析</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113317203.png" alt="image-20240916113317203"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113341828.png" alt="image-20240916113341828"></p><p><strong>报文交换性能分析</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113421619.png" alt="image-20240916113421619"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113436223.png" alt="image-20240916113436223"></p><p><strong>分组交换性能分析</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113522702.png" alt="image-20240916113522702"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113541364.png" alt="image-20240916113541364"></p><p><strong>三种交换方式的性能对比</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113618478.png" alt="image-20240916113618478"></p><p><strong>三种交换方式的表格对比</strong></p><table><thead><tr><th></th><th>电路交换</th><th>报文交换</th><th>分组交换</th></tr></thead><tbody><tr><td>完成传输所需时间</td><td>最少（排除建立&#x2F;释放连接耗时）</td><td>最多</td><td>较少</td></tr><tr><td>存储转发时延</td><td>无</td><td>较高</td><td>较低</td></tr><tr><td>通信前是否需要建立连接？</td><td>是</td><td>否</td><td>否</td></tr><tr><td>缓存开销</td><td>无</td><td>高</td><td>低</td></tr><tr><td>是否支持差错控制？</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>报文数据有序到达？</td><td>是</td><td>是</td><td>否</td></tr><tr><td>是否需要额外的控制信息</td><td>否</td><td>是</td><td>是（控制信息占比最大）</td></tr><tr><td>线路分配灵活性</td><td>不灵活</td><td>灵活</td><td>非常灵活</td></tr><tr><td>线路利用率</td><td>低</td><td>高</td><td>非常高</td></tr></tbody></table><h3 id="1-1-4计算机网络的分类"><a href="#1-1-4计算机网络的分类" class="headerlink" title="1.1.4计算机网络的分类"></a>1.1.4计算机网络的分类</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916121413817.png" alt="image-20240916121413817"></p><h3 id="1-1-5计算机网络的性能指标"><a href="#1-1-5计算机网络的性能指标" class="headerlink" title="1.1.5计算机网络的性能指标"></a>1.1.5计算机网络的性能指标</h3><p><strong>速率</strong>：又名：数据率，比特率，<em><strong>数据传输速率</strong></em></p><p><strong>带宽</strong>：表示某信道允许通过的<em><strong>最高数据率</strong></em></p><p><strong>吞吐量</strong>：描述某个网络（或节点、信道）的在单位时间内通过的实际数据量（<em><strong>实际的综合数据率，包括接受到的和发送出去的</strong></em>）</p><p>上述的三种性能指标的单位为bit&#x2F;s&#x3D;b&#x2F;s&#x3D;bps</p><p>bps,<strong>k</strong>bps,<strong>M</strong>bps,<strong>T</strong>bps(10^3递增)</p><p><em><strong>注意：</strong></em>1B&#x3D;8b</p><p><strong>带宽（另一种含义）</strong>：表示某信道允许通过的<em><strong>信道频带范围</strong></em>，单位<em><strong>Hz</strong></em></p><p><strong>时延</strong>：指数据一端传送到另一端的所需时间</p><p><strong>总时延</strong>&#x3D;<strong>发送时延</strong>+<strong>传播时延</strong>+<em><strong>处理时延+排队时延</strong></em></p><p><strong>发送时延：</strong>也称传输时延。节点将分组的所有比特推向链路所需要的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需要的时间</p><p>​                                                            <strong>发送时延</strong>&#x3D;<strong>分组长度</strong>&#x2F;<strong>发送速率</strong></p><p><strong>传播时延：</strong>电磁波在信道（传输介质）中传播一定的距离所花的时间，即一个比特从链路的一端传送到另一端所需的时间</p><p>​                                                           <strong>传输时延</strong>&#x3D;<strong>信道长度</strong>&#x2F;<strong>电磁波在信道上的传播速率</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">区分传输时延和传播时延。传输时延是路由器将分组推出所需的时间，是分组长度和链路传输速率的函数。传播时延是一个比特从一台路由器传播至另一个路由器所需的时间，是两台路由器之间距离的函数，而与分组长度或链路传播速率无关</span><br></pre></td></tr></table></figure><p><strong>处理时延</strong>：数据在交换节点为存储转发而进行的一些必要处理所需的时间。例如，分析分组的首部，从分组中提取数据、差错检验或查找合适的路由等。</p><p><strong>排队时延</strong>：分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发。这就产生了排队时延。</p><p><strong>时延带宽积：</strong>单向传播时延*带宽</p><p>**往返时延RTT:**表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间。</p><p><strong>信道利用率：</strong>某个信道有百分之多少的时间是有数据通过的</p><p>利用率低会浪费带宽资源，利用率太高可能导致网络拥塞</p><h3 id="1-1-6习题"><a href="#1-1-6习题" class="headerlink" title="1.1.6习题"></a>1.1.6习题</h3><h4 id="二-综合应用题-纯文字部分"><a href="#二-综合应用题-纯文字部分" class="headerlink" title="二.综合应用题(纯文字部分)"></a>二.综合应用题(纯文字部分)</h4><h4 id="03"><a href="#03" class="headerlink" title="03."></a>03.</h4><p><strong>在两台计算机之间传输一个文件有两种可行的确认策略。第一种策略把文件截成分组，接收方逐个确认分组，但就整体而言，文件没有得到确认。第二种策略不确认单个分组，但当文件全部收到后，对整个文件予以确认。讨论这两种方式的优缺点。</strong></p><p>若网络容易丢失分组，则对每个分组逐一进行确认较好,此时仅重传丢失的分组。另一方面若网络高度可靠，则在不发生差错的情况下，仅在整个文件传送的结尾发送一次确认，以减少确认次数，进而节省带宽。不过，即使只有单个分组丢失，也要重传整个文件。</p><h2 id="1-2计算机网络体系结构与参考模型"><a href="#1-2计算机网络体系结构与参考模型" class="headerlink" title="1.2计算机网络体系结构与参考模型"></a>1.2计算机网络体系结构与参考模型</h2><h3 id="1-2-1-计算机网络分层结构"><a href="#1-2-1-计算机网络分层结构" class="headerlink" title="1.2.1 计算机网络分层结构"></a>1.2.1 计算机网络分层结构</h3><ul><li><p><strong>网络的体系结构</strong></p><p><strong>定义</strong>:计算机网络各层及其协议的集合称为网络的体系结构。</p><p>“<strong>体系结构</strong>”精确定义了网络的层次划分、各层功能、各层协议等，不涉及具体实现。</p><p><strong>三种常见的网络体系结构</strong></p><p>OSI参考模型，7层（法律标准）</p><p>TCP&#x2F;IP模型，4层（事实标准）</p><p>五层模型，5层（教学用标准）</p></li><li><p><strong>实体、协议、接口、服务</strong></p><p><strong>实体：</strong>第n层中的活动元素（软件+硬件）称为第n层实体</p><p><strong>协议：</strong>是控制对等实体之间进行通信的规则的集合，<em><strong>是水平的</strong></em></p><p><strong>服务：</strong>是指下层为紧邻的上层提供的功能调用，<em><strong>是垂直的</strong></em>    服务的分类再试不讨论</p><p><strong>接口：</strong>又称为服务访问点（SAP），上一层实体通过“接口”请求下一层实体的服务</p></li><li><p><strong>PDU、SDU、PCI</strong></p><p>PDU（协议控制单元），SDU（服务数据单元），PCI（协议控制信息）</p><p>n-SDU+n-PCI&#x3D;n-PDU&#x3D;(n-1)-SDU</p><p><strong>翻译成人话就是：</strong>当层的服务数据单元，加上当层的协议控制信息就是当层的协议控制单元，而当层的协议控制单元就代表着下一层的服务数据单元，等待加入下一层的协议控制信息。</p></li><li><p><strong>三要素</strong></p><p>语法，语义，同步。</p><p><strong>语法：</strong>数据与控制信息的格式</p><p><strong>语义：</strong>即需要发出何种控制信息、完成何种动作及做出何种应答（成功或失败）</p><p><strong>同步（或时序）：</strong>执行各种操作的条件、时序关系等。</p></li></ul><h3 id="1-2-2-ISO-x2F-OSI参考模型和TCP-x2F-IP模型"><a href="#1-2-2-ISO-x2F-OSI参考模型和TCP-x2F-IP模型" class="headerlink" title="1.2.2 ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型"></a>1.2.2 ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型</h3><h4 id="1-2-2-1OSI参考模型"><a href="#1-2-2-1OSI参考模型" class="headerlink" title="1.2.2.1OSI参考模型"></a>1.2.2.1OSI参考模型</h4><p>国际标准化组织（ISO）提出的网络体系结构模型称为<em><strong>开放系统互连参考模型</strong></em>（OSI&#x2F;RM）,通常简称为<em><strong>OSI参考模型</strong></em>。共有七层对应的结构表格如下</p><table><thead><tr><th>口诀</th><th>OSI参考模型</th><th>任务</th><th>功能</th><th>各层传输单位</th><th>协议</th></tr></thead><tbody><tr><td><em><strong>用</strong></em></td><td>#7 应<em><strong>用</strong></em>层</td><td>实现特定网络应用</td><td>略（因为功能的种类太多了）</td><td>报文</td><td>FTP,HTTP,DNS,SMTP</td></tr><tr><td><em><strong>使</strong></em></td><td>#6 表<em><strong>示</strong></em>层</td><td>解决不同主机上信息表示不一致的问题</td><td>数据格式转换</td><td></td><td></td></tr><tr><td><em><strong>会</strong></em></td><td>#5 <em><strong>会</strong></em>话层</td><td>管理进程间会话</td><td>会话管理</td><td></td><td></td></tr><tr><td><em><strong>叔</strong></em></td><td>#4传<em><strong>输</strong></em>层</td><td>实现端到端（进程到进程）通信</td><td>复用和分用、差错控制、流量控制、连接管理、可靠传输管理、拥塞控制</td><td>报文段</td><td>TCP,UDP</td></tr><tr><td><em><strong>网</strong></em></td><td>#3 <em><strong>网</strong></em>络层</td><td>把分组从源节点转发到目的节点</td><td>路由选择、分组转发、拥塞控制、网际互联、差错控制、流量控制、连接管理、可靠传输管理</td><td>数据报（分组）</td><td>IP,ICMP,RIP,OSPF,BGP,IGMP</td></tr><tr><td><em><strong>联</strong></em></td><td>#2 数据<em><strong>链</strong></em>路层</td><td>确保相邻节点之间的链路逻辑上无差错</td><td><strong>差错控制、流量控制、寻址、成帧</strong></td><td>帧</td><td>PPP,ARP,RARP,MTU</td></tr><tr><td><em><strong>物</strong></em></td><td>#1<em><strong>物</strong></em>理层</td><td>实现相邻节点之间的比特的传输</td><td>需定义电路接口参数、信号的含义、电气特性等</td><td>比特</td><td>IEEE 802.1A,IEEE 802.2</td></tr></tbody></table><h4 id="1-2-2-2TCP-x2F-IP模型"><a href="#1-2-2-2TCP-x2F-IP模型" class="headerlink" title="1.2.2.2TCP&#x2F;IP模型"></a>1.2.2.2TCP&#x2F;IP模型</h4><table><thead><tr><th>口诀</th><th>TCP&#x2F;IP模型</th><th>任务</th><th>功能</th></tr></thead><tbody><tr><td>用</td><td>应用层</td><td>实现特定网络应用</td><td>略</td></tr><tr><td>叔</td><td>传输层</td><td>实现端到端（进程到进程）通信</td><td>复用和分用、差错控制、流量控制、连接管理。可靠传输管理</td></tr><tr><td>网</td><td>网络层</td><td>把分组从源节点转发到目的节点</td><td>路由选择、分组转发、拥塞控制、网际互联。不用考虑<em><strong>（差错控制、流量控制、连接管理、可靠传输管理）</strong></em></td></tr><tr><td>接</td><td>网络接口层</td><td><em><strong>实现相邻节点之间的数据传输（为网络层传输“分组”）</strong></em></td><td><em><strong>无具体规定</strong></em></td></tr></tbody></table><p><strong>OSI参考模型</strong>与<strong>TCP&#x2F;IP模型</strong>在应用层与网络接口层的区别</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240917122155005.png" alt="image-20240917122155005"></p><p><strong>OSI参考模型</strong>与<strong>TCP&#x2F;IP模型</strong>在传输层与网络层的区别</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240917122405985.png" alt="image-20240917122405985"></p><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-通信基础"><a href="#2-1-通信基础" class="headerlink" title="2.1 通信基础"></a>2.1 通信基础</h2><h3 id="2-1-1通信基础的基本概念"><a href="#2-1-1通信基础的基本概念" class="headerlink" title="2.1.1通信基础的基本概念"></a>2.1.1通信基础的基本概念</h3><p><strong>信源：</strong>信号来源，数据的发送方</p><p><strong>信宿：</strong>信号的“归宿”，数据的接收方</p><p><strong>信号：</strong>是数据的载体</p><p>​             <strong>数字信号：</strong>值是离散的</p><p>​              <strong>模拟信号：</strong>值是连续的</p><p><strong>信道：</strong>即信号的通道，分别对应模拟信道和数字信道</p><p><strong>码元：</strong>一个“信号周期”内可能出现几种信号？每一类信号就是一个码元。“码元宽度”：指的是一个“信号周期”的长度</p><p>若一个周期可能出现K种信号，就是K进制码元—-<strong>一码元携带log2(K)n&#x3D;bit</strong></p><p><strong>速率：</strong></p><p><strong>波特率：</strong>每秒传输几个码元。单位：码元&#x2F;秒，或<strong>波特（Baud）</strong></p><p><strong>比特率：</strong>每秒传输几个比特。单位：bit&#x2F;s,或b&#x2F;s,bps</p><p><strong>内在联系：</strong>一个码元携带几个比特</p><h3 id="2-1-2信道的极限容量"><a href="#2-1-2信道的极限容量" class="headerlink" title="2.1.2信道的极限容量"></a>2.1.2信道的极限容量</h3><p><strong>带宽：</strong>信道允许通过的信号频带范围。单位Hz</p><p><strong>噪声:</strong>  噪声会对信号的传播产生干扰，会影响信道的数据传输效果</p><p><strong>奈奎斯特定理：</strong></p><p><strong>无噪声</strong>情况下的信道的<strong>极限波特率</strong>&#x3D;2W（单位：波特，即码元&#x2F;秒）</p><p><strong>无噪声</strong>情况下信道的<strong>极限比特率</strong>&#x3D;<br>$$<br>2Wlog_2(K)（单位：bps)<br>$$<br>若一个码元有K种状态</p><p><strong>香农定理：</strong></p><p><strong>信噪比S&#x2F;N：</strong></p><p><strong>分贝记法</strong><br>$$<br>10lg(S&#x2F;N)(单位：dB)<br>$$<br>单位dB</p><p><strong>无单位记法</strong><br>$$<br>S&#x2F;N&#x3D;信号功率&#x2F;噪声功率<br>$$<br>有噪声情况下的信道的<strong>极限比特率</strong>&#x3D;<br>$$<br>Wlog_2(1+S&#x2F;N)(单位：b&#x2F;s)<br>$$<br>其中采用无单位记法</p><h3 id="2-1-3编码与调制"><a href="#2-1-3编码与调制" class="headerlink" title="2.1.3编码与调制"></a>2.1.3编码与调制</h3><p><strong>概念：</strong></p><p><strong>编码：</strong>二进制数据—&gt;数字信号，逆过程为“解码”</p><p><strong>调制：</strong>二进制数据—&gt;模拟信号，逆过程为“解调”</p><h4 id="2-1-3-1编码技术"><a href="#2-1-3-1编码技术" class="headerlink" title="2.1.3.1编码技术"></a>2.1.3.1编码技术</h4><p><strong>不归零编码（NRZ）：</strong>低0高1中不变。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918102708868.png" alt="image-20240918102708868"></p><p>**归零编码（RZ):**低0高1，中归零。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918102843971.png" alt="image-20240918102843971"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918102902470.png" alt="image-20240918102902470"></p><p><strong>反向非归零编码（NRZI）：</strong>跳0不跳1看起点，中不变</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103429195.png" alt="image-20240918103429195"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103503263.png" alt="image-20240918103503263"></p><p><strong>曼彻斯特编码：</strong>跳0反跳1看中间，中必变</p><p>①上0下1（考研常用标准）②下0上1</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103759010.png" alt="image-20240918103759010"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103752339.png" alt="image-20240918103752339"></p><p><strong>差分曼彻斯特编码：</strong>跳0不跳1看起点，中必变</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918104000451.png" alt="image-20240918104000451"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918104021251.png" alt="image-20240918104021251"></p><p>各种编码的特点：</p><p><strong>注：以太网默认使用曼彻斯特编码</strong></p><table><thead><tr><th>优缺点</th><th>不归零（NRZ)</th><th>归零（NR）</th><th>反向非归零（NRZI）</th><th>曼彻斯特</th><th>差分曼彻斯特</th></tr></thead><tbody><tr><td>自同步能力（时钟）</td><td>无</td><td>有</td><td>若能增加冗余位可实现自同步</td><td>有</td><td>有</td></tr><tr><td>浪费带宽</td><td>无</td><td>浪费</td><td>不太浪费</td><td>浪费</td><td>浪费</td></tr><tr><td>抗干扰能力</td><td>弱</td><td>弱</td><td>弱</td><td>强</td><td>强</td></tr></tbody></table><h4 id="2-1-3-2调制技术"><a href="#2-1-3-2调制技术" class="headerlink" title="2.1.3.2调制技术"></a>2.1.3.2调制技术</h4><ul><li><strong>调幅（AM）</strong>或<strong>幅移键控（ASK）</strong>：若信号波有K种振幅，则1码元&#x3D;log2K bit</li><li><strong>调频（FM）</strong>或<strong>频移键控（FSK）</strong>:     若信号波有K种频率，则1码元&#x3D;log2K bit</li><li><strong>调相（PM）</strong>或<strong>相移键控（PSK）</strong>：若信号波有K种相位，则1码元&#x3D;log2K bit</li></ul><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918104831646.png" alt="image-20240918104831646"></p><p><strong>正交幅度调制（QAM）</strong></p><p><strong>AM</strong>与<strong>PM</strong>结合，形成叠加信号，若有m种振幅，n种相位，则<strong>1码元&#x3D;log2mn bit</strong></p><p><strong>补充：</strong>QAM16的含义是采用QAM调制技术，有16种码元。</p><h2 id="2-2传输介质"><a href="#2-2传输介质" class="headerlink" title="2.2传输介质"></a>2.2传输介质</h2><p><strong>双绞线：</strong>两根导线相互绞合而成。有屏蔽层称为<strong>屏蔽双绞线（STP）</strong>，没有屏蔽层称为<strong>非屏蔽双绞线（UTP）</strong></p><p><strong>同轴电缆：</strong>内导体（用于传输信号）+外导体屏蔽层（用于抗电磁干扰）</p><p><strong>光纤：</strong>纤芯（高折射率）+包层（低折射率）。利用光的全反射特性，在纤芯内传输光脉冲信号</p><p>分类：</p><p><strong>单模光纤：</strong>只有一条光线在一根光纤中传输，适合长距离传输，信号传输损耗小。</p><p><strong>多模光纤：</strong>多条光线在一根光纤中传输，适合近距离传输，远距离传输光信号容易失真</p><p><em><strong>以上的传输介质都是导向性介质，从上至下，抗干扰能力依次增强，信号传输损耗依次降低</strong></em></p><p><strong>无线传输介质：</strong></p><p>本质都是<strong>电磁波</strong>，波长不同而已（长波-&gt;短波），波长与信号频率成反比</p><p>短波信号<strong>指向性强，</strong>数据<strong>传输能力强；</strong>长波信号<strong>绕射性好、指向性弱</strong></p><p><em><strong>注：卫星通信属于短波（或微波）通信</strong></em></p><p>物理层接口的特性</p><p><strong>机械特性：</strong>指明接口所用的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</p><p><strong>电气特性：</strong>指明在接口电缆的各条线上出现的电压的范围。传输速率。距离限制等</p><p><strong>功能特性：</strong>指明某条线上出现的某一电平的电压意义</p><p><strong>过程特性（规程特性）</strong>——指明对于不同功能的各种可能事件的出现顺序。</p><h2 id="2-3物理层设备"><a href="#2-3物理层设备" class="headerlink" title="2.3物理层设备"></a>2.3物理层设备</h2><p><strong>中继器：</strong></p><p>中继器只有两个端口。通过一个端口接收信号，将失真信号整形再生，并转发至另一端口（会产生一些时延）</p><p>仅支持半双工通信（两端连接的节点不可同时发送数据，会导致“冲突”</p><p>中继器两个端口对应两个“网段”</p><p><strong>集线器（Hub）</strong></p><p>本质上是多端口中继器。集线器将其中一个端口接收到的信号整形再生后，转发到所有其他端口。</p><p>各端口连接的节点不可同时发送数据，会导致“冲突”</p><p>集线器的N个端口对应N个“网段”，各网段属于同一个“冲突域”（同一冲突域的主机同时发送信号会导致“冲突”，因此需要“信道争用”。</p><p>一些特性</p><p><strong>集线器、中继器不能无限串联</strong></p><p><strong>集线器连接的网络，物理上是星型拓扑，逻辑上是总线型拓扑</strong></p><p><strong>集线器连接的各网段“共享带宽”</strong></p><p><strong>集线器可以连接不同的传输介质，因此两个网段的物理层接口特性可以不同(这就意味着集线器连接的网段，“物理层协议”可以不同)</strong></p><p><strong>集线器如果连接了速率不同的网段，会导致所有网段“速率向下兼容”</strong></p><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1数据链路层的功能"><a href="#3-1数据链路层的功能" class="headerlink" title="3.1数据链路层的功能"></a>3.1数据链路层的功能</h2><p><strong>封装成帧（组帧）</strong></p><p><strong>帧定界：</strong>如何让接收方能够确定帧的界限</p><p><strong>透明传输：</strong>接收方链路层要能从收到的帧内恢复原始的SDU，让网络层“感受不到”将分组封装成帧的过程。</p><p><strong>差错控制</strong>：发现并解决一个帧内部的“位错”</p><p>解决方案一：接收方发现比特错后<strong>丢弃帧</strong>，发送方<strong>重传帧</strong>（仅需采用 检错编码）</p><p>解决方法二：<strong>由接收方发现并纠正比特错误</strong>（需采用纠错编码）</p><p><strong>可靠传输：</strong>发现并解决“<strong>帧错</strong>”</p><p><strong>帧丢失：</strong>eg:发送帧①②③④，收到帧①②④</p><p><strong>帧重复：</strong>eg:发送帧①②③④，收到帧①②③③④</p><p><strong>帧失序：</strong>eg:发送帧①②③④，收到帧①③②④</p><p><strong>流量控制：</strong>控制发送方发送帧的速度别太快，让接收方来得及“接受”</p><p><strong>介质访问控制：</strong></p><p>“<strong>广播信道</strong>”需要实现此功能。广播信道在逻辑上是总线型拓扑，<strong>多个节点需争抢传输介质的使用权</strong></p><p>“<strong>点对点信道</strong>”通常不需要实现此功能。点对点信道通常意味着<strong>两个节点之间有专属的传输介质，不用抢。</strong></p><h2 id="3-2组帧（封装成帧）"><a href="#3-2组帧（封装成帧）" class="headerlink" title="3.2组帧（封装成帧）"></a>3.2组帧（封装成帧）</h2><p><strong>主要问题：</strong></p><p><strong>帧定界：</strong>如何让接收方能够确定帧的界限</p><p><strong>透明传输：</strong>接收方要能够去除“帧定界”的附加信息，把帧“恢复原貌”</p><p><strong>字符计数法：</strong></p><p>在每个帧开头，用一个定长的计数字段表示帧长</p><p><strong>注意</strong>：<strong>帧长&#x3D;计数字段长度+帧的数据部分长度</strong></p><p><strong>最大缺点：</strong>任何一个计数字段出错，都会导致后续所有帧无法定界</p><p><strong>字节填充法：</strong></p><p><strong>特殊字符：</strong>标记帧开头的字符SOH；标志帧结尾的字符EOT</p><p><strong>转义字符：</strong>ESC</p><p>如果帧的数据部分包含“<strong>特殊字符</strong>”，则发送方需要在这些“<strong>特殊字符</strong>”前填充“<strong>转义字符ESC</strong>”（<strong>接收方要做逆处理</strong>）</p><p><strong>零比特传输法：</strong></p><p>用特殊的比特串01111110标记帧开始、帧结尾</p><p>发送方需要对帧的数据部分进行处理，每当遇到了连续5个1，就填充一个0</p><p>接收方需要对帧的数据部分进行逆处理，每当遇到连续5个1，就删掉后面的0</p><p><strong>HDLC协议、PPP协议使用此方法</strong></p><p><strong>违规编码法：</strong></p><p>使用“<strong>违规信号</strong>”，表示帧的开头、结尾（这种方法需要物理层配合）</p><p>如：采用<strong>曼彻斯特编码</strong>时，使用“<strong>中间不跳变</strong>”作为“<strong>违规信号</strong>”，标记帧的开头、结尾。</p><h2 id="3-3差错控制"><a href="#3-3差错控制" class="headerlink" title="3.3差错控制"></a>3.3差错控制</h2><h3 id="3-3-1检错编码"><a href="#3-3-1检错编码" class="headerlink" title="3.3.1检错编码"></a>3.3.1检错编码</h3><h4 id="3-3-1-1奇偶校验"><a href="#3-3-1-1奇偶校验" class="headerlink" title="3.3.1.1奇偶校验"></a>3.3.1.1奇偶校验</h4><p><strong>概念：</strong></p><p><strong>信息位（有效数据）：</strong>指的是帧的“数据部分”</p><p><strong>校验位（冗余位）：</strong>即为了给帧的“数据部分”检错&#x2F;纠错而附加的一些冗余比特。</p><p><strong>校验原理</strong></p><p>在信息位的首部或尾部添加一个校验位</p><p>奇校验：整个校验码（信息位和校验位）中的“1”的个数为奇数</p><p>偶校验：整个校验码（信息位和校验位）中的“1”的个数为偶数</p><p>奇偶校验码仅<strong>能检测出奇数位错误，无法检测出偶数位错误，无纠错能力。</strong></p><p><strong>异或运算（模2加）</strong></p><p>两个比特进行异或运算，当二者“相异”时计算结果为1</p><p>将“偶校验”的信息位、校验位全部异或，若结果为0说明没有错误</p><h4 id="3-3-1-1循环冗余校验码"><a href="#3-3-1-1循环冗余校验码" class="headerlink" title="3.3.1.1循环冗余校验码"></a>3.3.1.1循环冗余校验码</h4><p><strong>构造：</strong></p><p>由生成多项式确定“除数”。若生成多项式中x的最高次为R，则“除数”有R+1位</p><p>K个信息位+R个0，作为“被除数”</p><p>被除数、除数进行“模二除”，的R位余数</p><p>K个信息位+R位余数&#x3D;CRC码</p><p><strong>校验：</strong></p><p>收到K+R位数据，与生成多项式模二除，计算R位余数</p><p>余数为0，说明无错误</p><p>余数非0，代表出错</p><p><strong>检错、纠错能力</strong></p><p>1.可检测出所有奇数个错误</p><p>2.可检测出所有双比特的错误</p><p>3.可检测出所有小于等于校验位长度的连续错误</p><p>4.若选择合适的生成多项式，且2^R&gt;&#x3D;K+R+1,则可纠正单比特错误</p><h3 id="3-3-2纠错编码"><a href="#3-3-2纠错编码" class="headerlink" title="3.3.2纠错编码"></a>3.3.2纠错编码</h3><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><p><strong>基本思想：</strong>分组偶校验，多个校验位可反映出错位置</p><p><strong>求解步骤：</strong></p><p>确定校验位个数（k个校验位，n个信息位）<br>$$<br>2^k&gt;&#x3D;n+k+1<br>$$<br><strong>确定校验位分布：</strong></p><p>P1,P2,P3..分别在1,2,4,8,16…</p><p>空出来其他位置依次填入信息位</p><p><strong>求校验位：</strong></p><p>将信息位的位置序号用k位二进制数表示出来</p><p>校验位Pi与位置序号第i位为1的信息位归为同一组，进行偶校验</p><p><strong>纠错：</strong></p><p>对P1,P2,P3..所属个分组进行异或（相当于分组偶校验）求得S1,S2,S3</p><p>S3 S2 S1&#x3D;000 说明无错误</p><p>S3 S2 S1≠000,则其值反映出错位置</p><p><strong>补充</strong></p><p>海明码有1位纠错，2位检错能力</p><p>为了区分1位错和2位错，还需添加“全校验位”对整体进行偶校验</p><p><strong>注意：有的题目位置编号可能是从小到大的，但处理方法雷同。</strong></p><h2 id="3-4流量控制与可靠信息传输"><a href="#3-4流量控制与可靠信息传输" class="headerlink" title="3.4流量控制与可靠信息传输"></a>3.4流量控制与可靠信息传输</h2><h3 id="3-4-1流量控制与滑动窗口机制"><a href="#3-4-1流量控制与滑动窗口机制" class="headerlink" title="3.4.1流量控制与滑动窗口机制"></a>3.4.1流量控制与滑动窗口机制</h3><p><strong>滑动窗口机制：</strong></p><p>发送窗口WT&#x3D;1，接收窗口WR&#x3D;1;</p><p>发送窗口WT&gt;1，接收窗口WR&#x3D;1;</p><p>发送窗口WT&gt;1，接收窗口WR&gt;1;</p><p><strong>发送窗口内的帧允许被发送。接受窗口内的帧允许被接受</strong></p><p><strong>确认机制</strong></p><p><strong>确认帧：</strong>ACK_i：若接收方收到i号帧，且没有检测出差错，需要给发送方返回确认帧ACK_i</p><p><strong>否认帧：</strong>NAK_i：若接收方收到i号帧，但检测出i号帧有差错，需要丢弃该帧，并给发送方返回否认帧NAK_i</p><p><strong>重传机制</strong></p><p><strong>超时重传：</strong>若发送方超时未收到ACK_i,则重传i号帧</p><p><strong>请求重传：</strong>若发送方收到NAK_i,则重传i号帧</p><p><strong>帧编号：</strong></p><p>为了支持以上机制正确运行，至少需要n bit给帧“编号”</p><p><strong>要求</strong><br>$$<br>W_T+W_R&lt;&#x3D;2^n<br>$$</p><h3 id="3-4-2停止等待协议（S-W）"><a href="#3-4-2停止等待协议（S-W）" class="headerlink" title="3.4.2停止等待协议（S-W）"></a>3.4.2停止等待协议（S-W）</h3><p><strong>滑动窗口机制：</strong>发送窗口WT&#x3D;1，接受窗口WR&#x3D;1；</p><p><strong>确认机制</strong>：确认帧：ACK_i：若接受方收到i号帧，且没有检测出“差错”，需要给发送方返回确认帧ACK_i</p><p><strong>重传机制：</strong>超时重传，若发送方超时未收到ACK_i,则重传i号帧</p><p><strong>帧编号：</strong>仅需1 bit给帧“编号”</p><p><strong>要求：</strong><br>$$<br>W_T+W_R&lt;&#x3D;2^n<br>$$<br><strong>回顾：</strong></p><h4 id="正常窗口移动"><a href="#正常窗口移动" class="headerlink" title="正常窗口移动"></a>正常窗口移动</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919165327357.png" alt="image-20240919165327357"></p><p>发送方发出数据帧Data0,接收方接受并验证正确，返回确认帧ACK0，并给出信息，下一个要传送的这&#x3D;帧是Data1</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919165445809.png" alt="image-20240919165445809"></p><p>接收方接收到对应的数据帧之后就会将接收窗口进行右移，右移到帧序号为1的帧上，</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919165623351.png" alt="image-20240919165623351"></p><p>发送方收到对应的确认帧之后就会将发送窗口向右移动继续下一轮次的发送</p><h4 id="异常情况1："><a href="#异常情况1：" class="headerlink" title="异常情况1："></a>异常情况1：</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170026919.png" alt="image-20240919170026919"></p><p>在发送方到接受方的信道中存在网络噪声等因素，数据帧因网络噪声等原因丢失，接受方一直收不到下一个帧。</p><p>解决机制：超时重传，发出一个帧后，发送方需要启动“计时器”，若计时器超时，就自动重传。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170526283.png" alt="image-20240919170526283"></p><p>重传之后，在这次的计时器超时之前，发送方就很有可能会收到确认帧，之后的进程就和以前一样了。</p><h4 id="异常情况2："><a href="#异常情况2：" class="headerlink" title="异常情况2："></a>异常情况2：</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170701065.png" alt="image-20240919170701065"></p><p>确认帧在传送过程中丢失</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170953936.png" alt="image-20240919170953936"></p><p>由于接收方已经接收到了对应的信息，所以接收窗口就会向右移动1位。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919171046355.png" alt="image-20240919171046355"></p><p>这会导致发送方在超时重传时发送到了当前滑动窗口的前一个帧的接收方位置上，这样接收方就收到了一个重复帧。帧序号落在接收窗口外：接收方完成两个动作①丢弃重复帧②返回重复帧的ACK。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919171729690.png" alt="image-20240919171729690"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919171746582.png" alt="image-20240919171746582"></p><p>发送方在收到了接受方发来的确认信息，发送窗口就可以继续向右移动</p><p>思考：在刚才的这个场景中，如果没有“帧序号”会发生什么？</p><p>答：接收方无法判别“重复帧”！</p><p>由于接收窗口和发送窗口的距离不超过1，因此用1bit表示帧序号足矣。</p><h4 id="异常情况3"><a href="#异常情况3" class="headerlink" title="异常情况3"></a>异常情况3</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919172247741.png" alt="image-20240919172247741"></p><p>接收方接收到错误的数据帧，接收方会将此帧丢弃，且不返回ACK、</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919172350699.png" alt="image-20240919172350699"></p><p>发送方超时未收到ACK自动对于ACK进行重传，这次的数据帧没有检测出差错，就可以继续进行以后的步骤。</p><h3 id="3-4-3后退N帧协议（GBN"><a href="#3-4-3后退N帧协议（GBN" class="headerlink" title="3.4.3后退N帧协议（GBN)"></a>3.4.3后退N帧协议（GBN)</h3><p><strong>滑动窗口机制：</strong>发送窗口WT&gt;1,接收窗口WR&#x3D;1</p><p><strong>确认机制：</strong>确认帧：ACK_i，若接收方收到i号帧，且没有检测出“差错”，需要给发送方返回确认帧ACK_i</p><p><strong>重传机制：</strong>超时重传，若发送方超时未收到ACK_i，则重传i号帧。</p><p><strong>帧编号：</strong></p><p>为了支持以上机制正确运行，至少需要用n bit给帧“编号”</p><p>要求<br>$$<br>W_T+W_R&lt;&#x3D;2^n<br>$$<br><strong>GBN的特殊规则：</strong></p><p>关于确认帧：接收方可以“累计确认”。即连续收到到多个数据帧时，可以仅返回最后一个帧的ACK（ACK_i代表接收方已收到i号帧及其之前的所有帧)</p><p>关于超时重传：若发送方超时未收到ACK_i,则重传i号帧，及其之后的所有帧</p><p><strong>要点：</strong></p><p>收到一个“非法帧”时，接收方会将此帧丢弃，并返回目前已接收的最后一个正确帧的ACK_i,以提醒发送方“后退”会i+1号重新发送</p><p>注：“非法帧”包括落在接收窗口之外的帧、检测出差错的帧</p><p><strong>缺点：</strong>如果接收方接受帧的速度很慢，或在信道误码率很高的情况下，可能会导致发送方的发送进度经常需要“后退”，传输效率低下。</p><h4 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919211300037.png" alt="image-20240919211300037"></p><p>三个发送窗口都发送数据，给接收方</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919211349714.png" alt="image-20240919211349714"></p><p>当接收方接受了一个帧之后，就可以移动接收窗口接受下一个帧</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919212756853.png" alt="image-20240919212756853"></p><p>以此类推，当整个发送窗口的帧都已经被接受了，最后一个帧的接受信息会被接收方发送给发送方，ACK_i表示接收方已经收到i号帧及其之前的所有帧</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213004293.png" alt="image-20240919213004293"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213034736.png" alt="image-20240919213034736"></p><p>之后向后移动完成对应的下一个发送窗口的帧的发送与接受</p><h4 id="异常情况1-数据帧丢失"><a href="#异常情况1-数据帧丢失" class="headerlink" title="**异常情况1 **数据帧丢失"></a>**异常情况1 **数据帧丢失</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213249647.png" alt="image-20240919213249647"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213312452.png" alt="image-20240919213312452"></p><p>当收到接受窗口之外的帧时，返回目前以正确接受的最后一个帧的ACK,完成对应的前序工作的整理。一号数据帧在接受窗口之外，直接丢弃</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240920112620791.png"></p><p>重新调整数据窗口，若i号帧超时，需要重传i号帧及其后续所有帧</p><p>为什么叫“后退”N帧协议，原本已经发送了1号帧，现在却后退回零号帧重新传送。这样即可实现“流量控制”</p><p>之后完成重传即可。</p><h4 id="异常情况2-确认帧丢失"><a href="#异常情况2-确认帧丢失" class="headerlink" title="异常情况2 确认帧丢失"></a>异常情况2 确认帧丢失</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213843058.png" alt="image-20240919213843058"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213935656.png" alt="image-20240919213935656"></p><p>这样第一个传送帧就会超时，之后所有的后续帧都要重传，但会被丢弃（因为已经传送过了）</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919214037617.png" alt="image-20240919214037617"></p><h4 id="探讨：如果不满足WT-WR-lt-x3D-2-n会出现什么问题"><a href="#探讨：如果不满足WT-WR-lt-x3D-2-n会出现什么问题" class="headerlink" title="探讨：如果不满足WT+WR&lt;&#x3D;2^n会出现什么问题"></a>探讨：如果不满足WT+WR&lt;&#x3D;2^n会出现什么问题</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919214146309.png" alt="image-20240919214146309"></p><p>超时后窗口的帧会发现不能确定这是新的帧，还是重传的旧帧，数据帧会被错误的接受。</p><h3 id="3-4-4选择重传协议（SR）"><a href="#3-4-4选择重传协议（SR）" class="headerlink" title="3.4.4选择重传协议（SR）"></a>3.4.4选择重传协议（SR）</h3><p><strong>滑动窗口机制：</strong>发送窗口WT&gt;1,接收窗口E&#x3D;WR&gt;1</p><p><strong>确认机制：</strong></p><p><strong>确认帧：</strong>ACK_i:若接收方收到i号帧，且没有检测出“差错”，需要给发送方返回确认帧ACK_i</p><p><strong>否认帧：</strong>NAK_i：若接收方收到i号帧，但检测出i号帧由”差错”，需要丢弃该帧，并给发送方返回否认帧NAK_i</p><p><strong>重传机制</strong></p><p><strong>超时重传：</strong>若发送方超时未收到ACK_i，则重传i号帧</p><p><strong>请求重传：</strong>若发送方收到NAK_i，则重传i号帧</p><p><strong>帧编号</strong></p><p>为了支持以上机制正确运行，至少需要用n bit给帧“编号”</p><p>要求<br>$$<br>W_T+W_R&lt;&#x3D;2^n；</p><p>W_R&lt;&#x3D;W_T,即接收窗口不能大于发送窗口</p><p>若接收窗口大于发送窗口，<br>则接收窗口永远不可能填满，接收窗口多出的空间就毫无意义。<br>$$</p><p><strong>要点</strong></p><p>若接受方检测出帧差错，则丢弃帧，并返回NAK_i，主动请求重传</p><p><strong>接收方不能“累计确认”，必须“一帧一确认”</strong></p><h4 id="正常情况："><a href="#正常情况：" class="headerlink" title="正常情况："></a>正常情况：</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223313596.png" alt="image-20240919223313596"></p><p>每个发送方都向接收方的帧窗口发送帧</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223502882.png"></p><p>每收到一个帧，接收窗口就可以向右平移一位。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223535445.png"></p><p>发送方每收到一个应答信息就可以平移一次发送窗口。</p><p>最后完成平移，依次进行。</p><h4 id="异常情况1：数据帧丢失"><a href="#异常情况1：数据帧丢失" class="headerlink" title="异常情况1：数据帧丢失"></a>异常情况1：数据帧丢失</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223746395.png" alt="image-20240919223746395"></p><p>其中的一个数据帧因通信故障丢失。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223808061.png" alt="image-20240919223808061"></p><p>由于出现了一个数据帧的丢失，所以对应的发送窗口和接收窗口的移动都会受到限制只能各移动一位</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224041546.png" alt="image-20240919224041546"></p><p>重传</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224056506.png" alt="image-20240919224056506"></p><p>重应答</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224113876.png" alt="image-20240919224113876"></p><p>完成最终的平移，以此类推。</p><h4 id="异常情况2-数据帧因差错而被丢弃"><a href="#异常情况2-数据帧因差错而被丢弃" class="headerlink" title="异常情况2:数据帧因差错而被丢弃"></a>异常情况2:数据帧因差错而被丢弃</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224329435.png" alt="image-20240919224329435"></p><p>检测出现错误，被接收方丢弃</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240920192203740.png"></p><p>返回5号“否认帧”</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224552444.png" alt="image-20240919224552444"></p><p>触发重传，0号是正常传递</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224630899.png" alt="image-20240919224630899"></p><p>之后一次完成发送窗口以及接收窗口的平移。</p><h4 id="异常情况3：确认帧丢失"><a href="#异常情况3：确认帧丢失" class="headerlink" title="异常情况3：确认帧丢失"></a>异常情况3：确认帧丢失</h4><p>与一般的确认帧丢失差不多。也会限制对应的发送帧的平移</p><h4 id="探讨：如果不满足WT-WR-lt-x3D-2-n会有什么问题？"><a href="#探讨：如果不满足WT-WR-lt-x3D-2-n会有什么问题？" class="headerlink" title="探讨：如果不满足WT+WR&lt;&#x3D;2^n会有什么问题？"></a>探讨：如果不满足WT+WR&lt;&#x3D;2^n会有什么问题？</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919225402153.png"></p><p>假设所有的ACK帧都丢失了。</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919225430320.png" alt="image-20240919225430320"></p><p>会有的重复帧被判定为正常帧，被接收方接收。</p><h3 id="3-4-5信道利用率的分析"><a href="#3-4-5信道利用率的分析" class="headerlink" title="3.4.5信道利用率的分析"></a>3.4.5信道利用率的分析</h3><p><strong>S-W</strong>,停止等待协议的信道利用率<br>$$<br>U&#x3D;T_D&#x2F;(T_D+RTT+TA)<br>$$<br>**TD:**一个数据帧的传输时延（发送时延）</p><p><strong>TA：</strong>一个ACK确认帧的传输时延（发送时延）</p><p><strong>RTT：</strong>往返时延，即两倍的单向传播时延</p><p><strong>注意：很多题目会忽略确认帧的传输时延TA</strong></p><p><strong>GBN&#x2F;SR，</strong>剩余两项协议的信道利用率<br>$$<br>U&#x3D;N*T_D&#x2F;(T_D+RTT+TA)<br>$$<br><strong>N</strong>表示发送窗口大小</p><p><strong>注意：信道利用率不能超过1</strong></p><p>常结合“<strong>帧编号</strong>”考察。</p><p>用n bit给帧“编号”，要求WT+WR&lt;&#x3D;2^n</p><p><strong>GBN协议的WR&#x3D;1,SR协议WR&gt;1.因此用同样多的比特数给帧编号，GBN的发送窗口WT更大，因此GBN的信道利用率也会很高。</strong></p><p><strong>术语补充</strong></p><p>滑动窗口协议：GBN或SR协议</p><p>ARQ协议：指的是S-W,GBN或SR协议</p><p>连续ARQ协议：GBN或SR协议</p><h2 id="3-5介质访问控制"><a href="#3-5介质访问控制" class="headerlink" title="3.5介质访问控制"></a>3.5介质访问控制</h2><h3 id="3-5-1信道划分介质访问控制"><a href="#3-5-1信道划分介质访问控制" class="headerlink" title="3.5.1信道划分介质访问控制"></a>3.5.1信道划分介质访问控制</h3><h4 id="时分复用（TDM"><a href="#时分复用（TDM" class="headerlink" title="时分复用（TDM)"></a>时分复用（TDM)</h4><p>将时间片（时间片大小固定），各节点依次分配一个时间片</p><h4 id="统计时分复用（STDM"><a href="#统计时分复用（STDM" class="headerlink" title="统计时分复用（STDM)"></a>统计时分复用（STDM)</h4><p>在时分复用 的基础上，按需分配时间片</p><h4 id="频分复用（FDM"><a href="#频分复用（FDM" class="headerlink" title="频分复用（FDM)"></a>频分复用（FDM)</h4><p>将信道的总频带拆分为几条互不相交的子频带，为每一个发送节点分配一条子频带</p><h4 id="波分复用（WDM"><a href="#波分复用（WDM" class="headerlink" title="波分复用（WDM)"></a>波分复用（WDM)</h4><p>本质上是光的频分复用（光的波长与频率有关）</p><h4 id="码分复用（CDM"><a href="#码分复用（CDM" class="headerlink" title="码分复用（CDM)(***)"></a>码分复用（CDM)(***)</h4><p>①给各节点分配专属“码片序列”</p><p><strong>“码片序列”</strong>包含m个码片（信号值），可看做<strong>“m维向量”（分量通常取1或-1）</strong></p><p>要求：各节点的“m维向量”<strong>必须相互正交</strong></p><p>Tips：相互通信的各节点知道彼此的“码片序列”</p><p>②发送方如何发送数据</p><p>节点发出m个信号值与<strong>“码片序列”相同</strong>，表示<strong>比特1</strong>；</p><p>节点发出m个信号值与<strong>“码片序列”不同</strong>，表示<strong>比特0</strong>；</p><p>③信号在传输过程中“叠加”</p><p>当多个发送方同时发送数据使，<strong>信号值会叠加</strong>（注：本质是多个m维向量的加法）</p><p>④接收方如何接收数据</p><p>接收方接收到的是“叠加”信号，需要从中“分离”出各发送方的数据</p><p>叠加信号与发送方的码片序列做“规格化内积”</p><p><strong>结果为1，表示比特1</strong></p><p><strong>结果为-1，表示比特0</strong></p><h3 id="3-5-2随机访问介质访问控制"><a href="#3-5-2随机访问介质访问控制" class="headerlink" title="3.5.2随机访问介质访问控制"></a>3.5.2随机访问介质访问控制</h3><h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><p><strong>纯ALOHA</strong></p><p>节点一旦准备好数据帧，就立即发送到信道上</p><p>若超时未收到ACK,随机等一段时间后重传</p><p><strong>时隙ALOHA</strong></p><p>“时隙”大小固定&#x3D;传输一个最长帧所需时间</p><p>各节点只能在时隙内传输帧，相比于纯ALOHA，降低了冲突的概率</p><h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><p><strong>1-坚持CSMA</strong></p><p>发送前先监听信道，若信道空闲立即发送数据帧（发送概率为1）</p><p>“坚持”意味着如果信道不空闲，节点会坚持监听信道</p><p><strong>非坚持CSMA</strong></p><p>可记忆为“1-非坚持”，即发送前先监听信道，若信道空闲立即发送数据帧（发送概率为1）</p><p>“非坚持”意味着如果信道不空闲，节点不会坚持监听信道，而是随机推迟一段时间后再尝试监听</p><p><strong>p-坚持CSMA</strong></p><p>发送前先监听信道，若信道空闲则以概率p立即发送帧，以概率1-p推迟一段时间再发送</p><p>“坚持”同上</p><h4 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><p><strong>协议要点：</strong></p><p>先听后发，边听边发，冲突停发，随机重发</p><p><strong>如何随机重发？</strong></p><p>截断二进制指数退避算法：</p><p>随机等待一段时间&#x3D;r倍争用期，其中r是随机数</p><p>①如果k&lt;&#x3D;10,在[0,(2^k-1)]区间随机取一个整数r</p><p>②如果k&gt;10,在[0,(2^10-1)]区间随机取一个整数r</p><p><strong>特别注意：</strong></p><p>第10次冲突，是“随机重发”的分水岭</p><p>第16次重发，直接躺平，放弃传帧，报告上级（网络层）</p><p><strong>争用期</strong>&#x3D;2*最大单向传播时延（考虑距离最远的两个节点）</p><p>若<strong>争用期</strong>内未发生冲突，就不可能再次发生冲突</p><p>CSMA&#x2F;CD<strong>没有ACK机制</strong>，若发送过程中未检测到冲突，就认为帧发送成功</p><p><strong>最短帧长</strong>&#x3D;2* 最大单向传播时延 *信道带宽</p><p>若收到的帧小于最短帧长，视为无效帧</p><p>原因：可能会导致所有的帧都已经发出了，但是在这之后的一段时间，一个冲突信息才感到，这样会被认为没有发生冲突，就算是当成冲突，也没有剩余的帧长可以用来收回了。</p><p><strong>最长帧长：</strong>规定最长帧长可防止某些节点一直占用信道。</p><p><strong>以太网规定：</strong>最短帧长&#x3D;64B；最长帧长&#x3D;1518B</p><h4 id="CSMA-x2F-CA协议"><a href="#CSMA-x2F-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h4><p><strong>协议要点：</strong></p><p>发送方：先听后发，忙则退避</p><p>若信道空闲，间隔DIFS（很长的时间）后，再发送帧（一口气发完，发送过程中不用检测冲突）</p><p>若信道不空闲，则进行“随机退避”</p><p><strong>“随机退避”原理</strong></p><p>①用二进制指数退避算法确定一段随机退避时间（倒计时）</p><p>②发送方会保持监听信道，只有信道空闲时才“扣除倒计时”，倒计时结束后立即发送帧（此时信道“听起来”一定空闲）</p><p><strong>接收方：停止等待协议</strong></p><p>每收到一个正确数据都返回ACK：若发送方超时未收到ACK，则进行“随机退避”</p><p><strong>信道预约机制（可选功能）</strong></p><p>①发送方广播RTS控制帧（先听后发，忙则退避）</p><p>②AP广播CTS控制帧（需在RTS、CTS中指明预约时长）</p><p>③其他无关节点收到CTS后自觉“禁言”一段时间（即：虚拟载波监听机制）；发送方收到CTS后，就可以发送数据帧</p><p>④AP收到数据帧后，进行CRC校验，若无差错就返回ACK帧</p><p><strong>帧间间隔IFS</strong></p><p>**DIFS,**最长的IFS</p><p>每次“帧事务”开始之前需要等待的时间</p><p>**SIFS,**最短的IFS</p><p>收到一个帧后需要预留的一段处理时间</p><p>**PIFS,**中等长度的IFS</p><p>考研不考虑PIFS</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240922202058917.png" alt="image-20240922202058917"></p><h3 id="3-5-3轮询访问：令牌传递协议"><a href="#3-5-3轮询访问：令牌传递协议" class="headerlink" title="3.5.3轮询访问：令牌传递协议"></a>3.5.3轮询访问：令牌传递协议</h3><p><strong>协议要点：</strong></p><p><strong>令牌帧</strong></p><p>需知明当前获得令牌的节点编号</p><p>只有获得令牌（Token）的节点才能往信道上发送数据帧</p><p>如果获得令牌的节点没有数据要发送，就将令牌传递下一个节点</p><p><strong>数据帧</strong>（发送数据时令牌帧转换成数据帧）</p><p>需指明数据帧的源地址和目的地址、是否已被接收、获得令牌的节点编号</p><p>数据帧从源节点发出，“传递一圈”后回到源节点</p><p>数据帧“传递一圈”过程中，会为<strong>目的节点</strong>复制一份数据，并将数据帧标记为<strong>“已接收”</strong></p><p>数据帧回到源节点后，如果发现异常状况，就尝试重发；若<strong>无异常</strong>，就<strong>将令牌传递下一个节点</strong></p><p><strong>其他补充：</strong></p><p>无论是令牌帧还是数据帧，都只能单向传递</p><p>获得令牌的节点，每次只能发一帧，发完就释放令牌</p><p>需要用专门的网络设备（MAU）实现<strong>集中控制</strong></p><p>令牌传递协议很<strong>适用于负载高</strong>的网络（不会发生冲突，效率高）（重发少））</p><h2 id="3-6局域网"><a href="#3-6局域网" class="headerlink" title="3.6局域网"></a>3.6局域网</h2><h3 id="3-6-0局域网与IEEE"><a href="#3-6-0局域网与IEEE" class="headerlink" title="3.6.0局域网与IEEE"></a>3.6.0局域网与IEEE</h3><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240930204125634.png" alt="image-20240930204125634"></p><h3 id="3-6-1局域网的基本概念和体系结构"><a href="#3-6-1局域网的基本概念和体系结构" class="headerlink" title="3.6.1局域网的基本概念和体系结构"></a>3.6.1局域网的基本概念和体系结构</h3><h4 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240930204432070.png" alt="image-20240930204432070"></p><h3 id="3-6-2以太网与IEEE-802-3"><a href="#3-6-2以太网与IEEE-802-3" class="headerlink" title="3.6.2以太网与IEEE 802.3"></a>3.6.2以太网与IEEE 802.3</h3><h4 id="3-6-2-1物理层标准"><a href="#3-6-2-1物理层标准" class="headerlink" title="3.6.2.1物理层标准"></a>3.6.2.1物理层标准</h4><p><strong>速度+Base+传输介质信息</strong></p><p>如：10Base5、10Base2–同轴电缆</p><p>如：10BaseT、100BaseTX、2.5GBaseT–双绞线</p><p>如：10BaseF、100BaseFX、40GBaseFR–光纤(很少考)</p><p><strong>key：如果一个网段工作在半双工模式下，才需要使用CSMA&#x2F;CD协议实现介质访问控制</strong></p><p><strong>做题技巧</strong></p><p><strong>同轴电缆网段</strong></p><p>仅支持半双工</p><p><strong>双绞线网段</strong></p><p>如果连接集线器，就只能工作在半双工模式下</p><p>如果连接交换机，就默认工作在全双工模式下</p><p><strong>光纤网段（很少考）</strong></p><p>仅支持<strong>全双工</strong></p><p>以太网的物理层使用<strong>曼彻斯特编码（跳0反跳1看中间，中必变）</strong></p><h4 id="3-6-2-2MAC层标准"><a href="#3-6-2-2MAC层标准" class="headerlink" title="3.6.2.2MAC层标准"></a>3.6.2.2MAC层标准</h4><p><strong>以太网MAC帧格式</strong></p><p>V2标准（默认） 662N4,收发协数验</p><p>802.3标准 662N4，收发长数验</p><p>N是46-1500</p><p><strong>一个MAC地址是6B,48bit。目的地址全1表示广播帧</strong></p><p>交换机会将受到的广播帧转发至其他端口</p><p>路由器不会转发广播帧</p><p><strong>物理层会在MAC帧前添加8B前导码（7同步、1定界）</strong></p><h3 id="3-6-3VLAN虚拟局域网"><a href="#3-6-3VLAN虚拟局域网" class="headerlink" title="3.6.3VLAN虚拟局域网"></a>3.6.3VLAN虚拟局域网</h3><p><strong>大型局域网需要面临的问题：</strong></p><p>整个局域网是一个很大的广播域，容易出现广播风暴。</p><p>不利于信息安全。</p><p><strong>VLAN的特征</strong></p><p>可将一个大型局域网分割成若干个较小的VLAN每个VLAN是一个广播域</p><p>需要使用支持VLAN功能的以太网交换机来实现</p><p><strong>每个VLAN对应一个VID</strong></p><p><strong>三种划分VLAN的方式</strong></p><p>基于接口</p><p>VID&lt;–&gt;接口号</p><p>基于MAC地址</p><p>VID&lt;–&gt;MAC地址</p><p>基于IP地址</p><p>VID&lt;–&gt;IP地址</p><p>这种方式可以让VLAN范围跨越路由器，让多个局域网的主机组成一个VLAN（需要网络层功能支持）</p><p><strong>802.1Q帧</strong></p><p><strong>主机与交换机</strong>之间，传输<strong>标准以太网帧</strong>（6 6 2 N 4，收发协数验）</p><p><strong>交换机与交换机</strong>之间（干线链路），传输<strong>802.1Q</strong>帧（6 6 <strong>4</strong> 2 N 4，收发<strong>V</strong>协数验）</p><p><strong>4</strong>字节<strong>V</strong>LAN标签&#x3D;16+4+<strong>12</strong>bit&#x3D;固定+随便+<strong>VID</strong>（<strong>V的构成</strong>）</p><h2 id="3-8数据链路层设备"><a href="#3-8数据链路层设备" class="headerlink" title="3.8数据链路层设备"></a>3.8数据链路层设备</h2><h3 id="3-8-1以太网交换机"><a href="#3-8-1以太网交换机" class="headerlink" title="3.8.1以太网交换机"></a>3.8.1以太网交换机</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>交换机&#x3D;多端口<strong>网桥</strong>（408大纲已经删除网桥）</p><p>交换机工作在数据链路层，可以根据目的MAC地址转发帧</p><h4 id="自学习功能（支持即插即用）"><a href="#自学习功能（支持即插即用）" class="headerlink" title="自学习功能（支持即插即用）"></a>自学习功能（支持即插即用）</h4><p><strong>交换表</strong></p><p>初始为空，记录[MAC地址，端口号]的对应关系</p><p>每<strong>收到一个帧</strong>，就将<strong>“发送方”</strong>的[MAC地址，端口号]更新到交换表</p><p>①如果<strong>不知道“接收方”在哪里</strong>，就把帧<strong>广播到除入口外的其他端口</strong></p><p>②如果<strong>知道“接收方”在哪里</strong>，就把帧<strong>精准转发至某个端口</strong></p><p>交换表中每个表项都有“有效时间”，<strong>过期表项自动作废</strong>，以防某些节点拔线跑路</p><h4 id="两种交换方式"><a href="#两种交换方式" class="headerlink" title="两种交换方式"></a>两种交换方式</h4><p><strong>直通交换</strong></p><p>只检查帧的目的MAC地址，以决定帧的转发端口</p><p>优点：转发时延低</p><p>缺点：不适用于需要速度匹配、协议转换或差错检测的线路</p><p><strong>存储转发转换</strong></p><p>先把帧完整地接受到交换机内部的高速缓存中，进行差错检测等必要处理，再根据交换表决定从哪个端口转发出去</p><p>优点：适用于需要速率匹配、协议转换或差错检测的线路</p><p>缺点：转发时延高</p><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="4-1网络层的功能"><a href="#4-1网络层的功能" class="headerlink" title="4.1网络层的功能"></a>4.1网络层的功能</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241101205456840.png" alt="image-20241101205456840"></p><h2 id="4-2-IPv4"><a href="#4-2-IPv4" class="headerlink" title="4.2 IPv4"></a>4.2 IPv4</h2><h3 id="4-2-1-IPv4分组的格式"><a href="#4-2-1-IPv4分组的格式" class="headerlink" title="4.2.1 IPv4分组的格式"></a>4.2.1 IPv4分组的格式</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107205838548.png" alt="image-20241107205838548"></p><ol><li><strong>版本</strong>。占4位。指的是IP的版本，IPv4数据包中的该字段值是4</li><li><strong>首部长度。</strong>占4位。以4B为单位，最大可表示的首部长度为60B（15*4B）。最常用的首部长度是20B（5乘以4B），该字段值是5，此时不使用任何可选字段。</li><li><strong>总长度。</strong>占16位。指的是首部和数据之和的长度，单位为字节，因此数据报的最大长度为65535B。以太网帧的最大传送单元（MTU）为1500B，因此当一个IP数据报封装成帧时，数据报的总长度（首部加数据）一定不能超过下面的数据链路层的MTU值</li><li><strong>标识。</strong>占16位。他是一个计数器，每产生一个数据报就加1，并赋值给标识字段</li><li><strong>标志。</strong>占3位。标志字段的最低位为MF，MF&#x3D;1表示后面还有分片，MF&#x3D;0表示最后一个分片、标志字段中间的一位是DF，只有当DF&#x3D;0时才允许分片。</li><li><strong>片偏移。</strong>占13位。他指出较长的数据报在分片后，某片在原数据报中的相对位置，片偏移以8B为偏移单位。除最后一个分片外，每个分片的长度一定是8B的整数倍</li><li><strong>生存时间。</strong>占8位。数据报在网络中可通过的路由器数的最大值，标识数据报在网络中的寿命，以确保数据报不会永远在网络中循环。路由器在转发数据报前，现将TTL减一。若TTL被减为0，则该数据报必须丢弃。</li><li><strong>协议。</strong>占8位。指出此数据报携带的数据使用何种协议，即数据报的数据部分应上交给哪个协议进行处理，如TCP,UDP等。其中值为<strong>6</strong>表示<strong>TCP</strong>，值为<strong>17</strong>表示<strong>UDP</strong></li><li><strong>首部检验和。</strong>占16位。它只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，都要重新计算首部检验和（有些字段，如生存时间。。。。）不检验数据部分可以减少计算的工作量、</li><li><strong>源地址字段。</strong>占4B，标识发送方的IP地址。</li><li><strong>目标地址字段。</strong>占4B，标识接收方的IP地址。</li></ol><p><strong>易错：</strong>除了最后一个分片外，其他每个分片的“数据部分”必须是8B的整数倍</p><h3 id="4-2-2-IP地址"><a href="#4-2-2-IP地址" class="headerlink" title="4.2.2 IP地址"></a>4.2.2 IP地址</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212143880.png" alt="image-20241107212143880"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212242485.png" alt="image-20241107212242485"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212354347.png" alt="image-20241107212354347"></p><p><strong>一些特殊的用途的IP地址</strong></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212456289.png" alt="image-20241107212456289"></p><h3 id="4-2-3子网划分，子网掩码"><a href="#4-2-3子网划分，子网掩码" class="headerlink" title="4.2.3子网划分，子网掩码"></a>4.2.3子网划分，子网掩码</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212823844.png" alt="image-20241107212823844"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212906369.png" alt="image-20241107212906369"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213033881.png" alt="image-20241107213033881"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213333299.png" alt="image-20241107213333299"></p><h2 id="4-3IPv6"><a href="#4-3IPv6" class="headerlink" title="4.3IPv6"></a>4.3IPv6</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213543824.png" alt="image-20241107213543824"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213521559.png" alt="image-20241107213521559"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213502015.png" alt="image-20241107213502015"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213620097.png" alt="image-20241107213620097"></p><p><strong>位数多，彻底解决了IP地址不够用的问题</strong>IPv6</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213709212.png" alt="image-20241107213709212"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213742029.png" alt="image-20241107213742029"></p><h2 id="4-4路由算法及路由协议"><a href="#4-4路由算法及路由协议" class="headerlink" title="4.4路由算法及路由协议"></a>4.4路由算法及路由协议</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214127781.png" alt="image-20241107214127781"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214237249.png" alt="image-20241107214237249"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214350839.png" alt="image-20241107214350839"></p><h3 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a>RIP协议及距离向量算法</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214621410.png" alt="image-20241107214621410"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214750666.png" alt="image-20241107214750666"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214910886.png" alt="image-20241107214910886"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215411724.png" alt="image-20241107215411724"></p><h3 id="OSPF协议及链路状态算法"><a href="#OSPF协议及链路状态算法" class="headerlink" title="OSPF协议及链路状态算法"></a><strong>OSPF协议及链路状态算法</strong></h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215540852.png" alt="image-20241107215540852"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215616889.png" alt="image-20241107215616889"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215714329.png" alt="image-20241107215714329"></p><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215814268.png" alt="image-20241107215814268"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215844525.png" alt="image-20241107215844525"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215913791.png" alt="image-20241107215913791"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220022511.png" alt="image-20241107220022511"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220103983.png" alt="image-20241107220103983"></p><h2 id="4-5IP组播"><a href="#4-5IP组播" class="headerlink" title="4.5IP组播"></a>4.5IP组播</h2><p>略</p><h1 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h1><p>5.1传输层提供的服务</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220440767.png" alt="image-20241107220440767"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220621755.png" alt="image-20241107220621755"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220858742.png" alt="image-20241107220858742"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221031989.png" alt="image-20241107221031989"></p><h2 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221213475.png" alt="image-20241107221213475"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221309028.png" alt="image-20241107221309028"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221419740.png" alt="image-20241107221419740"></p><p>UDP差错检验</p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221602144.png" alt="image-20241107221602144"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221743456.png" alt="image-20241107221743456"></p><h2 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h2><h3 id="5-3-1TCP结构"><a href="#5-3-1TCP结构" class="headerlink" title="5.3.1TCP结构"></a>5.3.1TCP结构</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221925513.png" alt="image-20241107221925513"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221939990.png" alt="image-20241107221939990"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222005762.png" alt="image-20241107222005762"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222445180.png" alt="image-20241107222445180"></p><p>原理与UDP雷同，计算检验和之前也需要添加12B 伪首部（只需将UDP 伪首部的协议字段的 17 改成6，UDP 长度字段改成 TCP 长度）</p><h3 id="5-3-2连接管理"><a href="#5-3-2连接管理" class="headerlink" title="5.3.2连接管理"></a>5.3.2连接管理</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222814427.png" alt="image-20241107222814427"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222835791.png" alt="image-20241107222835791"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222912482.png" alt="image-20241107222912482"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222928138.png" alt="image-20241107222928138"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223001982.png" alt="image-20241107223001982"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223056761.png" alt="image-20241107223056761"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223115096.png" alt="image-20241107223115096"></p><h3 id="5-3-3可靠传输，流量控制"><a href="#5-3-3可靠传输，流量控制" class="headerlink" title="5.3.3可靠传输，流量控制"></a>5.3.3可靠传输，流量控制</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223236033.png" alt="image-20241107223236033"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223320213.png" alt="image-20241107223320213"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223357503.png" alt="image-20241107223357503"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223503577.png" alt="image-20241107223503577"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223559678.png" alt="image-20241107223559678"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223619505.png" alt="image-20241107223619505"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223714965.png" alt="image-20241107223714965"></p><h3 id="5-3-4拥塞控制"><a href="#5-3-4拥塞控制" class="headerlink" title="5.3.4拥塞控制"></a>5.3.4拥塞控制</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224047888.png" alt="image-20241107224047888"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224135147.png" alt="image-20241107224135147"></p><h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><h2 id="6-1网络应用模型"><a href="#6-1网络应用模型" class="headerlink" title="6.1网络应用模型"></a>6.1网络应用模型</h2><h3 id="C-x2F-S模型，比如说百度网盘"><a href="#C-x2F-S模型，比如说百度网盘" class="headerlink" title="C&#x2F;S模型，比如说百度网盘"></a>C&#x2F;S模型，比如说百度网盘</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224619534.png" alt="image-20241107224619534"></p><h3 id="P2P模型，比如说BT种子"><a href="#P2P模型，比如说BT种子" class="headerlink" title="P2P模型，比如说BT种子"></a>P2P模型，比如说BT种子</h3><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224723432.png" alt="image-20241107224723432"></p><h2 id="6-2DNS解析"><a href="#6-2DNS解析" class="headerlink" title="6.2DNS解析"></a>6.2DNS解析</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224913614.png" alt="image-20241107224913614"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224941151.png" alt="image-20241107224941151"></p><h2 id="6-3FTP"><a href="#6-3FTP" class="headerlink" title="6.3FTP"></a>6.3FTP</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225038206.png" alt="image-20241107225038206"></p><h2 id="6-4电子邮件"><a href="#6-4电子邮件" class="headerlink" title="6.4电子邮件"></a>6.4电子邮件</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225129513.png" alt="image-20241107225129513"></p><h2 id="6-5万维网和HTTP"><a href="#6-5万维网和HTTP" class="headerlink" title="6.5万维网和HTTP"></a>6.5万维网和HTTP</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225231100.png" alt="image-20241107225231100"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225258837.png" alt="image-20241107225258837"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225311819.png" alt="image-20241107225311819"></p>]]></content>
    
    
    <summary type="html">有关openVZ</summary>
    
    
    
    <category term="计算机网络" scheme="http://interaction2023.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="openVZ" scheme="http://interaction2023.cn/tags/openVZ/"/>
    
  </entry>
  
  <entry>
    <title>操作系统笔记</title>
    <link href="http://interaction2023.cn/2024/10/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <id>http://interaction2023.cn/2024/10/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</id>
    <published>2024-10-01T01:58:39.764Z</published>
    <updated>2024-10-12T04:02:51.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><h2 id="2-1线程的属性"><a href="#2-1线程的属性" class="headerlink" title="2.1线程的属性"></a>2.1线程的属性</h2><p>①线程是处理机调动的单位。</p><p>②多cpu计算机中，各个线程可占用不同的CPU</p><p>③每个线程都有一个线程ID，线程控制块(TCB)</p><p>④线程也有就绪，阻塞运行三种基本状态</p><p>⑤线程几乎不拥有任何系统资源</p><p>⑥同一进程的不同线程间共享进程的资源。</p><p>⑦由于共享内存地址空间，同一进程的线程间通信甚至无需系统干预</p><p>⑧同一进程中的线程切换不会引起进程切换</p><p>⑨与⑧相反</p><p>⑩切换同进程内的线程，系统开销很小</p><p>⑪切换进程，系统开销很小。</p><h2 id="2-2调度"><a href="#2-2调度" class="headerlink" title="2.2调度"></a>2.2调度</h2><h3 id="三种调度的联系对比"><a href="#三种调度的联系对比" class="headerlink" title="三种调度的联系对比"></a>三种调度的联系对比</h3><table><thead><tr><th>调度方法</th><th>细节描述</th><th>数据流动方向</th><th align="center">发生频率</th><th align="center">状态转换</th></tr></thead><tbody><tr><td>高级调度（作业调度）</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td>外存-&gt;内存（面向作业）</td><td align="center">发生频率最低</td><td align="center">不存在-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度（内存调度）</td><td>按照某种规则，从挂起队列中选择合适的进程将数据调回内存。</td><td>外存-&gt;内存（面向进程）</td><td align="center">中等</td><td align="center">挂起态-&gt;就绪态（阻塞挂起）-&gt;阻塞态</td></tr><tr><td>低级调度（进程调度）</td><td>按照某种规则从就绪队列中选择一个进程为其分配处理机</td><td>内存-&gt;CPU</td><td align="center">最高</td><td align="center">就绪态-&gt;运行态</td></tr></tbody></table><h3 id="需要进行切换的调度与切换状况"><a href="#需要进行切换的调度与切换状况" class="headerlink" title="需要进行切换的调度与切换状况"></a>需要进行切换的调度与切换状况</h3><table><thead><tr><th align="left">当前运行的进程主动放弃处理机</th><th align="left">①进程正常终止②运行过程中出现异常而终止③进程主动请求阻塞</th></tr></thead><tbody><tr><td align="left">当前运行的进程被动放弃处理机</td><td align="left">①分给进程的时间片用光②有更紧急的是需要处理（如优先级调度剥夺形式的短作业（进程）优先调度或者I&#x2F;O中断)③有更高优先级的进程进入就绪队列</td></tr></tbody></table><p>小知识点</p><p>进程在操作系统内核程序临界区中不能进行地调度与切换</p><p><strong>临界资源：</strong>一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源</p><p><strong>临界区：</strong>访问临界资源的那段代码</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p><p>如果还没有退出临界区（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利地进行进程调度</p><p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理操作。因此访问内核程序临界区期间不能进行调度与切换。</p><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理操作。因此在访问普通临界区时可以进行调度与切换。</p><h3 id="2-2-1-习题"><a href="#2-2-1-习题" class="headerlink" title="2.2.1 习题"></a>2.2.1 习题</h3><p>为什么说多级反馈队列调度算法能较好地满足各类用户的需要？</p><p>多级反馈队列调度算法能够较好的满足各种类型用户的需要。对终端型作业用户而言，由于他们所提交的作业大多属于交互性作业，作业通常比较短小，系统只要能使这类作业在第一梯队队列对规定的时间片内完成，便可使终端型作业用户得到满意：对于短批处理作业用户而言，他们与终端型作业用户一样，只要能在对应的给定的时间片内完成，便可获得与终端作业用户一样的响应时间。对于稍长的作业，通常也只需要在第二个队列与第三级队列中各运行一个时间片即可完成，其周转时间依旧较短。对于长批处理作业用户而言，他们的长作业将一次在1-n级队列完成，然后按照时间片轮转的方式运行，用户不必担心作业长期得不到处理。</p><h2 id="2-3同步与互斥"><a href="#2-3同步与互斥" class="headerlink" title="2.3同步与互斥"></a>2.3同步与互斥</h2><h3 id="2-3-1同步互斥"><a href="#2-3-1同步互斥" class="headerlink" title="2.3.1同步互斥"></a>2.3.1同步互斥</h3><p><strong>进程同步：</strong>并发性带来了异步性，有时需要通过进程同步解决这种异步问题。有的进程之间需要相互配合的完成工作，各进程之间的工作推进需要遵循一定的先后顺序。</p><p><strong>进程互斥：</strong>对进程临界资源的访问，需要互斥的进行，即同一时间段内只允许一个进程访问该资源。</p><p>四个部分：</p><p><strong>进入区：</strong>检查是否可进入临界区，若可进入则需“上锁”</p><p><strong>临界区：</strong>用来访问临界资源的那段代码。</p><p><strong>退出区：</strong>负责解锁</p><p><strong>剩余区：</strong>其余代码部分</p><p>需要遵循的原则：</p><p><strong>空闲让进：</strong>临界区空闲时，应允许一个进程访问。</p><p><strong>忙则等待：</strong>临界区正在被访问时，其他试图访问的进程需要等待</p><p><strong>有限等待：</strong>要在有效时间内进入临界区，保证不会饥饿</p><p><strong>让权等待：</strong>进不了临界区的进程，要释放处理机，防止忙等</p><h4 id="2-3-1-1进程互斥的软件实现方法"><a href="#2-3-1-1进程互斥的软件实现方法" class="headerlink" title="2.3.1.1进程互斥的软件实现方法"></a>2.3.1.1进程互斥的软件实现方法</h4><h5 id="单标志法："><a href="#单标志法：" class="headerlink" title="单标志法："></a>单标志法：</h5><p>在进入区只做“检查”，不上锁，在退出区把临界区的使用权转交给另一个进程（相当于在退出区既给另一进程解锁）</p><p><strong>主要问题：</strong>不遵循空闲让进的原则。</p><p>该算法可以实现每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程在某一时刻不在进入临界区，则另一个进程也无法进入临界区（不遵循空闲让进的原则）这样很容易造成资源利用不充分。</p><p><strong>通俗解释：</strong>若P0顺利进入临界区并从临界区离开，则此时临界区是空闲的，但P1并没有进入临界区的打算，而turn&#x3D;1一直成立，则P0就无法再次进入临界区。</p><h5 id="双标志先检查法："><a href="#双标志先检查法：" class="headerlink" title="双标志先检查法："></a>双标志先检查法：</h5><p>在进入区先“检查”后“上锁”，退出区“解锁”（检查对方的标志，设置自己的标志）</p><p><strong>优点：</strong>不用交替进入，可连续使用</p><p><strong>主要问题：</strong>不遵循“忙则等待”原则。</p><p><strong>缺点：</strong>P0和P1可能同时进入临界区。即检查对方标志后和设置自己的标志前可能发生进程切换，结果双方都被检查通过，会同时即进入临界区（不遵循“忙则等待”原则）原因是在于检查对方标志和设置自己标志两个过程不能一气呵成。</p><p><strong>通俗解释：</strong>在进入临界区之后有可能在被上锁之前就会另一个进程可以避过另一个进程进入临界区的锁，直接两个进程全部使用临界资源。</p><h5 id="双标志后检查法："><a href="#双标志后检查法：" class="headerlink" title="双标志后检查法："></a>双标志后检查法：</h5><p>再进区先“加锁”后检查，退出区“解锁”</p><p><strong>主要问题：</strong>不遵循“空闲让进，有限等待”原则，可能导致饥饿</p><p>即两个进程依次设置自己的标志，并依次检查对方的标志，发现对方也想进入临界区，双方都争着进入临界区，结果谁都进不了（违背“空闲让进”原则）于是各进程都长期无法访问临界区而导致“饥饿现象”（违背有限等待原则）</p><p><strong>通俗解释：</strong></p><p>你等我不想进去，我等你不想进去，最后谁都想去，谁也进不去</p><h5 id="peterson算法："><a href="#peterson算法：" class="headerlink" title="peterson算法："></a>peterson算法：</h5><p>在进入区“主动争取，主动谦让，检查对方是否想进，己方是否谦让”</p><p><strong>主要问题：</strong>不遵循“让权等待”原则，会发生忙等</p><p><strong>一般是最后一个表示意愿的就是最终两个人合作的意愿。</strong></p><h4 id="2-3-1-2进程互斥的硬件实现方法"><a href="#2-3-1-2进程互斥的硬件实现方法" class="headerlink" title="2.3.1.2进程互斥的硬件实现方法"></a>2.3.1.2进程互斥的硬件实现方法</h4><h5 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h5><p>使用“开关中断”指令实现</p><p><strong>优点：</strong>简单高效</p><p><strong>缺点：</strong>只适用于单处理机；只适用于操作系统内核进程。</p><p><strong>这种方法的缺点：</strong></p><p>①限制了CPU交替执行程序的能力，因此系统效率会明显降低</p><p>②对内核来说，在它执行更新变量的几条指令期间，关中断时很方便的，但将关中断权限交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p><p>③不适用于多处理器系统，因为在一个CPU上关中断并不能防止进程在其他的CPU上执行相同的临界区代码。</p><h5 id="Test-and-Set-TS-x2F-TSL指令"><a href="#Test-and-Set-TS-x2F-TSL指令" class="headerlink" title="Test and Set(TS&#x2F;TSL指令)"></a>Test and Set(TS&#x2F;TSL指令)</h5><p>old记录是否已经被上锁；</p><p>再将lock设为true；</p><p>检查临界区是否已经被上锁</p><p>（若已上锁，则循环重复前几步）</p><p><strong>优点：</strong>实现简单，适用于多处理器环境</p><p><strong>缺点：</strong>不满足“让权等待”</p><h5 id="Swap指令（XCHG指令）"><a href="#Swap指令（XCHG指令）" class="headerlink" title="Swap指令（XCHG指令）"></a>Swap指令（XCHG指令）</h5><p>逻辑上和上面的指令一样。</p><h5 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h5><p>整型信号量：用一个整数型变量作为信号量，数值表示某种资源数，整型信号量与普通整型变量区别：对信号量只能执行初始化,p,v,两种操作。</p><p>整型信号量的问题：不满足让权等待原则。</p><p>记录型信号量：S.value表示某种资源数，S.L指向等待该资源的队列,</p><p>P操作中一定是先S.value–,之后可能需要执行block原语。</p><p>V操作中一定是先S.value++,之后可能需要执行wake up原语。</p><p>注意要能够自己腿短在什么条件下需要执行block或wake up</p><p>可以用记录型信号量实现系统资源的“申请”和“释放”</p><p>可以用记录型信号量实现进程互斥，进程同步。</p><p>信号量机制实现进程同步互斥和前驱关系</p><h4 id="2-3-1-3进程互斥同步的基本问题"><a href="#2-3-1-3进程互斥同步的基本问题" class="headerlink" title="2.3.1.3进程互斥同步的基本问题"></a>2.3.1.3进程互斥同步的基本问题</h4><h5 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a><strong>实现进程互斥</strong></h5><p>分析问题：确定临界区</p><p>设置互斥信号量：<strong>初值为1</strong></p><p>临界区之前对信号量执行P操作</p><p>临界区之后对信号量执行V操作</p><h5 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a><strong>实现进程同步</strong></h5><p>分析问题：找出哪里需要实现“一前一后”的同步关系</p><p>设置同步信号量，<strong>初始值为0；</strong></p><p>在“前操作”之后执行V操作</p><p>在“后操作”之前执行P操作</p><h5 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h5><p>分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题</p><p>为每对前驱关系设置同步信号量，初值为0</p><p>在“前操作”之后执行V操作</p><p>在“后操作”之前执行P操作</p><p>本质是多级同步问题。</p><p>除了互斥，同步关系之外，还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行V操作即可</p><h3 id="2-3-2常见的几个经典互斥同步问题"><a href="#2-3-2常见的几个经典互斥同步问题" class="headerlink" title="2.3.2常见的几个经典互斥同步问题"></a>2.3.2常见的几个经典互斥同步问题</h3><p>PV操作题目的解题思路</p><p>1.关系分析。找出题目中描述的各个进程，分析他们之间的同步、互斥关系</p><p>2.整理思路。根据各进程的操作流程确定PV操作的大致顺序</p><p>3.设置信号量：设置需要的信号量，并根据题目条件确定信号量初值。（互斥）信号量初值一般为1，同步信号量的初值要看对应资源的初始值是多少。</p><h4 id="2-3-2-1生产者消费者问题"><a href="#2-3-2-1生产者消费者问题" class="headerlink" title="2.3.2.1生产者消费者问题"></a>2.3.2.1生产者消费者问题</h4><p>生产者消费者问题是一个互斥、同步的综合问题</p><p>对于初学者来说最难的是发现题目中隐含的两对同步关系</p><p>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后”问题，因此需要设置两个同步信号量。</p><p><img src="/2024/10/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20240921174455888.png" alt="image-20240921174455888"></p><p>易错点：实现互斥和实现同步的两个P操作的前后顺序（死锁问题）</p><p>自己理解：生产者只有满足缓冲区条件则可以开始生产，如果开始加锁之后在进行生产，又发现无法生产，而消费者也先检查互斥关系的锁导致消费者也没有办法进行消费，这样就既不能生产，也不能消费，死锁形成、</p><h4 id="2-3-2-2多生产者—多消费者问题"><a href="#2-3-2-2多生产者—多消费者问题" class="headerlink" title="2.3.2.2多生产者—多消费者问题"></a>2.3.2.2多生产者—多消费者问题</h4><p>解决”多生产者—多消费者问题”的关键在于理清复杂的同步关系</p><p>在分析同步问题（一前一后）问题的时候不能从单个进程行为的角度来分析要把“一前一后”发生的事看做是两种“事件”的先后关系</p><p>比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：</p><p>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才可以放入水果</p><p>如果盘子里装有橘子，那么一定要女儿取走橘子后父亲或母亲才可以放入水果</p><p>这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系？</p><p>正确的分析方法应该是从“事件”的角度来考虑我们可以把上述四对“进程行为的前后关系”抽象为一对“时间的先后关系”</p><p>盘子变空事件–&gt;放入水果事件“盘子变空事件即可以由儿子引发，也可以由女儿引发</p><p>“放水果事件”既可能是父亲执行，也可能是母亲执行，这样的话，就可以用一个同步信号量解决问题了</p><h4 id="2-3-2-3吸烟者问题"><a href="#2-3-2-3吸烟者问题" class="headerlink" title="2.3.2.3吸烟者问题"></a>2.3.2.3吸烟者问题</h4><p>吸烟者问题可以为我们解决“可以生产多个商品的单生产者”问题提供一个思路</p><p>值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要轮流的在桌子上放上组合1,2,3.注意体会我们是如何用一个整型变量；实现这个“轮流”过程的，若一个生产者要生产多种产品（或者说会引发多种前驱事件）那么各个V操作应该放在格子对应的“事件”发生之后的位置。</p><h4 id="2-3-2-4读者写者问题"><a href="#2-3-2-4读者写者问题" class="headerlink" title="2.3.2.4读者写者问题"></a>2.3.2.4读者写者问题</h4><p>读者–写者问题为我们解决复杂的互斥问题提供了一个参考思路</p><p>其核心思想在于设置一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理</p><p>另外，对count的检查和赋值不能一气呵成导致了一个错误，如果需要实现“一气呵成”，必须要使用互斥信号量。最后，还要认真体会我们是如何解决“写进程饥饿”问题。绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p><h4 id="2-3-2-5哲学家进餐问题"><a href="#2-3-2-5哲学家进餐问题" class="headerlink" title="2.3.2.5哲学家进餐问题"></a>2.3.2.5哲学家进餐问题</h4><p>哲学家进餐问题的关键在于解决进程死锁。</p><p>这些进程之间仅存在互斥关系，但是与之前接触到的互斥关系不同的是，每个</p><p>进程都需要同时执有两个临界资源，因此就有了“死锁”的问题的隐患。</p><p>如果考试中遇到了一个进程需要同时执有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁，可以参考哲学家问题解决死锁的三种思路</p><p><strong>①</strong>五个哲学家只允许四个哲学家拿筷子，第五个哲学家拿筷子时会被阻塞，等禁食的某个哲学家结束进食放下筷子，第五个哲学家才可以不去思考去拿起筷子。</p><p><strong>②</strong>使相邻的奇偶编号哲学家不去同时抢左侧或同时取右侧的一个筷子而造成死锁，只有（会造成无死锁的情况）</p><p><strong>③</strong>当一名哲学家左右两边的筷子都可用时，才允许他抓取筷子，抓筷子的过程中不允许中断，两边筷子全要抓起来。</p><h3 id="2-3-4管程"><a href="#2-3-4管程" class="headerlink" title="2.3.4管程"></a>2.3.4管程</h3><h4 id="2-3-4-1为什么要引入管程？"><a href="#2-3-4-1为什么要引入管程？" class="headerlink" title="2.3.4.1为什么要引入管程？"></a>2.3.4.1<strong>为什么要引入管程？</strong></h4><p>解决信号量机制编程麻烦，易出错的问题。</p><h4 id="2-3-4-2组成"><a href="#2-3-4-2组成" class="headerlink" title="2.3.4.2组成"></a>2.3.4.2组成</h4><p>共享数据结构，对数据结构初始化的语句，一组用来访问数据结构的过程（函数）</p><h4 id="2-3-4-3基本特征"><a href="#2-3-4-3基本特征" class="headerlink" title="2.3.4.3基本特征"></a>2.3.4.3基本特征</h4><p>各外部进程&#x2F;线程只能通过管程提供的特定“入口”才能访问共享数据。</p><p>每次仅允许一个进程在管程内执行某个内部过程</p><h4 id="2-3-4-4补充"><a href="#2-3-4-4补充" class="headerlink" title="2.3.4.4补充"></a>2.3.4.4补充</h4><p>各进程必须互斥访问管程的特性是由编译器实现的可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题。</p><h4 id="2-3-4-5拓展1-用管程解决生产者消费者问题"><a href="#2-3-4-5拓展1-用管程解决生产者消费者问题" class="headerlink" title="2.3.4.5拓展1 用管程解决生产者消费者问题"></a>2.3.4.5拓展1 用管程解决生产者消费者问题</h4><p>引入管程的目的无非就是要更方便地实现进程的互斥和同步</p><p>1.需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</p><p>2.需要在管程中定义用于访问这些共享数据的“入口”–其实是就是一些函数（如生产者，消费者），问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数从缓冲区取出产品</p><p>3.只有通过这些特定的“入口”才能访问共享数据</p><p>4.管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或“线程进入（如生产者，消费者问题中，各进程需要互斥地访问共享缓冲区，管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的。</p><p>5.可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题，可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出入口），可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</p><p>程序员可以用某种特殊的语法定义一个管程（比如monitor .producer,consumer,end monitor)之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步互斥了（封装思想）</p><h2 id="2-4死锁"><a href="#2-4死锁" class="headerlink" title="2.4死锁"></a>2.4死锁</h2><h3 id="2-4-1什么是死锁？"><a href="#2-4-1什么是死锁？" class="headerlink" title="2.4.1什么是死锁？"></a>2.4.1<strong>什么是死锁？</strong></h3><p>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进</p><h3 id="2-4-2死锁、饥饿、死循环的区别"><a href="#2-4-2死锁、饥饿、死循环的区别" class="headerlink" title="2.4.2死锁、饥饿、死循环的区别"></a>2.4.2<strong>死锁、饥饿、死循环的区别</strong></h3><p>死锁：至少是两个进程一起死锁，死锁进程处于阻塞态。</p><p>饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可以是就绪态</p><p>死循环：可能有一个进程陷入死循环，死循环的进程可以上处理机</p><p>死锁和饥饿是操作系统要解决的问题，死循环是应用程序员来解决的</p><h3 id="2-4-3死锁产生的必要条件"><a href="#2-4-3死锁产生的必要条件" class="headerlink" title="2.4.3死锁产生的必要条件"></a>2.4.3<strong>死锁产生的必要条件</strong></h3><p><strong>互斥条件：</strong>对必须互斥使用的资源的争抢才会导致思索</p><p><strong>不剥夺条件：</strong>进程保持的资源只能主动释放，不可强行剥夺</p><p><strong>请求和保持条件</strong>：保持着某些资源不放的同时，请求别的资源</p><p><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，循环等待未必死锁，死锁必然循环等待</p><h3 id="2-4-4什么时候会发生死锁"><a href="#2-4-4什么时候会发生死锁" class="headerlink" title="2.4.4什么时候会发生死锁"></a>2.4.4<strong>什么时候会发生死锁</strong></h3><p>对不可剥夺资源的不合理分配，可能导致死锁</p><h3 id="2-4-5死锁的处理策略"><a href="#2-4-5死锁的处理策略" class="headerlink" title="2.4.5死锁的处理策略"></a>2.4.5<strong>死锁的处理策略</strong></h3><p>预防死锁（破坏死锁产生的四个必要条件）</p><p>避免死锁（避免系统进入不安全状态）</p><p>死锁的检测和解除（允许死锁发生，系统负责检测出死锁后解除）</p><p>预防死锁</p><h4 id="2-4-5-1预防死锁"><a href="#2-4-5-1预防死锁" class="headerlink" title="2.4.5.1预防死锁"></a>2.4.5.1预防死锁</h4><h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><p>将临界资源改造为可共享的资源（如SPOOLing技术）</p><p>缺点：可行性不高，很多时候无法破坏互斥条件</p><h5 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h5><p>方案一：申请的资源得不到满足时，立即释放所拥有的全部资源</p><p>方案二：申请的资源被其他进程占用时，由操作系统协助剥夺资源（考虑优先级）</p><p>缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放资源会导致系统开销大，可能导致饥饿</p><h5 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h5><p>运行前分配好所有需要的资源，之后一直保持。</p><p>缺点：资源利用率低；可能导致饥饿</p><h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><p>给资源编号，必须按照编号从小到大的顺序申请资源</p><p>缺点；不方便添加新设备，会导致资源浪费用户编程困难。</p><h4 id="2-4-5-2避免死锁"><a href="#2-4-5-2避免死锁" class="headerlink" title="2.4.5.2避免死锁"></a>2.4.5.2避免死锁</h4><p><strong>银行家算法</strong></p><p>数据结构：</p><p>长度为m的一维数组Available表示还有多少可有资源</p><p>n*m矩阵Max代表各进程对资源的最大需求数</p><p>n*m矩阵Allocation表示已经给各进程分配了多少资源</p><p>Max-Allocation&#x3D;Need矩阵表示各进程最多还需要多少资源</p><p>用长度为N的一位数组request表示进程此次申请的各种资源数。</p><p>银行家算法步骤</p><p>①检查此次申请是否超过了之前声明的最大需求数。</p><p>②检测此时系统剩余的可用资源是否还能满足这次请求。</p><p>③试探着分配，更改数据结构</p><p>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p>安全型算法步骤：</p><p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程持有的资源全部回收</p><p>不断重复上述过程，看最终是否能让所有进程都加入安全序列</p><p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态，系统处于安全 状态一定不会产生死锁。</p><h4 id="2-4-5-3死锁的检测和解除"><a href="#2-4-5-3死锁的检测和解除" class="headerlink" title="2.4.5.3死锁的检测和解除"></a>2.4.5.3死锁的检测和解除</h4><p><strong>如何检测：</strong></p><p><strong>数据结构（资源分配图）</strong></p><p>两种节点：进程节点，资源节点</p><p>两种边：进程节点-&gt;资源节点（请求边），资源节点-&gt;进程节点（分配边）</p><p><strong>死锁检测算法</strong>：依次消除与不阻塞进程相连的边，知道无边可消</p><p>注：所谓不阻塞进程是指其申请的资源数不足够进程</p><p><strong>死锁定理</strong>：若资源分配图是不可完全简化的，说明发生了死锁（题中会给出资源分配图）</p><p>不过也要小心与数据及结构结合考察</p><p><strong>如何解除死锁：</strong></p><p>资源剥夺法，撤销进程法（终止进程法）进程回退法</p><h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><h2 id="3-1内存管理"><a href="#3-1内存管理" class="headerlink" title="3.1内存管理"></a>3.1内存管理</h2><h3 id="3-1-1内存管理的基本原理和要求"><a href="#3-1-1内存管理的基本原理和要求" class="headerlink" title="3.1.1内存管理的基本原理和要求"></a>3.1.1内存管理的基本原理和要求</h3><h4 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h4><p><strong>什么是内存，有何作用？</strong></p><p>存储单元，内存地址的概念和联系。</p><p>按字节编址vs按字编址</p><p>指令的工作原理 操作码+若干参数（可能包含地址参数）</p><p>逻辑地址（相对地址）vs物理地址（绝对地址）</p><p><strong>从写程序到程序运行</strong></p><p>编译源代码文件</p><p>编译：由源代码文件生成目标模块（高级语言“翻译”为机器语言）</p><p>链接：由目标模块生成装入模块，链接后形成完整的逻辑地址</p><p>装入：将装入模块装入内存，装入后形成物理地址</p><p><strong>三种链接方式</strong></p><p>静态链接：装入前连接成一个完整装入模块</p><p>装入时动态链接：运行前边链接边装入</p><p>运行时动态链接：运行时需要目标模块才装入并链接</p><p><strong>三种装入方式</strong></p><p>绝对装入：编译时产生绝对地址</p><p>可重定位装入：装入时将编辑地址转换为物理地址</p><p>动态运行时装入：运行时将逻辑地址转换成物理地址，需重新设置重定位寄存器。。</p><h4 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h4><p><strong>内存空间的分配与回收</strong></p><p><strong>内存空间的扩充（实现虚拟性）</strong></p><p><strong>地址转换</strong></p><p>操作系统负责实现逻辑地址到物理地址的转换</p><p>三种方式：</p><p>绝对装入：编译器负责地址转换（单道程序阶段，无操作系统）</p><p>可重定位装入：装入程序负责地址转换（早期多道批处理阶段）</p><p>动态运行时装入：运行时才进行地址转换（现代操作系统)</p><p><strong>存储保护</strong></p><p>保证各进程在自己的内存空间的运行，不会越界访问</p><p>两种方式：设置上下限寄存器</p><p>利用重定位寄存器（基址寄存器），界地址寄存器（限长寄存器）进行判断</p><h4 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a><strong>进程的内存映像</strong></h4><img src="/2024/10/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/微信图片_20240928173202.jpg" alt="微信图片_20240928173202" style="zoom: 33%;"><h4 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h4><p><strong>一个固定区：</strong>存放最活跃的程序段，<strong>固定区中的程序段在运行过程中不会调入调出</strong></p><p><strong>若干覆盖区：</strong>不可能同时被访问程序段可共享一个覆盖区，<strong>覆盖区中的程序段在运行过程中会根据需要调入调出</strong></p><p>必须由<strong>程序员声明</strong>覆盖结构，操作系统完成自动覆盖</p><p><strong>缺点：</strong>对用户不透明，增加了用户编程负担</p><p><strong>交换技术</strong></p><p>内存紧张时，换出某些进程以腾出内存空间，再换入某些进程</p><p>磁盘分为文件区和对换区换出的进程放在对换区</p><p><strong>覆盖与交换的区别</strong></p><p>覆盖是在同一个程序或进程中的</p><p>交换是在不同进程或作业之间的。</p><h3 id="3-1-2连续分配管理方式"><a href="#3-1-2连续分配管理方式" class="headerlink" title="3.1.2连续分配管理方式"></a>3.1.2连续分配管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>只支持单道程序，内存分为系统区和用户区，用户程序放在用户区，（无外部碎片，有内部碎片）</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业（无外部碎片，有内部碎片）</p><p>两种分区方式分区大小相等，分区大小不等。</p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>支持多道程序，在进程装入内存时，根据进程大小动态地建立分区</p><p>（无内部碎片，有外部碎片）</p><p>外部碎片可用“紧凑”技术来解决</p><p>回收内存分区时，可能遇到四种情况（总之相邻的空闲分区要合并）</p><ol><li>回收区之后有相邻的空闲分区</li><li>回收区前、后都有相邻的空闲分区</li><li>回收区之前有相邻的空闲分区</li><li>回收区前后没有相邻的空闲分区</li></ol><p><strong>动态适应算法</strong></p><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应算法</td><td>从头到尾找合适的分区</td><td>空闲分区以地址递增的次序排列</td><td>综合看性能最好，算法开销小，回收分区一般不需要对空闲分区队列进行重新排序</td><td>无明显缺点</td></tr><tr><td>最佳适应算法</td><td>优先使用更小的分区，以保留更多的大分区</td><td>空闲分区按容量递增的次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区对队列进行重新排序</td></tr><tr><td>最坏适应算法</td><td>优先使用更大的分区，以防止太小的不可用的碎片</td><td>空闲分区按容量递减的次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区进程容易被用完，不利于大进程；算法开销大（原因同上）</td></tr><tr><td>邻近适应算法</td><td>由首次适应算法演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增的次序排列</td><td>不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应算法）</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h3 id="3-1-3基本分页存储管理"><a href="#3-1-3基本分页存储管理" class="headerlink" title="3.1.3基本分页存储管理"></a>3.1.3基本分页存储管理</h3><h4 id="基本分页存储管理的基本概念"><a href="#基本分页存储管理的基本概念" class="headerlink" title="基本分页存储管理的基本概念"></a>基本分页存储管理的基本概念</h4><p><strong>基本分页存储管理的思想：</strong>把进程分页，各个页面可离散地放到各个内存块中。</p><p><strong>易混概念</strong>：“页框，页帧，内存块，物理块，物理页”VS“页，页面”</p><p>​                    “页框号，页帧号，内存块号，物理块号，物理页号”vs“页号，页面号”</p><p><strong>页表：</strong>页表记录了页面和实际存放的内存块之间的映射关系</p><p>一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成</p><p>每个页表项的大小是相同的，页号是“隐含的”<br>$$<br>i号页表项存放地址&#x3D;页表始址+i*页表项大小<br>$$<br><strong>逻辑地址结构</strong>（可拆分为页号P页内偏移量w）<br>$$<br>页号&#x3D;逻辑地址&#x2F;页面大小<br>$$</p><p>$$<br>页内偏移量&#x3D;逻辑地址mod页面大小<br>$$<br>如果页面大小刚好是2的整数次幂呢！</p><p>这样就可以根据二进制原理对应前多少位为页号，后多少位为页内偏移量。</p><p><strong>如何实现地址转换</strong></p><ol><li>计算出逻辑地址对应的【页号，页内偏移量】</li><li>找到对应页面在内存中的存放位置（查页表）</li><li>找到物理地址&#x3D;页面始址+页内偏移量</li></ol><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><h5 id="页面寄存器的作用："><a href="#页面寄存器的作用：" class="headerlink" title="页面寄存器的作用："></a><strong>页面寄存器的作用：</strong></h5><h5 id="存放页表起始地址，存放页表长度"><a href="#存放页表起始地址，存放页表长度" class="headerlink" title="存放页表起始地址，存放页表长度"></a><strong>存放页表起始地址，存放页表长度</strong></h5><h5 id="地址变换过程："><a href="#地址变换过程：" class="headerlink" title="地址变换过程："></a><strong>地址变换过程：</strong></h5><ol><li>根据逻辑地址算出页号、页内偏移量</li><li>页号的合法性检查（与页表长度对比）</li><li>若页号合法，再根据页表起始地址、页号找到对应页表项。</li><li>根据页表项中记录的内存块号，页内偏移量得到最终的物理地址</li><li>访问物理内存对应的内存单元</li></ol><h5 id="其他小细节"><a href="#其他小细节" class="headerlink" title="其他小细节"></a><strong>其他小细节</strong></h5><p>页内偏移量位数与页面大小之间的关系（要能用其中一个条件推出另一个条件）</p><p>页式管理地址是一维的</p><p>实际应用中，通常使一个页框恰好能放入整个页表项</p><p>为了方便找到页表项，页表一般是放在连续的内存块中</p><h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a><strong>具有快表的地址变换机构</strong></h4><ol><li>算页号，页内偏移量</li><li>检查页号合法性</li><li>查快表。若命中，即可知道页面存放的内存块号，可直接进行5操作；若未命中则进行4</li><li>查页表，找到页面存放的内存块号并且将页表项复制到快表中</li><li>根据内存块号与页面的偏移量得到物理地址</li><li>访问目标内存单元</li></ol><p>TLB与普通Cache的区别：</p><p>TLB只有页表项的副本，而普通Cache可能有各种数据副本。</p><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><p><strong>单级页表存在的问题：</strong></p><p>所有页表项必须连续存放，页表过大时需要很大的连续空间</p><p>在一段时间内并非连续的所有页面都用得到，因此没有必要让整个页表常驻内存</p><p><strong>两级页表</strong></p><p>将长长的页表再分页。<br>$$<br>逻辑地址结构：（一级页号、二级页号、页内偏移量）<br>$$<br>注意几个术语:页目录表&#x2F;外层页表&#x2F;顶级页表</p><p>要能根据逻辑地址位数，页面大小，页表项大小，可以通过一个页表能容纳多少个页表项确定一级页表的位数。确定多级页表的逻辑地址结构。</p><p><strong>如何实现地址变换</strong></p><ol><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB中读出页目录表始址，根据一级页表查页目录表，找到下一级页表在内存中存放的位置</li><li>根据二级页号查表，找到最终想要访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ol><p><strong>几个细节</strong></p><p>多级页表中各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级</p><p>多级页表的访存次数（假设没有快表机构）–N级页表访问一个逻辑地址需要N+1次访存。</p><h3 id="3-1-4基本分段存储管理"><a href="#3-1-4基本分段存储管理" class="headerlink" title="3.1.4基本分段存储管理"></a>3.1.4基本分段存储管理</h3><p><strong>分段：</strong></p><p>将地址空间按照程序自身的逻辑关系划分为若干个段，每段从0开始编址</p><p>每个段在内存中占据连续空间，但各段之间可以不相邻</p><p>逻辑地址结构：（段号，段内地址）</p><p><strong>段表：</strong></p><p>记录逻辑段到实际存储地址的映射关系</p><p>每个段对应一个段表项各段表项长度相同，由段号（隐含），段长，基址组成</p><p><strong>地址变换：</strong></p><ol><li>由逻辑地址得到段号，段内地址</li><li>段号与段表寄存器中的段长度比较，检查是否越界</li><li>由段表始址，段号找到对应段表项</li><li>根据段表中记录的段长，检查段内地址是否越界</li><li>由段表中的“基址+段内地址”得到最终的物理地址</li><li>访问目标单元</li></ol><p><strong>分段vs分页</strong></p><ol><li>分页的页面长度相同，分段的页面长度不同</li><li>分页对于用户不可见，分段对于用户可见</li><li>分页的地址是一维的，分段的地址是二维的</li><li>分段更容易实现信息的共享和保护（纯代码，可重入代码，可共享）</li><li>分页（单级页表），分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构</li></ol><h3 id="3-1-5段页式管理"><a href="#3-1-5段页式管理" class="headerlink" title="3.1.5段页式管理"></a>3.1.5段页式管理</h3><p><strong>分段+分页</strong></p><p>将地址空间按照程序的自身逻辑关系划分为若干段，再将各段分为大小相等的页面</p><p>将内存空间分为与页面相等的一个个内存块，系统以块为单位为进程分配内存<br>$$<br>逻辑地址&#x3D;（段号，页号，页内偏移量）<br>$$<br><strong>段表，页表</strong></p><p>每个段对应一个段表项，各段表项长度相同，由段号（隐含）页表长度，页表存放地址组成</p><p>各个页对应一个页表项，各页表项长度相同，由页号（隐含）页面存放那个的内存块号组成</p><p><strong>地址变换</strong></p><ol><li>由逻辑地址得到段号、页号、页内偏移量</li><li>段号与段表寄存器中的段长度比较，检查是否越界</li><li>由段表始址、段号找到对应段表项</li><li>根据段表中记录的页面长度，检查页号是否越界</li><li>由段表中的页表地址、页号得到查询页表，找到对应页表项</li><li>由页面存放的内存块号、页内偏移量得到最终的物理地址</li><li>访问目标单元</li></ol><p><strong>访问一个逻辑地址所需的访存次数</strong></p><p>第一次：查段表，第二次：查页表，第三次：访问目标单元</p><p>可引入快表机构，以段号和页号为关键字查询快表，即可找到最终的目标页面，存放位置、引入快表后仅需要一次访存。</p><h2 id="3-2虚拟内存"><a href="#3-2虚拟内存" class="headerlink" title="3.2虚拟内存"></a>3.2虚拟内存</h2><h3 id="3-2-1虚拟内存的基本概念"><a href="#3-2-1虚拟内存的基本概念" class="headerlink" title="3.2.1虚拟内存的基本概念"></a>3.2.1虚拟内存的基本概念</h3><h4 id="3-2-1-1传统存储管理方式的特征（缺点）"><a href="#3-2-1-1传统存储管理方式的特征（缺点）" class="headerlink" title="3.2.1.1传统存储管理方式的特征（缺点）"></a><strong>3.2.1.1传统存储管理方式的特征（缺点）</strong></h4><p>一次性：作业数据必须一次全部调入内存</p><p>驻留性：作业数据在整个运行期间都会常驻内存</p><h4 id="3-2-1-2局部性原理"><a href="#3-2-1-2局部性原理" class="headerlink" title="3.2.1.2局部性原理"></a><strong>3.2.1.2局部性原理</strong></h4><p><strong>时间局部性：</strong>现在访问的指令，数据在不久之后很可能会被再次访问。</p><p><strong>空间局部性：</strong>现在访问的内存单元周围的内存单元，很可能在不久后会被访问。</p><p><strong>高速缓存技术：</strong>使用频繁的数据放到更高速的存储器中。</p><h4 id="3-2-1-3虚拟内存的定义和特征"><a href="#3-2-1-3虚拟内存的定义和特征" class="headerlink" title="3.2.1.3虚拟内存的定义和特征"></a><strong>3.2.1.3虚拟内存的定义和特征</strong></h4><p><strong>定义：</strong>程序不需要全部装入即可运行，运行时根据需要动态调入数据。若内存不够，还需换出一些数据。</p><p><strong>特征：</strong></p><p><strong>多次性：</strong>无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</p><p><strong>对换性：</strong>无需在作业运行时一直常驻内存，而是允许在作业运行过程中，讲作业换入换出。</p><p><strong>虚拟性：</strong>从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量</p><h4 id="3-2-1-4如何实现虚拟内存技术"><a href="#3-2-1-4如何实现虚拟内存技术" class="headerlink" title="3.2.1.4如何实现虚拟内存技术"></a>3.2.1.4如何实现虚拟内存技术</h4><p>访问的信息不在内存中，由操作系统负责将所需信息，从外存调入内存（请求调页功能）。</p><p>内存空间不够，将内存中暂时用不到的信息换出内存（页面置换功能）</p><p><strong>虚拟内存的实现：</strong></p><p>请求分页存储管理、请求分段存储管理、请求段页式存储管理。</p><h3 id="3-2-2请求分页管理方式"><a href="#3-2-2请求分页管理方式" class="headerlink" title="3.2.2请求分页管理方式"></a>3.2.2请求分页管理方式</h3><p><strong>页表机制：</strong>在基本分页的基础上增加了几个表项</p><p><strong>状态位：</strong>标识页面是否已在内存中</p><p><strong>访问字段：</strong>记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考。</p><p><strong>修改位：</strong>表示页面调入内存后是否被修改过，只有修改过的页面才在需要置换时写入外存。</p><p><strong>外存地址：</strong>页面在外存中存放的位置</p><p><strong>缺页中断机构</strong></p><p>找到页表项后检查页面是否已在内存，若没有在内存中，则产生缺页中断</p><p>缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面，缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常，一条指令在执行过程中可能产生多次缺页中断</p><p><strong>地址变换机构（重点关注与基本分页不同的地方）</strong></p><p>找到页表项是需要检查页面是否在内存中。</p><p>若页面不在内存中，需要请求调页。</p><p>若内存空间不够，还需换出页面</p><p>页面调入内存中后，需要修改相应页表项</p><p><img src="/2024/10/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20241005105926343.png" alt="image-20241005105926343"></p><h3 id="3-2-3页框分配"><a href="#3-2-3页框分配" class="headerlink" title="3.2.3页框分配"></a>3.2.3页框分配</h3><p>**驻留集:**指的是请求分页存储管理中给进程分配的内存块的集合</p><p><strong>页面分配置换策略：</strong></p><p><strong>固定分配VS可变分配</strong>：区别在于进程运行期间驻留集大小是否可变</p><p><strong>局部置换VS全局置换：</strong>区别在于发生缺页时是否只能从进程自己的页面中选择一个换出</p><p><strong>固定分配局部置换：</strong>进程运行前就分配一定数量物理块，缺页时只能换出进程自己的某一页</p><p><strong>可变分配全局置换：</strong>只要缺页就分配新物理块，可能来自空闲物理块，也可能需换出别的进程页面</p><p>**可变分配局部置换:**频繁缺页的进程，多分配一些物理块；缺页率很低的进程，回收一些物理块，直到缺页率合适</p><p><strong>何时调入页面：</strong></p><p><strong>预调页策略：</strong>一般用于进程运行前</p><p><strong>请求调页策略：</strong>进程运行时，发现缺页再调页</p><p><strong>从何处调页：</strong></p><p><strong>对换区：</strong>采用连续存储方式，速度更快；文件区—采用离散存储方式，速度更慢</p><p><strong>对换区足够大：</strong>运行将数据从文件区复制到对换区，之后所有的页面调入调出，都是在内存与对换区之前进行。</p><p><strong>对换区不够大：</strong>不会修改的数据每次都从文件区调入；会修改的数据调出到对换区，需要时再从对换区调入。</p><p><strong>Unix方式：</strong>第一次使用的页面都从文件区调入调出的页面都写会对换区，再次使用时从对换区调入。</p><p><strong>抖动颠簸现象：</strong>页面频繁换入换出的现象。主要原因是分配给进程的物理块不够</p><p><strong>工作集：</strong>在某段时间间隔里；进程实际访问页面的集合。驻留集大小一般不能小于工作集大小</p><h3 id="3-2-4页面置换算法"><a href="#3-2-4页面置换算法" class="headerlink" title="3.2.4页面置换算法"></a>3.2.4页面置换算法</h3><table><thead><tr><th>算法</th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单，但性能很差，可能出现贝拉迪异常</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问的的页面</td><td>性能很好，但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK(NRU)</td><td>循环扫描各页面，第一轮访问淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1，若第一轮未选中，则进行第二轮扫描</td><td>实现简单，算法开销小。但未考虑页面是否被修改</td></tr><tr><td>改进型CLOCK(改进型NRU)</td><td>若用（访问位，修改位）的形式表述，第一轮淘汰（0,0），第二轮淘汰（0,1），并将扫描过的页面访问位都置为0，第三轮淘汰（1,0），第四轮淘汰（1,1）（优先级）</td><td>算法开销小，性能也不错</td></tr></tbody></table><h3 id="3-2-5内存映射文件"><a href="#3-2-5内存映射文件" class="headerlink" title="3.2.5内存映射文件"></a>3.2.5内存映射文件</h3><p><strong>特性：</strong>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间，以访问内存的方式读写文件。进程关闭文件时，操作系统负责将文件数据写回磁盘，以解除内存映射，多个进程可以映射同一个文件，方便共享。</p><p><strong>优点：</strong>程序员编程更简单，已建立映射的文件，只需访问内存的方式读写即可。文件数据的读入写出完全由操作系统负责优化。</p><h1 id="第四章-文件"><a href="#第四章-文件" class="headerlink" title="第四章 文件"></a>第四章 文件</h1><h2 id="4-1文件系统基础"><a href="#4-1文件系统基础" class="headerlink" title="4.1文件系统基础"></a>4.1文件系统基础</h2><h3 id="①文件管理"><a href="#①文件管理" class="headerlink" title="①文件管理"></a>①文件管理</h3><p><strong>文件的定义：</strong>一组有意义的信息的集合。</p><p><strong>文件的属性：</strong>文件名，标识符，类型，位置，大小，保护信息</p><p>文件内部应该如何被组织起来（文件的逻辑结构）</p><p>文件之间该如何被组织起来（目录结构）</p><p>操作系统应向上提供哪些功能（create,delete,open,close,read,write系统调用）</p><p>文件应如何存放在外存中（文件的物理结构）</p><p>操作系统如何管理外存中的空闲块（存储空间的管理）</p><p>操作系统需要提供的其他文件管理功能（文件共享，文件保护）</p><h3 id="②有结构文件"><a href="#②有结构文件" class="headerlink" title="②有结构文件"></a>②有结构文件</h3><p><strong>顺序文件</strong></p><p>串结构：记录顺序与关键字无关。</p><p>顺序结构：记录按关键字顺序排列</p><p>可变长记录的顺序文件无法实现随机存取，定长记录可以。（可变长记录的顺序文件在每次查询时只能从头一次查找）</p><p>定长记录、顺序结构的顺序文件可以快速检索（根据关键字可快速找到记录）</p><p>最大缺点：不方便增加&#x2F;删除记录。</p><p><strong>索引文件</strong></p><p>建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加&#x2F;删除记录。</p><p>索引表本身就是定长记录的顺序文件，一个索引表项就是一条定长记录，因此索引文件可支持随机存取。</p><p>若索引表按关键字顺序排列，则可支持快速检索</p><p>解决了顺序文件不方便增删记录的问题，同时让不定长记录的文件实现了随机存取，但索引表可能占用很多空间。</p><p><strong>索引顺序文件</strong></p><p>将记录分组，每组对应一个索引表项</p><p>检索记录时先顺序查索引表，找到分组，再顺序查找分组（会 查 ，计算平均查找次数）</p><p>当记录过多时，可建立多级索引表。</p><h3 id="③文件的基本操作"><a href="#③文件的基本操作" class="headerlink" title="③文件的基本操作"></a>③文件的基本操作</h3><p><strong>创建文件：</strong>分配外存空间，创建目录项</p><p><strong>删除文件：</strong>回收外存空间，删除目录项</p><p><strong>打开文件：</strong></p><p>将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户，打开文件后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作。</p><p>每个进程有自己的打开文件表，系统中也有一张总的打开文件表，进程打开文件表中特有的属性，读写指针，访问权限（只读？读写?)</p><p>系统打开文件表中特有的属性：打开计数器（有多少个进程打开了该文件）</p><p>**关闭文件:**将进程打开文件表中的相应表项删除，系统打开文件表的打开计数器减，若打开计数器为，则删除系统表的表项</p><p><strong>读文件：</strong>根据读指针、读入数据量，内存位置将文件数据从外存读入内存</p><p><strong>写文件：</strong>根据写指针，写出数据量，内存位置将文件数据从内存写出外存</p><p><em><strong>“读写文件”用“文件描述符”即可，指明文件，不再需要用到“文件名”</strong></em></p><p><em><strong>打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”</strong></em></p><h3 id="④文件的物理结构"><a href="#④文件的物理结构" class="headerlink" title="④文件的物理结构"></a>④文件的物理结构</h3><p><strong>连续分配（总结）</strong></p><p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong></p><p><strong>优点：</strong>支持顺序访问和直接访问（即随机访问），连续分配的文件在顺序访问时速度最快</p><p><strong>缺点：</strong>不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p><p><strong>链接分配（总结）</strong></p><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显示连接两种。</p><p><strong>隐式链接</strong>—除文件的最后一个盘块之外，每个盘块中都存在指向下一个盘块的指针。文件目录包含文件第一块的指针和最后一块的指针</p><p><strong>优点：</strong>很方便文件拓展，不会有碎片问题，外存利用率高</p><p><strong>缺点：</strong>只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针，也需要耗费少量的存储空间</p><p><em><strong>（考试题目中遇到未指明隐式&#x2F;显式的“链接分配，默认指的是隐式链接的链接分配）</strong></em></p><p><strong>显式链接：</strong>把用于链接文件各物理块的指针显式的存放在一张表中，即文件分配表（FAT，File Allocation Table)一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><p><strong>优点：</strong>很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</p><p><strong>缺点：</strong>文件分配表的需要占有一定的存储空间</p><p>​</p><p><strong>索引分配（总结）</strong></p><p><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块所对应的物理块</strong>（索引表的功能类似与内存管理中的页表–建立逻辑页面到物理页面的映射关系），索引表的存放的磁盘块称为索引块，文件数据存放的磁盘块称为<strong>数据块。</strong></p><p>若文件太大、索引表项太多，可以采取以下三种方法解决：</p><p>①</p><p><strong>链接方案：</strong>如果索引表太大，一个索引块装不下，那么可以将多个索引块连接起来存放。</p><p><strong>缺点：</strong>若文件很大，索引表很长，就需要将很多个索引块连接起来，想要找到i号索引块，必须献一次读入0-i-1号索引块，这就导致磁盘I&#x2F;O次数过多，查找效率低下</p><p>②</p><p><strong>多层索引：</strong>建立多层索引（<strong>原理类似于多级页表</strong>）是第一层索引块指向第二层的索引块。还可以根据文件大小的的要求在建立第三层，第四层索引块。采用K层索引结构，且<strong>顶级索引表未调入内存</strong>，则访问一个数据块只需要K+1次读磁盘操作。<strong>缺点：</strong>即便是小文件，访问一个数据块依然需要K+1次读磁盘</p><p>③</p><p><strong>混合索引：</strong>多次索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），有包含<strong>一级间接索引</strong>（指向单层索引表），还包含<strong>两级间接索引</strong>（指向两层索引表）</p><p><strong>优点：</strong>对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><p><strong>超级超级超级重要考点：</strong>①要会根据多层索引，混合索引的结构计算出文件的最大长度（<strong>KEY：</strong>各级索引表最大不能超过一个块）②要能分析访问某个数据块所需要的读磁盘次数（<strong>KEY：</strong>FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块，每次读入下一级的索引块都需要一次读磁盘操作，另外，要注意题目条件–<strong>顶级索引块是否已经调入内存</strong>）</p><h4 id="顺序分配，链接分配与索引分配"><a href="#顺序分配，链接分配与索引分配" class="headerlink" title="顺序分配，链接分配与索引分配"></a>顺序分配，链接分配与索引分配</h4><table><thead><tr><th>分配方式</th><th>how?</th><th>目录项内容</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>顺序分配</td><td>为文件分配的必须是连续的磁盘块</td><td>起始块号，文件长度</td><td>顺序存取速度快，支持随机访问</td><td>会产生碎片，不利于文件拓展</td></tr><tr><td>隐式链接</td><td>读文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针</td><td>起始块号，结束块号</td><td>可解决碎片问题，外存利用率高，文件拓展实现方便</td><td>只能顺序访问，不能随机访问</td></tr><tr><td>显式链接</td><td>建立一张文件分配表（FAT），显式记录盘块的先后关系（开机后FAT常驻内存）</td><td>起始块号</td><td>除了拥有隐式链接的优点之外，还可以通过查询内存中的FAT实现随机访问</td><td>FAT需要占用一定的存储空间</td></tr><tr><td>索引分配</td><td>为文件数据块建立索引表，若文件太大，可采用连接方案，多层索引，混合索引</td><td>连接方案记录的是第一个索引块的块号，多层混合索引记录的是顶级索引号的块号</td><td>支持随机访问，易于实现文件的拓展</td><td>索引表需要占用一定的存储空间访问数据块前需要读入索引块。若采用链接方案，查找索引块时需要很多次读磁盘操作</td></tr></tbody></table><h3 id="逻辑结构VS物理结构"><a href="#逻辑结构VS物理结构" class="headerlink" title="逻辑结构VS物理结构"></a>逻辑结构VS物理结构</h3><p><strong>逻辑结构：</strong>用户（文件创建者）的视角看到的样子，在用户看来，整个文件占有连续的逻辑地址空间文件内部的信息组织完全由用户自己决定，操作系统并不关心。</p><p><strong>物理结构：</strong>由操作系统决定文件采用什么物理结构存储，操作系统负责将逻辑地址转变为（逻辑块号，块内偏移量）的形式，并负责实现逻辑块号到物理块号的映射。</p><h2 id="4-2目录"><a href="#4-2目录" class="headerlink" title="4.2目录"></a>4.2目录</h2><h3 id="4-2-1文件目录"><a href="#4-2-1文件目录" class="headerlink" title="4.2.1文件目录"></a>4.2.1文件目录</h3><p><strong>文件目录的实现：</strong></p><p>一个文件对应一个FCB，1个FCB就是一个目录项，多个FCB组成文件目录</p><p>对目录的操作：搜索，创建文件，删除文件，显示文件，修改文件</p><p><strong>目录结构：</strong></p><p><strong>单级目录结构：</strong>一个系统只有一张目录表，不允许文件重名。</p><p><strong>两级目录结构：</strong>不同用户的文件可以重名，但不能对文件进行分类</p><p><strong>多级目录结构（树形）：</strong></p><p>不同目录下的文件可以对文件进行分类，不方便文件共享</p><p>系统根据“文件路径”找到目标文件</p><p>从根目录出发的路径是“绝对路径”</p><p>从当前目录出发的路径是“相对路径”</p><p><strong>无环图目录结构：</strong></p><p>在树形目录结构的基础上，增加一些指向同一节点的有向性，使整个目录称为一个有向无环图</p><p>为共享节点设置一个共享计数器，计数器为0时才真正删除节点</p><p>索引节点：除了文件名之外的所有信息都放到索引节点中，每个文件对应一个索引节点，目录项中只包含文件名，索引节点指针，因此每个目录项的长度大幅减少，由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时的磁盘I&#x2F;O的次数就少了很多。</p><h3 id="4-2-2文件共享"><a href="#4-2-2文件共享" class="headerlink" title="4.2.2文件共享"></a>4.2.2文件共享</h3><p><strong>硬链接：</strong></p><p>各个用户的目录项指向同一个索引节点，索引节点中需要有链接计数count，某用户想删除文件时，只是删除该文件的目录项，且count–，只有count&#x3D;&#x3D;0时才能真正删除文件数据和索引节点，否则会导致指针悬空</p><p><strong>软链接：</strong></p><p>在一个Link型的文件中记录共享文件的存放路径（windows快捷方式）操作系统根据路径一层层查找目录，最终找到共享文件。即使软链接指向的共享文件已被删除，link型文件依然存在，只是通过Link型文件中的路径会查找共享文件会失败（找不到对应目录项），由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O.</p><h3 id="4-2-3文件保护"><a href="#4-2-3文件保护" class="headerlink" title="4.2.3文件保护"></a>4.2.3文件保护</h3><p><strong>口令保护:</strong></p><p>为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确，实现开销小，但“口令”一般存放在FCB或索引节点中（也就是存放在系统中）因此不太安全。</p><p><strong>加密保护：</strong></p><p>用一个“密码”对文件加密，用户想要访问文件时，需要提供相同的“密码”才能正确的解密。</p><p>安全性高，但加密&#x2F;解密需要耗费一定的时间。</p><p><strong>访问控制：</strong></p><p>用一个访问控制表（ACL)记录各个用户（或各组用户）时文件的访问权限，对文件的访问类型可以分为读写执行删除等。实现灵活，可以实现复杂的文件保护功能。</p><p><strong>如果对于某个记录进行了访问控制，那也要对目录下的所有文件进行相同的访问权限控制。</strong></p><h2 id="4-3文件层次结构"><a href="#4-3文件层次结构" class="headerlink" title="4.3文件层次结构"></a>4.3文件层次结构</h2><h3 id="文件层次结构"><a href="#文件层次结构" class="headerlink" title="文件层次结构"></a>文件层次结构</h3><ol><li>用户需要通过操作系统提供的借口发出上述请求——<strong>用户接口。</strong></li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——<strong>文件目录结构</strong></li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——<strong>存取控制模块（存取控制验证层）</strong></li><li>验证用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——<strong>逻辑文件系统与文件信息缓冲区</strong></li><li>知道了目标记录对应的逻辑地址后，还需要转化成实际的物理地址——<strong>物理文件系统</strong></li><li>要删除这条记录，必定要对磁盘设备发出请求——<strong>设备管理程序模块</strong></li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——<strong>辅助分配模块</strong></li></ol><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p><strong>存储空间的划分与初始化</strong></p><p>文件卷（逻辑卷），目录区，文件区的概念</p><p>目录区包含文件目录，空闲区，位示图，超级块等用于文件管理的数据</p><p><strong>空闲表法</strong></p><p>空闲表中记录每个连续空闲区的起始盘块号，盘块数。</p><p>分配时可采用<strong>首次适用，最佳适应</strong>等策略；回收时注意表项的合并问题</p><p><strong>空闲链表法</strong></p><p><strong>空闲盘块链：</strong>以盘块为单位组成一条空闲链。分配时从链头依次取出空闲块，回收时将空闲块查到链尾，以盘区为单位组成一条空闲链。</p><p>**空闲盘区链:**分配可采用首次适应，最佳适应等策略；回收时注意相邻空闲盘区合并的问题。</p><p><strong>位示图法：</strong></p><p>一个二进制位对应一个盘块（字号，位号）或（行号，列号）与盘块号一一对应，</p><p><strong>重要考点：</strong>要能够自己推出盘块号——&gt;（字号，位号）之间的相互转换公式。</p><p>需要注意的题目条件：二进制011到底哪个代表空闲，哪个代表不空闲，字号、位号、盘块号到底是从0开始，还是从1开始</p><p>成组链接法：UNIX采用的策略，适合大型文件系统，理解即可，不方便用文字描述的知识点也很难作为考题。</p><h1 id="第五章-输入输出I-x2F-O管理"><a href="#第五章-输入输出I-x2F-O管理" class="headerlink" title="第五章 输入输出I&#x2F;O管理"></a>第五章 输入输出I&#x2F;O管理</h1><h2 id="5-1-I-x2F-O管理概述"><a href="#5-1-I-x2F-O管理概述" class="headerlink" title="5.1 I&#x2F;O管理概述"></a>5.1 I&#x2F;O管理概述</h2><h3 id="5-1-1I-x2F-O设备"><a href="#5-1-1I-x2F-O设备" class="headerlink" title="5.1.1I&#x2F;O设备"></a>5.1.1I&#x2F;O设备</h3><p><strong>什么是I&#x2F;O设备？</strong></p><p>将数据Input&#x2F;Output(输入&#x2F;输出)计算机的外部设备</p><p><strong>按使用特性分类：</strong></p><p>人机交互类外部设备，存储设备，网络通信设备</p><p><strong>按传输速率分类：</strong></p><p>低速设备，中速设备，高速设备</p><p><strong>按信息交换的单位分类：</strong></p><p>块设备（传输快，可寻址）</p><p>字符设备（传输慢，不可寻址）</p><p><strong>I&#x2F;O控制器</strong></p><p>用于实现对I&#x2F;O设备的控制，I&#x2F;O设备由机械部件和电子部件组成。、</p><p><strong>主要功能：</strong></p><p>接受和识别CPU发出的命令（要有控制寄存器）</p><p>向CPU报告设备的状态（要有状态寄存器）</p><p>数据交换：要有数据寄存器，暂存输入和输出的数据</p><p>地址识别：（由I&#x2F;O逻辑实现）</p><p><strong>组成：</strong></p><p>CPU与控制器之间的接口（实现控制器与CPU之间的通信）</p><p>I&#x2F;O逻辑（负责识别CPU发出的命令，并向设备发出命令）</p><p>控制器与设备之间的接口（实现控制器与设备之间的通信）</p><p><strong>两种寄存器编址方式：</strong></p><p><strong>内存映射I&#x2F;O</strong></p><p>控制器中的寄存器与内存统一编址，可以采用对内存进行操作的指令来对控制器进行操作</p><p><strong>优点：</strong></p><p>不需要专门的I&#x2F;O指令，使得CPU访问I&#x2F;O的操作更加灵活和方便，还使用端口具有较大的编址空间。I&#x2F;O访问的保护机制可有虚拟存储管理系统来实现，无需专门设置。</p><p><strong>缺点：</strong></p><p>端口地址占用了部分主存地址空间，使主存的可用容量变小，此外，由于在识别I&#x2F;O端口是全部地址线都要参加译码，使得译码电路更加复杂，降低了寻址速度。</p><p><strong>寄存器独立编制：</strong></p><p>控制器中的寄存器独立编制</p><p>需要设置专门的指令来操作控制器。</p><p><strong>优点：</strong></p><p>I&#x2F;O端口数比主存单元少得多，只需要少量的地址线，使得I&#x2F;O端口译码简单，寻址速度更快，使用专用的I&#x2F;O指令，可使程序更加清晰，便于理解和检查。</p><p><strong>缺点：</strong></p><p>I&#x2F;O指令少，只提供简单的传输操作，所以程序设计的灵活性较差，此外，CPU需要提供两组独立的存储器和设备的读写控制信号，增加了控制的复杂性。</p><h3 id="5-1-2I-x2F-O控制方式"><a href="#5-1-2I-x2F-O控制方式" class="headerlink" title="5.1.2I&#x2F;O控制方式"></a>5.1.2I&#x2F;O控制方式</h3><table><thead><tr><th>方式</th><th>完成读写的过程</th><th>CPU干预频率</th><th>每次I&#x2F;O数据传输单位</th><th>数据流向</th></tr></thead><tbody><tr><td>程序直接控制方式</td><td>CPU发出I&#x2F;O命令后需要不断轮询</td><td>极高</td><td>字</td><td>设备–》CPU–》内存，内存–》CPU–》设备</td></tr><tr><td>中断驱动方式</td><td>CPU发出I&#x2F;O命令后可以做其他事，本次I&#x2F;O完成后设备控制器发出中断信号</td><td>高</td><td>字</td><td>设备–》CPU–》内存，内存–》CPU–》设备</td></tr><tr><td>DMA方式</td><td>CPU发出I&#x2F;O命令后可以做其他事，本次I&#x2F;O完成后DMA控制器发出中断信号</td><td>中</td><td>块</td><td>设备–》内存，内存–》设备</td></tr><tr><td>通道控制方式</td><td>CPU发出I&#x2F;O命令后可以做其他事，通道会执行通道程序以完成I&#x2F;O，完成后通道向CPU发出中断信号</td><td>低</td><td>一组块</td><td>设备–》内存，内存–》设备</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优缺点：</span><br><span class="line">每个阶段的优点都是解决了上一阶段的最大缺点；总体来说：整个发展过程就是要减少CPU对I/O过程的干预，把CPU从繁杂的I/O控制事务中解脱出来，以便更多的去完成数据处理任务。</span><br></pre></td></tr></table></figure><h3 id="5-1-3I-x2F-O软件层次结构"><a href="#5-1-3I-x2F-O软件层次结构" class="headerlink" title="5.1.3I&#x2F;O软件层次结构"></a>5.1.3I&#x2F;O软件层次结构</h3><p><strong>I&#x2F;O软件层次</strong></p><p><strong>用户层软件</strong></p><p>实现与用户交互的接口，向上提供方便易用的库函数</p><p><strong>设备独立性软件</strong></p><p>①向上层提供统一的调用接口（如read&#x2F;write系统调用）</p><p>②设备的保护</p><p>③差错处理</p><p>④设备的分配与回收</p><p>⑤数据存储区管理</p><p>⑥建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</p><p><strong>设备驱动程序</strong></p><p>设置设备寄存器，检查设备状态</p><p><strong>中断处理程序</strong></p><p>进行中断处理</p><p><strong>硬件</strong></p><p>执行I&#x2F;O操作，有机械部件，电子部件组成（参考I&#x2F;O控制器）</p><p>理解并记住I&#x2F;O软件各个层次之间的次序，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立型软件，设备驱动程序这两层。只需理解一个特点即可。直接涉及到硬件具体细节，且与中断无关的操作肯定是在设备驱动程序层完成的，没有涉及硬件的，对各种设备都需要进行的管理工作都是在设备独立性软件层完成的）</p><h3 id="5-1-4应用程序I-x2F-O接口"><a href="#5-1-4应用程序I-x2F-O接口" class="headerlink" title="5.1.4应用程序I&#x2F;O接口"></a>5.1.4应用程序I&#x2F;O接口</h3><p><strong>I&#x2F;O接口的分类</strong></p><p>字符设备接口，快设备接口，网络设备接口。</p><p><strong>阻塞I&#x2F;O</strong></p><p>阻塞I&#x2F;O是指当用户进程调用I&#x2F;O操作时，进程就被阻塞，并移到阻塞队列，I&#x2F;O操作完成后进程才被唤醒，移到就绪队列</p><p><strong>例如：****你和女友去奶茶店买奶茶，点完单之后，因为不知道奶茶什么时候做好，所以只能一直等待，其他什么事也不能干。</strong></p><p><strong>优点：</strong>操作简单，实现难度低，适合并发量小的应用开发</p><p><strong>缺点：</strong>I&#x2F;O执行阶段进程会一直阻塞下去。</p><p><strong>非阻塞I&#x2F;O：</strong></p><p>非阻塞I&#x2F;O是指当前用户进程调用I&#x2F;O操作时，不阻塞该进程但进程需要不断询问I&#x2F;O操作是否完成，在I&#x2F;O执行阶段，进程还可以做其他事情。</p><p><strong>例如：</strong>你和女友去奶茶店买奶茶，汲取了上次的教训，点完单口顺便去逛逛商场，由于担心错过取餐，所以每隔一段时间就过来询问服务员</p><p><strong>优点；</strong>进程在等待I&#x2F;O期间不会阻塞，可以做其他事情，适合并发量大的应用开发</p><p><strong>缺点：</strong>轮询方式询问I&#x2F;O结果，会占用CPU的时间</p><h2 id="5-2设备独立性软件"><a href="#5-2设备独立性软件" class="headerlink" title="5.2设备独立性软件"></a>5.2设备独立性软件</h2><h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p><strong>SPOOLING</strong></p><p><strong>脱机技术：</strong>外围控制机+更高速的涉笔——磁带</p><p><strong>作用：</strong>缓解设备与CPU的速度矛盾实现预输入，缓输出</p><p><strong>假脱机技术：</strong></p><p>又叫SPooling技术，用软件的方式模拟脱机技术</p><p><strong>输入井和输出井：</strong>模拟脱机输入输出时的磁带</p><p><strong>输入进程和输出进程：</strong>模拟脱机输入输出的外围控制机</p><p><strong>输入缓冲区和输出缓冲区：</strong>内存中的缓冲区，输入输出时的“中转站”</p><p><strong>共享打印机：</strong></p><p>用假脱机技术将独占式的打印机“虚拟”成共享打印。</p><h3 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h3><p><strong>应考虑的因素</strong></p><p><strong>固有属性：</strong>独占设备，共享设备，虚拟设备</p><p><strong>分配算法：</strong>先来先服务，优先级高者优先，短任务优先</p><p><strong>安全性：</strong>安全分配方式、不安全分配方式（死锁避免，银行家算法）</p><p><strong>静态分配与动态分配：</strong></p><p><strong>静态分配：</strong>进程运行前为其分配全部所需资源，运行结束后归还资源</p><p><strong>动态分配：</strong>进程运行过程中动态申请设备资源（动态）</p><p><strong>设备分配管理中的数据结构</strong></p><p>**设备控制表（DCT)**每个设备对应一个DCT，关键字段：类型&#x2F;标识符&#x2F;状态&#x2F;指向COCT的指针&#x2F;等待队列指针</p><p>**控制器控制表（COCT)**每个控制器对应一个COCT，关键字段：类型&#x2F;标识符&#x2F;状态&#x2F;指向CHCT的指针&#x2F;等待队列指针</p><p>**通道控制表（CHCT)**每个控制器对应一个CHCT，关键字段：类型&#x2F;标识符&#x2F;状态&#x2F;等待队列指针</p><p><strong>系统设备表（SDT）</strong>记录整个系统中所有设备的情况，每个设备对应一个表目，关键字段：设备类型&#x2F;标识符&#x2F;DCT&#x2F;驱动程序入口</p><p><strong>设备分配的步骤：</strong></p><p>①根据进程请求的物理设备名查找SDT</p><p>②根据SDT找到DCT并分配设备</p><p>③根据DCT找到COCT并分配控制器</p><p>④根据COCT找到CHCT并分配通道</p><p><strong>注：</strong>只有设备，控制器，通道，三者都分配成功时，这次设备分配才算成功之后便可启动I&#x2F;O设备进行数据传送。</p><p><strong>缺点：</strong>用户编程时必须使用“物理设备名”若换了一个物理设备，则程序无法运行。若进程请求的物理设备正在忙碌，即使系统中还有同类型的设备，进程必须阻塞等待。</p><p><strong>设备分配步骤的改进：</strong>用户编程时使用逻辑设备名申请设备，操作系统负责实现从逻辑设备名到物理设备名的映射（通过LUT）</p><p><strong>逻辑设备表的设置问题：</strong></p><p>整个系统只有一张LUT；各个用户所用的逻辑设备名不允许重复</p><p>每个用户一张LUT，各个用户的逻辑设备名可重复</p><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p><strong>缓冲区的概念：</strong></p><p>一般利用内存作为缓冲区，缓解CPU与设备的速度矛盾，减少对CPU的中断频率，解决数据粒度不匹配的问题，提高CPU与I&#x2F;O设备之间的并行性</p><p><strong>单缓冲：</strong></p><p>设备-（T）-缓冲区-（M）工作区-(C)处理</p><p>处理一块数据平均耗时Max(C,T)+M</p><p>分析问题的初始状态：工作区满，缓冲区空</p><p><strong>双缓冲：</strong></p><p>处理一块数据平均耗时max(T,C+M)</p><p>分析问题的初始状态；工作区空，一个缓冲区满，另一个缓冲区空</p><p><strong>循环缓冲：</strong></p><p>多个缓冲区连接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区</p><p><strong>缓冲池：</strong></p><p><strong>三个队列：</strong>空缓冲队列，输入队列，输出队列</p><p><strong>四种工作缓冲区：</strong>用于收容输入数据的工作缓冲区，用于提取输入数据的工作缓冲区</p><p>用于收容输出数据的工作缓冲区，用于提取输出数据的工作缓冲区</p><h2 id="5-3磁盘和固态硬盘"><a href="#5-3磁盘和固态硬盘" class="headerlink" title="5.3磁盘和固态硬盘"></a>5.3磁盘和固态硬盘</h2><h3 id="5-3-1磁盘的结构"><a href="#5-3-1磁盘的结构" class="headerlink" title="5.3.1磁盘的结构"></a>5.3.1磁盘的结构</h3><p><strong>磁盘、磁道、扇区的概念</strong></p><p>磁盘由表面涂有磁性物质的圆形盘片组成</p><p>每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区</p><p><strong>如何在磁盘中读写数据</strong></p><p>磁头移动到目标位置，盘片旋转，对应盘区划过磁道才能完成读写</p><p><strong>盘面，柱面的概念：</strong></p><p>磁盘有多个盘片“摞起来”，每个盘片有两个盘面</p><p>所有盘面中相对位置的磁道组成柱面</p><p><strong>磁盘的物理地址：</strong></p><p>（柱面号，盘面号，扇区号）</p><h3 id="5-3-2磁盘的分类"><a href="#5-3-2磁盘的分类" class="headerlink" title="5.3.2磁盘的分类"></a>5.3.2磁盘的分类</h3><p><strong>根据磁头是否可移动</strong></p><p>固定头磁盘（每个磁道有一个磁头）</p><p>移动头磁盘（每个盘面只有一个磁头）</p><p><strong>根据盘面是否可以更换</strong></p><p>固定盘磁盘，可换盘磁盘</p><h3 id="5-3-3磁盘的调度算法"><a href="#5-3-3磁盘的调度算法" class="headerlink" title="5.3.3磁盘的调度算法"></a>5.3.3磁盘的调度算法</h3><p><strong>一次磁盘读写操作需要的时间</strong></p><p>寻道时间：移动磁臂，移动磁头所需要的的时间</p><p>延迟时间：将目标扇区转到磁头下面所花的时间</p><p>传输时间：读写数据花费的时间</p><p><strong>磁盘调度算法：</strong></p><table><thead><tr><th>先来先服务（FCFS）</th><th>①按访问请求到达的先后顺序进行处理</th></tr></thead><tbody><tr><td>最短寻找时间优先（SSTF）</td><td>每次都优先响应距离磁头最近的磁道的访问请求，贪心算法的思想，能保证眼前最优，但无法保证总的寻道时间最短，缺点，可能导致饥饿</td></tr><tr><td>扫描算法（电梯算法，SCAN）</td><td>只有磁头移动到最边缘的磁道时才可以改变磁头方向，缺点：对各个位置磁道的响应频率不平均</td></tr><tr><td>循环扫描算法（C-SCAN）</td><td>只有需磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，返回途中不响应任何请求</td></tr><tr><td>LOOK算法</td><td>SCAN算法的改进，只要在磁头移动方向上不再有请求，就立即改变磁头方向</td></tr><tr><td>C-LOOK算法</td><td>C-SCAN算法的改进 ，只要在磁头移动方向上不在有请求，就立即让磁头返回序号最小的磁头</td></tr></tbody></table><p>若题目中无特别说明，则SCAN就是Look，C-SCAN就是C-LOOK</p><h3 id="5-3-4减少延迟时间的方法"><a href="#5-3-4减少延迟时间的方法" class="headerlink" title="5.3.4减少延迟时间的方法"></a>5.3.4减少延迟时间的方法</h3><p><strong>交替编号：</strong></p><p>具体做法：让编号相邻的扇区在物理上不相邻</p><p>原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</p><p><strong>错位命名：</strong></p><p>具体做法：让相邻的盘面的扇区编号“错位”</p><p>原理：与“交替编号”的原理相同。”错位命名法“可以降低延迟时间</p><p><strong>磁盘地址结构的设计：</strong></p><p>理解为什么要用（柱面号，盘区号，扇区号）的结构</p><p>理解为什么不用（盘区号，柱面号，扇区号）的结构</p><p>原因：在读取地址连续的磁盘块时，前者更不需要移动磁头</p><h3 id="5-3-5磁盘的管理："><a href="#5-3-5磁盘的管理：" class="headerlink" title="5.3.5磁盘的管理："></a>5.3.5<strong>磁盘的管理：</strong></h3><p><strong>磁盘初始化：</strong></p><p>低级格式化&#x2F;物理格式化：划分扇区</p><p>磁盘分区（C盘，D盘，E盘）</p><p>逻辑格式化：建立文件系统（建立根目录文件，建立用于存储空间管理的数据结构）</p><p><strong>引导块：</strong></p><p>计算机启动时需要运行初始化程序（自举程序）未完成初始化</p><p>ROM存放很小的自举装入程序</p><p>完整的自举程序存放在初始化块（引导块）中</p><p><strong>坏块的管理：</strong></p><p>简单的磁盘：逻辑格式化时将坏块标记出来</p><p>复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区。</p><h3 id="5-3-6固态硬盘SSD"><a href="#5-3-6固态硬盘SSD" class="headerlink" title="5.3.6固态硬盘SSD"></a>5.3.6固态硬盘SSD</h3><p>原理：基于闪存技术Flash Memory,属于可擦除ROM，即EEPROM</p><p>组成：闪存翻译层-负责翻译逻辑块号，找到对应页（Page)</p>]]></content>
    
    
    <summary type="html">有关系统</summary>
    
    
    
    <category term="操作系统" scheme="http://interaction2023.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://interaction2023.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>（hexo github）搭建云平台</title>
    <link href="http://interaction2023.cn/2024/10/01/ok/"/>
    <id>http://interaction2023.cn/2024/10/01/ok/</id>
    <published>2024-10-01T01:58:39.756Z</published>
    <updated>2025-03-19T12:39:40.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学实验报告3-1"><a href="#山东大学实验报告3-1" class="headerlink" title="山东大学实验报告3-1"></a>山东大学实验报告3-1</h1><h2 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h2><h2 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h2><table><thead><tr><th align="left"><strong>学号：202000130199  |姓名：荆树吉 |  班级：20数据</strong></th></tr></thead><tbody><tr><td align="left"><strong>实验题目：利用云平台搭建个人博客</strong></td></tr><tr><td align="left">**实验学时：2|<strong>实验日期： 2023.3.15</strong></td></tr><tr><td align="left"><strong>实验目的：熟悉个人博客系统的搭建。<br>具体包括：<br>参考方案：注册Github账号，搭建Hexo环境并实现个人博客搭建，撰写实验报告。</strong></td></tr><tr><td align="left"><strong>硬件环境： <br>联网的计算机一台</strong></td></tr><tr><td align="left">**软件环境：<br>Windows **</td></tr><tr><td align="left"><strong>实验步骤与内容：</strong></td></tr><tr><td align="left">•    1.安装Git<br>•<strong>windows：</strong>到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。<br>•2.安装Node.js<br>•<strong>windows：</strong>下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。<br>•3.安装Hexo<br>•前面git和nodejs安装好后，就可以安装hexo了，可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）<br>•定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，无视它就行<br>•npm install -g hexo-cli<br>•安装完后输入hexo -v验证是否安装成功。<br>•<br>•至此hexo就安装完了。<br>hexo init<br>这个Hexo可以自己取什么名字都行，然后，接着输入npm install安装必备的组件。<br><br>新建完成后，指定文件夹Hexo目录下有：<br><br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题**<br>_config.yml: 博客的配置文件**<br>这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，<br> <br><img src="/2024/10/01/ok/1.png" alt="初始">•4.GitHub创建个人仓库<br>•打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93New">https://github.com/，新建一个项目仓库New</a> repository，如下所示：<br>• <br><img src="/2024/10/01/ok/2.png" alt="建仓库"><br>•生成SSH添加到GitHub，连接Github与本地。<br>•右键打开git bash，然后输入下面命令：<br>•git config –global user.name “yourname”<br>•git config –global user.email “youremail”<br>•注意：第一次使用git后需要将用户名和邮箱进行初始化<br>•<br>•这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。例如<br>•git config –global user.name “jsj12345”<br>•git config –global user.email <a href="mailto:&#50;&#x31;&#x31;&#53;&#x35;&#x32;&#x35;&#56;&#51;&#x32;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#50;&#x31;&#x31;&#53;&#x35;&#x32;&#x35;&#56;&#51;&#x32;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a><br>•可以用以下两条，检查一下你有没有输对<br>•git config user.name<br>•git config user.email<br>•然后创建SSH,一路回车<br>•ssh-keygen -t rsa -C “youremail”<br>•cat ~&#x2F;.ssh&#x2F;id_rsa.pub<br>•打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图：<br>• <br><img src="/2024/10/01/ok/3.png" alt="密钥">)在git bash输入ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;</a>，如果如下图所示，出现你的用户名，那就成功了。<br>•6.将hexo部署到GitHub<br>•这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息<br>•修改最后一行的配置：<br>• deploy:<br>•  type: git<br>•  repository: <a href="https://github.com/jsj12345/jsj12345.github.io.git">https://github.com/jsj12345/jsj12345.github.io.git</a><br>•  branch: master<br>•repository修改为你自己的github项目地址即可就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。<br>•<br>•这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br>•npm install hexo-deployer-git –save<br>•hexo clean<br>•hexo generate<br>•hexo deploy<br>•<br>•7.设置个人域名<br>•可省略因为需要花钱，且意义不明显<br>•8.发布文章<br>•首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。<br>•<br>•然后输入hexo new post “我的第一篇博客”，新建一篇文章。<br>•<br>•然后打开D:\Hexo\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>•你可以会直接在vscode里面编写markdown文件，可以实时预览，也可以用用其他编辑md文件的软件的工具编写。<br>•编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。<br>•<br>•到这儿基本第一部分就完成了，已经完整搭建起一个比较简陋的个人博客了，接下来我们就可以对我们的博客进行个性化定制了。<br>个性化定制暂略</td></tr><tr><td align="left">结论分析与体会：Hexo是高效的静态网站生成框架，它基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。通过Hexo，我们可以直接使用Markdown语法来撰写博客</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">实验报告3-1</summary>
    
    
    
    <category term="云计算" scheme="http://interaction2023.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云平台搭建" scheme="http://interaction2023.cn/tags/%E4%BA%91%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>nlp05</title>
    <link href="http://interaction2023.cn/2024/10/01/nlp05/"/>
    <id>http://interaction2023.cn/2024/10/01/nlp05/</id>
    <published>2024-10-01T01:58:39.754Z</published>
    <updated>2025-03-19T12:39:10.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验5-词向量"><a href="#实验5-词向量" class="headerlink" title="实验5 词向量"></a>实验5 词向量</h2><h4 id="1-One-hot编码实验"><a href="#1-One-hot编码实验" class="headerlink" title="1.One-hot编码实验"></a>1.One-hot编码实验</h4><h5 id="1-1-实验介绍"><a href="#1-1-实验介绍" class="headerlink" title="1.1 实验介绍"></a>1.1 实验介绍</h5><p>One-hot编码也称之为独热编码，是NLP里的经常在预处理数据的时候使用的技术。通常是需要将离散型特征或者标签用One-hot编码。比如房价预测中，出现房屋朝向的特征，一共有南、东南、西南、东、东北、北、西北和西8个方向，那么这样的离散特征是需要One-hot编码的，比如“南”的one-hot编码为[1,0,0,0,0,0,0,0]，“东南”的One-hot编码为[0,1,0,0,0,0,0,0]…依此类推。</p><h4 id="1-2-实验要求"><a href="#1-2-实验要求" class="headerlink" title="1.2 实验要求"></a>1.2 实验要求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="string">&#x27;体育&#x27;</span>, <span class="string">&#x27;军事&#x27;</span>, <span class="string">&#x27;娱乐&#x27;</span>, <span class="string">&#x27;教育&#x27;</span>, <span class="string">&#x27;文化&#x27;</span>, <span class="string">&#x27;时尚&#x27;</span>, <span class="string">&#x27;科技&#x27;</span>, <span class="string">&#x27;财经&#x27;</span>]</span><br><span class="line">onehot_encode(x)</span><br></pre></td></tr></table></figure><p>编写onehot_encode函数，生成效果如下：</p><p><img src="/2024/10/01/nlp05/image-20210304202934556.png" alt="image-20210304202934556"></p><p><strong>提示</strong>：可以使用sklearn.preprocessing中的OneHotEncoder</p><h5 id="1-3-思考题"><a href="#1-3-思考题" class="headerlink" title="1.3 思考题"></a>1.3 思考题</h5><p>从one-hot编码结果来看，one-hot编码的缺点是什么？</p><h4 id="2-Word2vec词向量训练"><a href="#2-Word2vec词向量训练" class="headerlink" title="2.Word2vec词向量训练"></a>2.Word2vec词向量训练</h4><p>Word2vec是Google在2013年开源的一款用于词向量计算的工具，一经发布就引起了工业界和学术界的关注。首先，Word2vec可以在百万数量级的词典和上亿的数据集上进行高效地训练；其次，该工具训练得到的词向量（word embedding），可以很好地度量词与词之间的相似性。Word2vec不是一种深度学习算法，其后面只是一个浅层神经网络，包含两种模型：CBOW模型和Skip-gram模型。</p><p>本实验主要是基于Python和gensim框架实现Word2vec在Wikipedia语料集上面的应用，并且获取词的词向量以及寻找相近词。</p><h5 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1 数据集"></a>2.1 数据集</h5><p>数据来源于维基语料</p><p>数据链接：<a href="https://icloud.qd.sdu.edu.cn:7777/link/28AA675BD5725B6D09B317234579B273">https://icloud.qd.sdu.edu.cn:7777/link/28AA675BD5725B6D09B317234579B273</a><br>有效期限：2021-05-20</p><p>共计33w条数据，数据太大，可以取10w条（或5w，数据量太小容易导致训练结果不佳）进行实验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据处理部分</span></span><br><span class="line"><span class="keyword">from</span> gensim.corpora <span class="keyword">import</span> WikiCorpus</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> word2vec</span><br><span class="line"><span class="keyword">import</span> zhconv <span class="comment">#繁体字简体字转换</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">input_file_name = <span class="string">&#x27;zhwiki-latest-pages-articles.xml.bz2&#x27;</span></span><br><span class="line">output_file_name = <span class="string">&#x27;corpus_cn.txt&#x27;</span></span><br><span class="line"><span class="comment">#加载数据</span></span><br><span class="line">input_file = WikiCorpus(input_file_name, lemmatize=<span class="literal">False</span>, dictionary=&#123;&#125;)</span><br><span class="line"><span class="comment">#将lemmatize设置为False的主要目的是不使用pattern模块来进行英文单词的词干化处理，无论你的电脑#是否已经安装了pattern，因为使用pattern会严重影响这个处理过程，变得很慢</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(output_file_name, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> output_file:</span><br><span class="line"><span class="comment">#使用WikiCorpus类中的get_texts()方法读取文件，每篇文章转换为一行文本，并去掉标签符号等内容</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> input_file.get_texts():</span><br><span class="line">        output_file.write(<span class="string">&#x27; &#x27;</span>.join(text) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;已处理%d条数据&#x27;</span> % count)            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;处理完成！&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#查看处理结果</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;corpus_cn.txt&#x27;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.readlines()[:<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h5 id="2-2-基本步骤"><a href="#2-2-基本步骤" class="headerlink" title="2.2 基本步骤"></a>2.2 基本步骤</h5><ol><li><p><strong>预处理</strong>：包括繁体-&gt;简体转换，分词，去除非中文词等主要步骤。</p></li><li><p><strong>训练词向量</strong>：使用gensim训练并保存model。</p></li><li><p><strong>加载模型并测试效果</strong>：如查看词汇的词向量，获取与某词汇最相关的n个词。</p></li></ol><p>例如：<img src="/2024/10/01/nlp05/image-20210304213009944.png" alt="image-20210304213009944"></p>]]></content>
    
    
    <summary type="html">8</summary>
    
    
    
    <category term="nlp" scheme="http://interaction2023.cn/categories/nlp/"/>
    
    
    <category term="词向量" scheme="http://interaction2023.cn/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>KVM环境配置</title>
    <link href="http://interaction2023.cn/2024/10/01/KVM/"/>
    <id>http://interaction2023.cn/2024/10/01/KVM/</id>
    <published>2024-10-01T01:58:39.751Z</published>
    <updated>2025-03-19T12:38:32.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h2 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h2><table><thead><tr><th>学号：</th><th>姓名：</th><th>班级：</th></tr></thead><tbody><tr><td>202000130199</td><td>荆树吉</td><td>20数据</td></tr></tbody></table><table><thead><tr><th>实验题目：虚拟化技术练习三KVM</th><th></th></tr></thead><tbody><tr><td>实验学时：2</td><td>实验日期：  2023.4.8</td></tr></tbody></table><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>在Linux环境下，熟悉KVM虚拟化环境。</p><p>具体包括：了解KVM虚拟化环境的配置和部署，完成实验环境及实验工具的熟悉，撰写实验报告。</p><h3 id="硬件环境："><a href="#硬件环境：" class="headerlink" title="硬件环境："></a>硬件环境：</h3><p>联网的计算机一台</p><h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3><p>Linux</p><h3 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h3><h4 id="一．先决条件"><a href="#一．先决条件" class="headerlink" title="一．先决条件"></a>一．先决条件</h4><p>要运行带有2 GB以上RAM的guest虚拟机，对应的虚拟环境必须拥有64位主机系统</p><p>再继续安装之前，要确保对应的ubundu虚拟机支持KVM虚拟化，系统应具有VT-x(vmx)的Intel处理器或具有AMD-V(svm)技术的AMD处理器。</p><p>以下grep命令以验证您的处理器支持硬件虚拟化：</p><p>grep -Eoc ‘(vmx|svm)’ &#x2F;proc&#x2F;cpuinfo</p><p>如果CPU支持硬件虚拟化，则该命令将输出一个大于零的数字，即CPU核心的数量。否则，如果输出是，0则表示CPU不支持硬件虚拟化。比如我对应的输出结果就是4</p><p>在某些计算机上，制造商可能会在BIOS中禁用虚拟技术扩展。</p><p>要检查BIOS中是否启用了VT，请使用kvm-ok软件包中随附的工具。以超级用户或具 有sudo特权的用户身份输入以下命令来安装cpu-checker包含该kvm-ok命令的软件包：</p><p>   sudo apt update</p><p>sudo apt install cpu-checker</p><p>安装完成后，检查我的系统是否可以运行硬件加速的KVM虚拟机：</p><p>kvm-ok</p><p>如果未在BIOS中禁用处理器虚拟化功能，则输出将如下所示：</p><p>INFO: &#x2F;dev&#x2F;kvm exists</p><p>KVM acceleration can be used</p><h4 id="二．在Ubuntu-20-04上安装KVM"><a href="#二．在Ubuntu-20-04上安装KVM" class="headerlink" title="二．在Ubuntu 20.04上安装KVM"></a>二．在Ubuntu 20.04上安装KVM</h4><p>运行以下命令以安装KVM和其他虚拟化管理软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager</span><br></pre></td></tr></table></figure><p>qemu-kvm -为KVM管理程序提供硬件仿真的软件。</p><p>libvirt-daemon-system -用于将libvirt守护程序作为系统服务运行的配置文件。</p><p>libvirt-clients -用于管理虚拟化平台的软件。</p><p>bridge-utils -一组用于配置以太网桥的命令行工具。</p><p>virtinst -一组用于创建虚拟机的命令行工具。</p><p>virt-manager -易于使用的GUI界面和支持命令行工具，用于通过libvirt管理虚拟机。</p><p>安装软件包后，libvirt守护程序将自动启动。您可以通过键入以下内容进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl is-active libvirtd</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">active</span><br></pre></td></tr></table></figure><p>为了能够创建和管理虚拟机，需要将用户添加到“ libvirt”和“ kvm”组中。为此，请输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG libvirt <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line">sudo usermod -aG kvm <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>$USER 是一个环境变量，其中包含当前登录用户的名称。</p><p>注销并重新登录，以便刷新组成员身份。</p><h4 id="三．网络设置"><a href="#三．网络设置" class="headerlink" title="三．网络设置"></a>三．网络设置</h4><p>在安装过程中会创建一个名为“ virbr0”的网桥。该设备使用NAT将来宾计算机连接到外界。</p><p>可以使用该brctl工具列出当前网桥及其连接的接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brctl show</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="/2024/10/01/KVM/clip_image002.png" alt="img"></p><p>“ virbr0”网桥未添加任何物理接口。“ virbr0-nic”是虚拟设备，没有流量通过该虚拟设备。该设备的唯一目的是避免更改“ virbr0”网桥的MAC地址。</p><p>此网络设置适用于大多数Ubuntu桌面用户，但有局限性。如果要从本地网络外部访问来宾，则需要创建一个新的网桥并对其进行配置，以便来宾计算机可以通过主机物理接口连接到外部世界</p><h4 id="四．创建虚拟机"><a href="#四．创建虚拟机" class="headerlink" title="四．创建虚拟机"></a>四．创建虚拟机</h4><p>现在，我的Ubuntu桌面上已安装了KVM，您可以创建第一个VM。可以从命令行或使用virt-manager应用程序完成此操作。</p><p>下载要安装的操作系统的ISO映像，然后按照以下步骤创建虚拟机：</p><p>  我所选择的对应的ISO映像是</p><p>  CentOS-7.5-x86_64-DVD-1804.iso</p><ol><li><p>使用virt-manager打开对应的应用程序</p></li><li><p>启动应用程序后，从顶部菜单中单击“File”-&gt;“New Virtual Machine”：<img src="/2024/10/01/KVM/clip_image002-1681637740764-2.png" alt="img"></p></li><li><p>将会出现一个新窗口。选择“Local install media(ISO image or CDROM”，然后单击“Forward”按钮。<img src="/2024/10/01/KVM/clip_image004.png" alt="img"></p></li><li><p>提供ISO映像路径，然后单击“Forward”按钮。</p></li><li><p>在下一个屏幕中，选择VM的内存和CPU设置。单击前进。由于我的linux环境是对应的虚拟机，所以对应的内存我就没做具体设置，没有分配磁盘空间</p></li><li><p>接下来，选择“为虚拟机创建磁盘映像”，然后选择VM的磁盘空间大小。单击前进</p></li><li><p>输入您的虚拟机名称的名称，然后单击“完成”。</p></li><li><p>VM将启动，并打开一个新窗口：对应的KVM虚拟机是可以和一般的centos系统进行相同的操作，以下为对应的centos系统配置结果</p></li></ol><p><img src="/2024/10/01/KVM/clip_image002-1681637784065-5.png" alt="img"></p><p>KVM配置完成。</p><h3 id="结论分析与体会："><a href="#结论分析与体会：" class="headerlink" title="结论分析与体会："></a>结论分析与体会：</h3><p>对应的虚拟机的apt安装是需要设置一下的</p><p>KVM（基于内核的虚拟机）是内置在Linux内核中的开源虚拟化技术。本实验结果提供有关如何在Ubuntu 20.04桌面上安装和配置KVM的说明。我们还将向您展示如何创建可用作不同应用程序开发环境的虚拟机。</p><p>KVM（基于内核的虚拟机）是内置在Linux内核中的开源虚拟化技术。用KVM运行多个Linux或Windows来宾虚拟机。每个来宾都彼此完全隔离，并具有自己的操作系统和专用的虚拟硬件，例如CPU，内存，网络接口和存储。</p><p>本实验提供有关如何在Ubuntu 20.04桌面上安装和配置KVM的说明。</p>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="http://interaction2023.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="KVM" scheme="http://interaction2023.cn/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境配置</title>
    <link href="http://interaction2023.cn/2024/10/01/Docker/"/>
    <id>http://interaction2023.cn/2024/10/01/Docker/</id>
    <published>2024-10-01T01:58:39.748Z</published>
    <updated>2024-10-02T11:30:15.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h1 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h1><table><thead><tr><th>学号：202000130199</th><th>姓名： 荆树吉</th><th>班级： 20 数据</th></tr></thead><tbody><tr><td>实验题目：虚拟化技术练习四Docker</td><td></td><td></td></tr><tr><td>实验学时：2</td><td>实验日期：  2023.4.15</td><td></td></tr></tbody></table><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><p>熟悉Docker虚拟化环境。</p><p>具体包括：了解Docker虚拟化环境的配置和部署，完成实验环境及实验工具的熟悉，包括使用官方镜像运行容器，以及借助官方镜像构建、运行自己的镜像和容器，撰写实验报告。</p><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境:"></a>硬件环境:</h2><p> 联网的计算机一台</p><h2 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h2><p>.15.0-69-generic #76~20.04.1-Ubuntu SMP Mon Mar 20 15:54:19 UTC 2023 x86_64 x86_64 x86_64 GNU&#x2F;Linux</p><h2 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h2><ol><li><h3 id="了解Docker虚拟化环境的配置和部署"><a href="#了解Docker虚拟化环境的配置和部署" class="headerlink" title="了解Docker虚拟化环境的配置和部署"></a>了解Docker虚拟化环境的配置和部署</h3><p>sudo apt-get -y install docker.io</p><p>安装完成后执行 docker，表明安装成功。</p><p>sudo docker pull ubuntu</p><p>安装完成之后默认会启动docker服务，如果没有启动和正常服务一样启动就好</p><p>docker version</p><p><img src="/2024/10/01/Docker/clip_image002.png" alt="docker version"></p></li><li><h3 id="使用官方镜像运行容器"><a href="#使用官方镜像运行容器" class="headerlink" title="使用官方镜像运行容器"></a>使用官方镜像运行容器</h3><p>查看下载到本地的所有镜像</p><p>docker images</p><p><img src="/2024/10/01/Docker/clip_image002-1681821166374-16.png" alt="docker images"></p><p> 查看容器</p><p> docker ps -a</p><p><img src="/2024/10/01/Docker/clip_image004.png" alt="查看容器"></p><p>删除镜像</p><p>docker rmi +镜像名</p><p>docker rmi +镜像标签</p><p><img src="/2024/10/01/Docker/clip_image006.png" alt="删除镜像"></p><p>下载镜像</p><p>docker pull +镜像名</p><p><img src="/2024/10/01/Docker/clip_image008.png" alt="下载镜像"></p><p>查看是否拉入镜像</p><p><img src="/2024/10/01/Docker/clip_image010.png" alt="查看是否拉入镜像"></p><p>已拉入</p><p>创建容器</p><p>docker create -it cengos:7 &#x2F;bin&#x2F;bash  &#x2F;&#x2F;创建一个新的容器但不启动它 #&#x2F;bin&#x2F;bash 交互   对应的镜像名</p><p>#选项：</p><p>-i ：  让容器的标准输入保持打开</p><p>-t ：  分配一个伪终端</p><p>-d ：  后台守护进程的方式运行</p><p>#去查询容器会发现状态为Created</p><p><img src="/2024/10/01/Docker/clip_image012.png" alt="查看容器"></p><p>启动容器</p><p>docker start 容器ID</p><p>打开刚刚创建的容器</p><p><img src="/2024/10/01/Docker/clip_image014.png" alt="启动容器"></p><p>停止容器</p><p>docker stop 容器id</p><p>停止刚刚打开的容器</p><p><img src="/2024/10/01/Docker/clip_image016.png" alt="停止容器"></p><p>容器已经被停止</p></li><li><h3 id="借助官方镜像构建、运行自己的镜像和容器"><a href="#借助官方镜像构建、运行自己的镜像和容器" class="headerlink" title="借助官方镜像构建、运行自己的镜像和容器"></a>借助官方镜像构建、运行自己的镜像和容器</h3><h4 id="①-建立dockerfile文件"><a href="#①-建立dockerfile文件" class="headerlink" title="① 建立dockerfile文件"></a>① 建立dockerfile文件</h4><p>（1） 新建工作目录dockertest，并新建Dockerfile。使用的命令如下：</p><p>mkdir dockertest</p><p>cd dockertest</p><p>touch Dockerfile </p><p>​       使用ls查看当前目录下的文件</p><p>​        <img src="/2024/10/01/Docker/clip_image002-1681821353211-25.png" alt="查看当前文件"></p><p>（2） 使用vim编辑Dockerfile</p><p><img src="/2024/10/01/Docker/clip_image004-1681821353212-26.png" alt="vim编辑Dockerfile"></p><p>其中，</p><p>  FROM ：定制的镜像都是基于 FROM 的镜像，也就是说，你的docker容器的系统。这里用的是ubuntu:latest，详细用法不再这里介绍，你可以在dockerhub上找其他的镜像。</p><p>  WORKDIR：你的工作目录，当你运行容器后，是一个ubuntu系统，在根目录会建立一个Mydata的目录。</p><p>  RUN：你可以暂且理解为制定镜像时，为ubuntu系统配置环境，安装一些包的命令执行过程。这里的run是我要配置一个opencv环境所要进行的操作，你可以按照你自己的需求来。</p><p>  CMD：执行docker run时默认执行的命令，docker在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat &#x2F;etc&#x2F;os-release。这就是用 cat &#x2F;etc&#x2F;os-release 命令替换了默认的 &#x2F;bin&#x2F;bash 命令了，输出了系统版本信息。</p><h4 id="②-制作docker镜像"><a href="#②-制作docker镜像" class="headerlink" title="② 制作docker镜像"></a>② 制作docker镜像</h4><p>在有Dockfile的这个目录下，执行该命令:</p><p>​    sudo docker build -t ubuntudocker:new .</p><p>​    由于自建的镜像较大，故只提供部分截图</p><p>​    <img src="/2024/10/01/Docker/clip_image002-1681821409004-29.png" alt="建立镜像"></p><p>​     可以使用下面的命令浏览有哪些镜像：</p><p><img src="/2024/10/01/Docker/clip_image004-1681821409005-30.png" alt="浏览镜像"></p><h4 id="③运行docker容器"><a href="#③运行docker容器" class="headerlink" title="③运行docker容器"></a>③运行docker容器</h4><p><img src="/2024/10/01/Docker/clip_image002-1681821468607-33.png" alt="运行并使用容器"></p><p>内部容器已经可以使用python3.10.6环境</p><p>打包镜像同上</p></li></ol><h2 id="结论分析与体会："><a href="#结论分析与体会：" class="headerlink" title="结论分析与体会："></a>结论分析与体会：</h2><p>docker是一种轻量级的虚拟机，docker是一个用于开发、交付、和运行应用程序的开放平台。</p><p>在linux容器里运行的开源工具：容器引擎，让开发者可以打包大量的应用及依赖包到一个可移植的镜像中，然后发布到任何流行的linux或者window机器中</p><p>进行实验的过程中需要不断的安装新的环境，要注意环境的兼容性</p><p>自己镜像的创建很费时间</p><p>docker引擎统一了基础设施环境–docker环境</p><p>docker引擎统一了程序打包（装箱）方式，docker镜像（把引擎放在镜像中，带着经i选哪个到处跑</p><p>docker引擎统一了程序部署（运行）方式–docker容器（利用引擎把这个镜像再去运行为之前的一摸一样的容器）</p>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="http://interaction2023.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="Docker" scheme="http://interaction2023.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成</title>
    <link href="http://interaction2023.cn/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <id>http://interaction2023.cn/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</id>
    <published>2024-10-01T01:58:39.746Z</published>
    <updated>2024-10-09T14:16:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="本章知识回顾"><a href="#本章知识回顾" class="headerlink" title="本章知识回顾"></a>本章知识回顾</h2><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/1.2.2.png" alt="1.2.2"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/1.2.2.1.png" alt="1.2.2.1"></p><p><img src="/2024/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/1.3.png" alt="1.3"></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>1)计算机由哪几部分组成?以哪部分为中心?计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称中央处理器。</p><p>在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。随着微电子技术的发展，同时计算机需要处理、加工的信息量也与日俱增，大量IO设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已发展为以存储器为中心，使 IO 操作尽可能地绕过 CPU，直接在IO设备和存储器之间完成，以提高系统的整体运行效率。</p><p>2)主频高的 CPU 一定比主频低的 CPU 快吗?为什么?</p><p>衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系,但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标(架构、缓存、指令集、CPU的位数、Cache 大小等)。由于主频并不直接代表运算速度,因此在一定情况下很可能会出现主频较高的 CPU 实际运算速度较低的现象。</p><p>3)翻译程序、汇编程序、编译程序、解释程序有什么差别?各自的特性是什么?<br>见常见问题和易混淆知识点1。</p><p>4)不同级别的语言编写的程序有什么区别?哪种语言编写的程序能被硬件直接执行?</p><p>机器语言和汇编语言与机器指令对应,而高级语言不与指令直接对应,具有较好的可移植性。<br>其中机器语言编写的程序可以被硬件直接执行。</p><h2 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h2><p><strong>1、翻译程序、解释程序、汇编程序、编译程序的区別和联系是什么?</strong></p><p><strong>翻译程序</strong>有两种;一种是<strong>编译程序</strong>，它将高级语言程序一次<strong>全部翻译成目标程序</strong>，只要程序不变，就<strong>无须重新翻译</strong>。另一种是<strong>解释程序</strong>，它将源程序的<strong>一条语言</strong>翻译成对应的<strong>机器目标代码</strong>，并立即执行，然后翻译下一条源程序语言并执行，直至所有源程序语全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</p><p><strong>汇编程序</strong>也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。编译程序与汇编程序的区别;若源语言是诸如C、c、javs等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</p><p><strong>2.什么是透明性?透明是指什么都能看见吗?</strong></p><p>在计算机领域中，站在某类用户的角度，若<strong>感觉不到</strong>某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是<strong>透明的</strong>”。这与日常生活中的“<strong>透明</strong>”概念(公开、看得见)正好相反。例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的;而对于机器语言或汇编语言程序员来说，<strong>指令的格式、</strong>机器结构、数据格式等则不是透明的。在CPU中，<strong>IR、MAR和MDR对各类程序员都是透明的。</strong><br>成的间顾即使是回度的差异</p><p><strong>3、字、字长、机器字长、指令字长、春储字长的区别和联系是什么?</strong></p><p><strong>字长</strong>是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。</p><p><strong>字</strong>和<strong>字长</strong>的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。</p><p>**指令字长:**一个指令字中包含的二进制代码的位数。</p><p>**存储字长:**一个存储单元存储的二进制代码的位数。<br>它们都必须是字节的整数倍。</p><p>指令字长一般取存储字长的<strong>整数倍</strong>，若指令字长等于存储字长的<strong>2倍</strong>，则需要<strong>2个访存周期</strong>来取出一条指令;若指令字长等于存储字长，则取指令周期等于机器周期。</p><p><strong>早期的存储字长一般与指令字长、字长相等</strong>，因此访问一次主存储器便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是<strong>字节的整数倍。</strong></p><p><strong>4、计算机体系结构和计算机组成的区别和联系是什么?</strong><br>计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、<br>数据类型、存储器寻址技术等，大都属于抽象的属性。,分算机组成是指如何实现计算机体系结构所体现的属性，它包含许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题、因此，当两合机器的指令系统相同时，只能认为它们具有相同的格局，至于这两合机器如何实现其指令，则完全可以不同、即可以认为它们的组成方式是不同的销物、三台机器是否具备乘法指令是一个结构的问题，但安现法指采什么式则是一个组成的问题。许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。</p><p><strong>5.基准程序执行得越快说明机器的性能越好吗?一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在度的差异，因此运行结果并不能完全说明问题。</strong></p>]]></content>
    
    
    <summary type="html">计算机组成</summary>
    
    
    
    <category term="计算机组成" scheme="http://interaction2023.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="计算机组成" scheme="http://interaction2023.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机网络配置和共享文件夹</title>
    <link href="http://interaction2023.cn/2024/10/01/4/"/>
    <id>http://interaction2023.cn/2024/10/01/4/</id>
    <published>2024-10-01T01:58:39.743Z</published>
    <updated>2025-03-19T12:32:54.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h1 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h1><table><thead><tr><th align="center">学号：202000130199</th><th>姓名： 荆树吉</th><th>班级： 20数据</th><th></th></tr></thead><tbody><tr><td align="center">实验题目：虚拟化技术练习一VMware</td><td></td><td></td><td></td></tr><tr><td align="center">实验学时：2</td><td>实验日期：</td><td></td><td></td></tr><tr><td align="center">实验目的：在Linux环境下，熟悉VMware虚拟化环境。  具体包括：了解VMware虚拟化环境的配置和部署，并配置网络连接，使其能够与本地计算机互相通信；在虚拟机中创建一个共享文件夹，使得本地计算机能够访问该共享文件夹，撰写实验报告。</td><td></td><td></td><td></td></tr><tr><td align="center">硬件环境：   联网的计算机一台</td><td></td><td></td><td></td></tr><tr><td align="center">软件环境：  Linux</td><td></td><td></td><td></td></tr><tr><td align="center">实验步骤与内容：  1. 安装VWware Workstation  官方正版VMware下载（16 pro）：我用的是阿里云盘传输下载，速度较快    下载Linux系统镜像，来源同上    安装：选一下安装地址，一直下一步即可。  <img src="/2024/10/01/4/clip_image002.jpg" alt="img">  新建虚拟机  现在我们就相当于买电脑，先把电脑配置整好。什么cpu啊内存条啊硬盘啊什么乱七八糟的，先不着急装系统。  Linux版本选的是GenOS7 64位。  一路默认  地址选在D盘  安装操作系统 选择镜像位置然后确认  打开虚拟机 读完秒后  选择简体中文  修改安装方式 选择GNOME桌面然后点完成  然后加一个默认的安装位置  开启网络连接  设置root密码和用户名密码  安装后重启 接受协议  安装配置进入界面  2. 并配置网络连接，使其能够与本地计算机互相通信  打开虚拟网络编辑器打开NAT模式  <img src="/2024/10/01/4/clip_image004.png" alt="img">  在面板-》虚拟机-》配置（一定要选择某台虚拟机，否则设置会变为灰色）  <img src="/2024/10/01/4/clip_image006.png" alt="img">  虚拟机内设置IP&#x2F;静态&#x2F;网关&#x2F;DNS  主机VMnet8的IP  <img src="/2024/10/01/4/clip_image008.png" alt="img">  主机连接网络的DNS(软件网络服务)     <img src="/2024/10/01/4/clip_image010.png" alt="img">  虚拟机内IP相关配置设置  vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33  例如：  6.重启network服务,配置生效  双方可ping通  网络连接完成     3.设置共享文件夹  选择待处理虚拟机，右键设置  在虚拟机设置 窗口：选择 选项–》点击 共享文件夹；文件夹共享 选择总是启用     在文件夹 ：添加共享目录； 弹出窗口 点击下一步–》设置共享文件夹目录 地址、共享文件夹名称 —》启用此共享 –》完成。 虚拟机设置完成。  <img src="/2024/10/01/4/clip_image012.png" alt="img">  3. 挂载  上述步骤完毕后，CentOS6会自动在&#x2F;mnt目录下挂载共享目录，但是CentOS7需要手动挂载。     1、在Centos 桌面打开终端（或者使用 XShell ：直接连接上就好)     2、查看共享目录情况  命令： vmware-hgfsclient  如果这是第一次设置共享目录， centos 7 需要创建文件夹在 &#x2F;mnt 下创建 &#x2F;hgfs  自动挂载：让虚拟机系统每次启动完成，自动挂载虚拟机已经设置的共享目录。在&#x2F;etc&#x2F;fstab文件中添加挂载目录  在打开的文件中 添加 ：  .host:&#x2F;共享文件名  &#x2F;mnt&#x2F;hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0　  mount -a生效</td><td></td><td></td><td></td></tr><tr><td align="center">结论分析与体会：  采用ubundu虚拟机会找不到对应的  网络配置的文件ens33  应该选择cento的linux系统  方可实现主机和虚拟机之间的联系</td><td></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="http://interaction2023.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="VM" scheme="http://interaction2023.cn/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境基本操作练习</title>
    <link href="http://interaction2023.cn/2024/10/01/1/"/>
    <id>http://interaction2023.cn/2024/10/01/1/</id>
    <published>2024-10-01T01:58:39.740Z</published>
    <updated>2025-03-19T12:32:14.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学实验报告-1"><a href="#山东大学实验报告-1" class="headerlink" title="山东大学实验报告 1"></a>山东大学实验报告 1</h1><h2 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h2><h2 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h2><p><strong>学号：202000130199  |姓名：荆树吉 |  班级：20数据</strong></p><h3 id="实验题目：Linux环境基本操作练习"><a href="#实验题目：Linux环境基本操作练习" class="headerlink" title="实验题目：Linux环境基本操作练习"></a>实验题目：Linux环境基本操作练习</h3><h3 id="实验学时：2"><a href="#实验学时：2" class="headerlink" title="实验学时：2"></a>实验学时：2</h3><h3 id="实验日期：-2023-2-25"><a href="#实验日期：-2023-2-25" class="headerlink" title="实验日期：  2023.2.25"></a>实验日期：  2023.2.25</h3><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>在Linux环境下，熟悉基本的文件操作和命令</p><p>具体包括：了解Linux，浏览文件、创建文件、安装一个程序、了解Python、C++等常用编程环境</p><h3 id="硬件环境："><a href="#硬件环境：" class="headerlink" title="硬件环境："></a>硬件环境：</h3><p>计算机一台</p><h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3><p>Linux</p><h3 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h3><h4 id="1-了解linux"><a href="#1-了解linux" class="headerlink" title="1.了解linux"></a>1.了解linux</h4><p>Linux，全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。</p><h4 id="2-浏览文件和创建文件"><a href="#2-浏览文件和创建文件" class="headerlink" title="2.浏览文件和创建文件"></a>2.浏览文件和创建文件</h4><p>ls可以浏览当前文件夹的所有文件vi可以浏览文件之间的具体内容</p><p><img src="/2024/10/01/1/1.png" alt="1.浏览文件夹内容"></p><p>vi test</p><p><img src="/2024/10/01/1/2.png" alt="2.浏览文件内容"></p><h4 id="3-安装程序"><a href="#3-安装程序" class="headerlink" title="3.安装程序"></a>3.安装程序</h4><h5 id="一、-源码编译安装（二进制安装）"><a href="#一、-源码编译安装（二进制安装）" class="headerlink" title="一、 源码编译安装（二进制安装）"></a>一、 源码编译安装（二进制安装）</h5><p>程序：由开发人员写代码一个一个单词敲出来的</p><p>源码：编写好的.c.java文件</p><p>编译：将人类写的代码翻译成二进制语言</p><p>安装：将二进制保存在键盘上</p><p>缺点：</p><p> 如果编译出了问题，你不懂源代码，无法解决</p><p>安装过程复杂</p><p>没有统一的管理人员</p><p>优点：</p><p> 契合系统，兼容性强</p><p>如果你可以看懂源代码，修改新增功能</p><p>比较自由</p><h5 id="二、rpm安装（安装包管理工具）"><a href="#二、rpm安装（安装包管理工具）" class="headerlink" title="二、rpm安装（安装包管理工具）"></a>二、rpm安装（安装包管理工具）</h5><p>优点：</p><p> 统一的安装包格式</p><p>已经帮你编译完成</p><p>使用简单</p><p>缺点：</p><p> 有依赖关系（安装 a ，就需要先安装别的）</p><p>查询（对已安装程序查询）</p><p>查看系统已安装的所有软件（-qa）</p><h4 id="4-c-和python的利用-vscode"><a href="#4-c-和python的利用-vscode" class="headerlink" title="4 .c++,和python的利用 vscode"></a>4 .c++,和python的利用 vscode</h4><h5 id="1-c-代码"><a href="#1-c-代码" class="headerlink" title="1.c++代码"></a>1.c++代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,X,Y;</span><br><span class="line"><span class="type">int</span> x[<span class="number">202</span>],y[<span class="number">202</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">d</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis;</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d node[<span class="number">202</span>];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;X&gt;&gt;Y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">        node[i].dis=(x[i]-X)*(x[i]-X)+(y[i]-Y)*(y[i]-Y);</span><br><span class="line">        node[i].no=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t,k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((node[i].dis&gt;node[j].dis)||((node[i].dis==node[j].dis)&amp;&amp;(node[i].no&gt;node[j].no)))</span><br><span class="line">            &#123;</span><br><span class="line">               t=node[i].dis;</span><br><span class="line">               node[i].dis=node[j].dis;</span><br><span class="line">               node[j].dis=t;</span><br><span class="line">               k=node[i].no;</span><br><span class="line">               node[i].no=node[j].no;</span><br><span class="line">               node[j].no=k;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;node[i].dis&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node[i].no&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;node[<span class="number">0</span>].no+<span class="number">1</span>&lt;&lt;endl&lt;&lt;node[<span class="number">1</span>].no+<span class="number">1</span>&lt;&lt;endl&lt;&lt;node[<span class="number">2</span>].no+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给出一个点的坐标和其他的点的个数</p><p>再给出几个对应的点的坐标</p><p>判断里这个点最近的三个点</p><p>三个点的顺序由序号越小对应的距离就越近</p><h5 id="2-python-代码"><a href="#2-python-代码" class="headerlink" title="2.python 代码"></a>2.python 代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#读入文件</span></span><br><span class="line">file_path = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">df = pd.read_table(file_path, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 x  y变量</span></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义颜色变量</span></span><br><span class="line">color = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;w&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#用for循环将文件中的值赋值给x，y</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df[<span class="number">0</span>])):</span><br><span class="line">    x.append(<span class="built_in">int</span>(df[<span class="number">0</span>][i].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>]))</span><br><span class="line">    y.append(<span class="built_in">int</span>(df[<span class="number">0</span>][i].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line">plt.scatter(x, y, c=color[<span class="number">2</span>], edgecolors=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">画一个散点图</span><br><span class="line">数据如下</span><br><span class="line"><span class="number">151</span>,<span class="number">54</span></span><br><span class="line"><span class="number">137</span>,<span class="number">55</span></span><br><span class="line"><span class="number">95</span>,<span class="number">66</span></span><br><span class="line"><span class="number">156</span>,<span class="number">91</span></span><br><span class="line"><span class="number">193</span>,<span class="number">101</span></span><br><span class="line"><span class="number">58</span>,<span class="number">104</span></span><br><span class="line"><span class="number">133</span>,<span class="number">105</span></span><br><span class="line"><span class="number">120</span>,<span class="number">118</span></span><br><span class="line"><span class="number">167</span>,<span class="number">136</span></span><br><span class="line"><span class="number">110</span>,<span class="number">149</span></span><br><span class="line"><span class="number">96</span>,<span class="number">174</span></span><br><span class="line"><span class="number">22</span>,<span class="number">184</span></span><br><span class="line"><span class="number">60</span>,<span class="number">193</span></span><br><span class="line"><span class="number">88</span>,<span class="number">198</span></span><br><span class="line"><span class="number">177</span>,<span class="number">202</span></span><br><span class="line"><span class="number">213</span>,<span class="number">235</span></span><br><span class="line"><span class="number">133</span>,<span class="number">249</span></span><br><span class="line"><span class="number">127</span>,<span class="number">255</span></span><br><span class="line"><span class="number">70</span>,<span class="number">257</span></span><br><span class="line"><span class="number">40</span>,<span class="number">273</span></span><br><span class="line"><span class="number">64</span>,<span class="number">271</span></span><br><span class="line"><span class="number">168</span>,<span class="number">286</span></span><br><span class="line"><span class="number">126</span>,<span class="number">325</span></span><br><span class="line"><span class="number">132</span>,<span class="number">335</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结论分析与体会"><a href="#结论分析与体会" class="headerlink" title="结论分析与体会"></a>结论分析与体会</h3><p>Linux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux不仅仅是被网络运维人员当作服务器使用，甚至当作网络防火墙，这是Linux的一大亮点。</p><p>Linux具有开放源码、没有版权、技术社区用户多等特点，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。</p><p>Linux的基本思想有两点：第一，一切都是文件；第二，每个文件都有确定的用途。其中第一条详细来讲就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近。</p>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="http://interaction2023.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="linux 操作" scheme="http://interaction2023.cn/tags/linux-%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>openVZ</title>
    <link href="http://interaction2023.cn/2023/10/28/openVZ/"/>
    <id>http://interaction2023.cn/2023/10/28/openVZ/</id>
    <published>2023-10-28T04:40:01.997Z</published>
    <updated>2025-03-19T12:40:35.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h1 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h1><table><thead><tr><th>学号：202000130199</th><th>姓名： 荆树吉</th><th>班级： 20数据</th></tr></thead></table><table><thead><tr><th>实验题目：操作系统虚拟化  OpenVZ</th></tr></thead></table><table><thead><tr><th>实验学时：2</th><th>实验日期： 2023.4.18</th></tr></thead></table><table><thead><tr><th>实验目的：在Linux环境下，熟悉OpenVZ虚拟化。  具体包括：自行了解OpenVZ虚拟化技术，完成实验环境及实验工具的熟悉，包括安装和配置OpenVZ，了解如何创建容器等，撰写实验报告。</th></tr></thead></table><table><thead><tr><th>硬件环境： 联网的计算机一台</th></tr></thead></table><table><thead><tr><th>软件环境：Linux</th></tr></thead></table><h2 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h2><h3 id="1-添加源"><a href="#1-添加源" class="headerlink" title="1.添加源"></a>1.添加源</h3><p>vim &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;openvz.list</p><p>写入下面内容保存</p><p>如果需要,可以视情况改动注释.</p><p>deb <a href="http://download.openvz.org/debian">http://download.openvz.org/debian</a> wheezy main</p><p># deb <a href="http://download.openvz.org/debian">http://download.openvz.org/debian</a> wheezy-test main</p><h3 id="2-导入key后更新"><a href="#2-导入key后更新" class="headerlink" title="2.导入key后更新"></a>2.导入key后更新</h3><p>wget <a href="http://ftp.openvz.org/debian/archive.key">http://ftp.openvz.org/debian/archive.key</a></p><p>apt-key add archive.key</p><p>apt update</p><h3 id="3-配置内核参数"><a href="#3-配置内核参数" class="headerlink" title="3. 配置内核参数"></a>3. 配置内核参数</h3><p>vim &#x2F;etc&#x2F;sysctl.conf</p><p>配置这些项:</p><p># On Hardware Node we generally need</p><p># packet forwarding enabled and proxy arp disabled</p><p>net.ipv4.ip_forward &#x3D; 1</p><p>net.ipv6.conf.default.forwarding &#x3D; 1</p><p>net.ipv6.conf.all.forwarding &#x3D; 1</p><p>net.ipv4.conf.default.proxy_arp &#x3D; 0</p><p># Enables source route verification</p><p>net.ipv4.conf.all.rp_filter &#x3D; 1</p><p># Enables the magic-sysrq key</p><p>kernel.sysrq &#x3D; 1</p><p># We do not want all our interfaces to send redirects</p><p>net.ipv4.conf.default.send_redirects &#x3D; 1</p><p>net.ipv4.conf.all.send_redirects &#x3D; 0</p><h3 id="4-让修改立刻生效"><a href="#4-让修改立刻生效" class="headerlink" title="4.让修改立刻生效:"></a>4.让修改立刻生效:</h3><p>sysctl -p</p><h3 id="5-安装64位系统用这个"><a href="#5-安装64位系统用这个" class="headerlink" title="5.安装64位系统用这个"></a>5.安装64位系统用这个</h3><p>apt install -y linux-image-openvz-amd64 vzctl vzquota ploop vzstats</p><h3 id="6-进入openvz内核"><a href="#6-进入openvz内核" class="headerlink" title="6.进入openvz内核"></a>6.进入openvz内核</h3><p>重启,在grub中选择”advance options for ubuntu”进入后可找到带着openvz的行(有可能不止一个,选第一个就是了)</p><h3 id="7-使用"><a href="#7-使用" class="headerlink" title="7.使用"></a>7.使用</h3><p>① 创建并初始化虚拟机</p><p>创建虚拟机需要下载系统模板</p><p>#创建虚拟机,编号102 参数是:虚拟机编号 –ostemplate 系统模板</p><p>vzctl create 102 –ostemplate debian-7.0-x86-minimal</p><p>#设置主机名称</p><p>vzctl set 102 –hostname “vz102” –save</p><p>#限制CPU</p><p>vzctl set 102 –cpuunits 1000 –cpulimit 50 –save</p><p>#限制I&#x2F;O</p><p>vzctl set 102 –iolimit 5M –save</p><p>#设置内存和swap</p><p>vzctl set 102 –ram 64M –swap 0G –save</p><p>#设置硬盘大小 参数:编号 –diskspace 软限制:硬限制 –save</p><p>vzctl set 102 –diskspace 64M:5G –save</p><p>#设置ip</p><p>vzctl set 102 –ipadd 192.168.0.2 –save</p><p>#设定dns服务器</p><p>vzctl set 102 –nameserver 8.8.8.8 –nameserver 8.8.4.4 –save</p><p>#设置root用户密码(需要Cgroup)</p><p>vzctl set 102 –userpasswd root:passwd</p><p>#主机开机时自动运行虚拟机,酌情使用</p><p>vzctl set 102 –onboot yes –save</p><p>② 启动</p><p>vzctl restart 102</p><p>③ 关闭</p><p>vzctl stop 102</p><p>④ 删除</p><p>vzctl destroy 102</p><p>⑤ 查看资源占用</p><p>vzcalc -v 102</p><h3 id="8-网络配置"><a href="#8-网络配置" class="headerlink" title="8.网络配置"></a>8.网络配置</h3><p>#Clear All configure</p><p>iptables -F</p><p>iptables -F -t nat</p><p>#let the computer can to forward data</p><p>iptables -A FORWARD -j ACCEPT</p><p>#这行是打通nat功能,让vps能通过host的ip发送数据到外网,外网也能返回数据,要改两个地方:网卡和最后的ip</p><p>iptables -t nat -A POSTROUTING -o eth0 -j SNAT –to 主机对外的ip</p><p>#这行是端口转发,把ssh端口打通一下</p><p>iptables -t nat -A PREROUTING -p tcp -m tcp –dport 10222 -j DNAT –to-destination 192.168.0.2:22</p><h2 id="结论分析与体会："><a href="#结论分析与体会：" class="headerlink" title="结论分析与体会："></a>结论分析与体会：</h2><p>优势：外面卖的这种类型，许可的内存都超大，CPU也强劲，而且卖家很多，可比性也很强。性价比超高。</p><p>劣势：超卖，没有不超卖的，导致各种石头盘，钻石盘。连带的cpu也被过度分割导致性能升值不如其标明的1&#x2F;10。再有就是内存，基本上OpenVZ技术没有独占的，都是共享，别人多了你就少了，而且这种技术最大的劣势就是内存下来后直接就是当机。还有开设vpn各种不方便</p>]]></content>
    
    
    <summary type="html">有关openVZ</summary>
    
    
    
    <category term="云计算" scheme="http://interaction2023.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="openVZ" scheme="http://interaction2023.cn/tags/openVZ/"/>
    
  </entry>
  
</feed>
