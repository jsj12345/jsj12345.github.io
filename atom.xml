<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JSJ-0513</title>
  
  <subtitle>about CS</subtitle>
  <link href="https://example.com/atom.xml" rel="self"/>
  
  <link href="https://example.com/"/>
  <updated>2025-10-24T12:05:50.691Z</updated>
  <id>https://example.com/</id>
  
  <author>
    <name>荆树吉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自注意力机制</title>
    <link href="https://example.com/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    <id>https://example.com/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</id>
    <published>2025-09-30T02:24:50.882Z</published>
    <updated>2025-10-24T12:05:50.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自注意力机制"><a href="#自注意力机制" class="headerlink" title="自注意力机制"></a>自注意力机制</h1><p><strong>自注意力（Self-Attention）机制</strong>是一种特殊的注意力机制，它允许模型在处理一个序列时，考虑到序列中<strong>每个元素</strong>与<strong>其他所有元素</strong>的关系。这种机制可以帮助模型更好地理解序列中的上下文信息，从而更准确地处理序列数据。 (序列数据是一种数据类型，其中的元素存在特定的顺序。每个元素都有特定的位置，且位置之间的顺序关系对于数据的含义和处理方式有重要影响）</p><p>在自注意力机制中，模型会<strong>计算序列中每个元素与其他所有元素的关联度（或称为权重）</strong>。这些权重反映了元素之间的相互关系，比如在语言模型中，它们可以反映词与词之间的语义关联度。（比如机器翻译）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例：以&quot;the 2022 Beijing Winter Games&quot;为例，当模型处理&quot;Games&quot;这个词时，通过自注意力机制，它可以考虑到&quot;2022&quot;、&quot;Beijing&quot;和&quot;Winter&quot;这些词的信息。这样，模型就能理解到&quot;Games&quot;在这里并不是指一般的&quot;游戏&quot;，而是指特定的&quot;比赛&quot;，并且这个&quot;比赛&quot;是在&quot;2022年&quot;、在&quot;北京&quot;举行的那就很好的理解为是&quot;冬季奥运会&quot;。</span><br></pre></td></tr></table></figure><h3 id="如何计算权重"><a href="#如何计算权重" class="headerlink" title="如何计算权重"></a>如何计算权重</h3><h3 id="理解查询（Query）键（Key）和值（Value）"><a href="#理解查询（Query）键（Key）和值（Value）" class="headerlink" title="理解查询（Query）键（Key）和值（Value）"></a>理解查询（Query）键（Key）和值（Value）</h3><p>对于输入序列中的每个元素，我们都会计算一个查询向量、一个键向量和一个值向量。（每一个元素都有QKV三个对应的矩阵）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例说明：假设你在图书馆里，你想找一本关于&quot;如何暴富&quot;的书。你的查询（Query）就是&quot;如何暴富&quot;。 图书馆的图书管理员就像是自注意力机制，他们需要根据你的查询（Query）在图书馆的大量书籍中找到相关的书。每一本书都有一个书名，这就是键（Key）。图书管理员会比较你的查询（Query）和每一本书的键（Key），也就是查询内容“如何暴富”和每一本书名进行比较，以确定哪些书与你的查询相关。 每一本书都有一些具体的信息，比如书的内容、作者等，这就是值（Value）。一旦图书管理员找到了与你的查询（Query）匹配的键（Key），他们就会给你那本书的值（Value），也就是你想要的书。</span><br></pre></td></tr></table></figure><p>当模型处理一个词（比如“games”）时，他会生成一个查询（QUERY).然后，模型会比较这个查询和其他所有词的键，以确定那些词与当前处理的词相关。最后，模型会根据这些相关词的值来更新当前处理的词的表示。所以，当模型处理”Games”这个词时，它可能会发现”2022”、”Beijing”和”Winter”这些词的键（Key）与”Games”的查询（Query）匹配，然后，模型就会考虑这些词的值，从而理解到“Game”这里并不是指一般的”游戏“,而是指特定的比赛，并且这个比赛是在”2022年”、在”北京”举行的”冬季奥运会”。</p><h4 id="过程说明："><a href="#过程说明：" class="headerlink" title="过程说明："></a><strong>过程说明：</strong></h4><p><img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/v2-403853c29f71b668bd1856b08e1cc3b4_1440w.jpg" alt="img"></p><p>注意力权重就是值向量</p><ol><li><p><strong>计算查询、键、值：</strong>对于输入序列中的每个元素，我们都会计算一个查询向量、一个键向量和一个值向量。<strong>这些向量是通过学习得到的权重矩阵</strong>与输入元素的线性变换得到的。 假设我们的输入序列为权重矩阵为</p><img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024193430127.png" alt="image-20251024193430127" style="zoom: 67%;"><p>那么对于每个元素我们有，<img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024193506001.png" alt="image-20251024193506001"> 其中<img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024193527578.png" alt="image-20251024193527578">分别表示第个元素的查询、键和值向量。（从矩阵中进行线性组合（一个元素有一个向量)这个向量与矩阵相乘会获得每个矩阵的查询向量。</p></li><li><p>计算注意力分数: 对于每一对元素<img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024193736926.png" alt="image-20251024193736926">, 我们计算一个注意力 分数, 表示 对 的注意力程度。</p></li><li><p>注意力分数是通过查询向量 和键向量的点积, 然后再除以一个缩放因子（通常是键向量维度的平方根) 得到的: <img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024193942105.png" alt="image-20251024193942105" style="zoom: 50%;">其中 <img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194025621.png" alt="image-20251024194025621">是键向量的维度。</p></li><li><p>计算注意力权重: 然后, 我们通过 softmax 函数使得注意力分数转为化0和1之前的数值且和为1，进而得出注意力权重, : <img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194100666.png" alt="image-20251024194100666" style="zoom:50%;">用自然对数</p></li><li><p>计算输出: 最后, 我们将每个元素的值向量与其对应的注意力权 重相乘, 然后求和, 得到最终的输出: <img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194222275.png" alt="image-20251024194222275">这些权重会被用来组合输入的词向量，生成一个新的上下文相关的词向量。这个词向量不仅包含了当前词的信息，还包含了其上下文的信息。这样，模型就能更好地理解每个词在具体上下文中的含义。</p></li></ol><h4 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h4><p><img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/v2-9e1eb58a851d1b6418e3fa3a8a30f18f_1440w.jpg" alt="img"></p><p>在多头注意力机制中，输入数据首先会被分成多个“头”（每个头包含若干个单词，以机器翻译为主），每个“头”都有自己的查询（Query）、键（Key）和值（Value）向量。每个头都会独立地进行自注意力计算，得到自己的注意力输出，计算过程与上面描述一致，最后将这些输出$z_i$拼接在一起，形成最终的输出。</p><p><img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194535797.png" alt="image-20251024194535797"></p><p>其中，<img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194640002.png" alt="image-20251024194640002">是输出权重矩阵，<img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194655618.png" alt="image-20251024194655618">是拼接操作。</p><p><img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194818057.png" alt="image-20251024194818057">函数的作用是将多个向量或矩阵在某一维度上进行拼接。在多头注意力机制中，<img src="/2025/09/30/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20251024194823304.png" alt="image-20251024194823304"> 函数用于将每个头的注意力输出向量拼接成一个大的向量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">具体来说，假设我们有h个头，每个头的注意力输出是一个d维的向量，那么通过 </span><br><span class="line"> textConcat函数拼接后，我们会得到一个 h*d 维的向量。这个大的向量包含了所有头的注意力输出信息。 可以让模型同时考虑到所有头的信息。因为每个头可能关注输入序列的不同部分，所以通过拼接，我们可以将这些不同的信息整合在一起，从而得到一个更全面的表示。</span><br></pre></td></tr></table></figure><p>多头注意力机制的优点是可以让模型同时关注输入序列的不同位置，从而捕捉更丰富的信息。例如，在处理自然语言时，模型可能需要同时关注一个句子中的主语和宾语，以理解句子的含义。通过多头注意力机制，模型可以在每个头中关注句子的不同部分，从而更好地理解句子的含义。</p><h4 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h4><p><strong>上下文注意力机制</strong>（<a href="https://zhida.zhihu.com/search?content_id=230686312&content_type=Article&match_order=1&q=Contextual++Attention&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjE0Nzc2MzEsInEiOiJDb250ZXh0dWFsICBBdHRlbnRpb24iLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoyMzA2ODYzMTIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.0UgGv9MEJQrvtvS5GnQh3zJYQKWBWUnWbkfSlhp3b2I&zhida_source=entity">Contextual Attention</a>）：这种注意力机制主要是在处理自然语言处理任务时使用的，它的主要目标是根据上下文信息来理解和生成语言。在这种机制中，模型会考虑到一个词的上下文信息（即它周围的词），并根据这些信息来确定它的含义。这种机制通常在词嵌入模型（如Word2Vec或GloVe）或者是语言模型（如BERT或GPT）中使用。</p><p><strong>编码器-解码器注意力机制</strong>（Encoder-Decoder Attention）：这种注意力机制主要是在处理序列到序列（Seq2Seq）任务时使用的，如机器翻译或者是文本摘要。在这种机制中，模型会在编码阶段将输入序列编码为一个固定长度的向量，然后在解码阶段根据这个向量来生成输出序列。在生成每一个输出元素时，模型会考虑到输入序列中的所有元素，并根据它们的重要性赋予不同的权重。这种权重通常是通过计算输入和输出元素之间的相似度得到的。</p>]]></content>
    
    
    <summary type="html">计算机组成</summary>
    
    
    
    <category term="机器学习" scheme="https://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="自注意力机制" scheme="https://example.com/tags/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>生成式对抗网络</title>
    <link href="https://example.com/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    <id>https://example.com/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</id>
    <published>2025-09-30T02:24:50.878Z</published>
    <updated>2025-10-24T11:55:25.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成式对抗网络（GAN）"><a href="#生成式对抗网络（GAN）" class="headerlink" title="生成式对抗网络（GAN）"></a>生成式对抗网络（GAN）</h1><p>传统的对应的架构，生成架构</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902193116848.png"></p><p>用network当作生成器，每一次随机生成对应的z，知道对应的分布是简单的，已知的均匀分布或者是正态分布，network的输出变成复杂的范围。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902193426646.png"></p><p>这样的网络就叫做生成器。</p><h2 id="为什么要选择分布？"><a href="#为什么要选择分布？" class="headerlink" title="为什么要选择分布？"></a>为什么要选择分布？</h2><p>训练资料是不断录制的影片，影片中小精灵的位置预测。传统的网络预测会让小精灵进行分裂，同样的转角会产生两种不同的结果，两种训练资料，进行两面讨好，就会同时向左向右转。让机器的输出是有几率的为其解决方法。加上一个分布包含向左转和向右转。</p><p><strong>当我们的任务需要一点创造性时</strong>，同样的输入，多种不同的输出。</p><p>让人们进行画图的工作会产生不同的结果，比如画一个红色的眼镜的人。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902194142327.png"></p><p>采用聊天的方法，去生成对应的图片。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902194240253.png"></p><p>这样我们就要生成式对抗网络。</p><h2 id="GAN的基础原理"><a href="#GAN的基础原理" class="headerlink" title="GAN的基础原理"></a>GAN的基础原理</h2><h3 id="淦"><a href="#淦" class="headerlink" title="淦"></a>淦</h3><p>，就是这么读。有很多种的英文字母，取名是很难的。</p><p>机器生成二次元人物的脸。</p><p>输入一个正态分布，生成一个低维的向量，会生成一个二次元人物的脸，产生一个非常高维的向量，输入不同，输出就会不同。选择一个简单的分布函数。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902194746830.png"></p><h3 id="Discriminator"><a href="#Discriminator" class="headerlink" title="Discriminator"></a><strong>Discriminator</strong></h3><p>输入一张图片，输出一个数字，判断一个图片是二次元人物的可能性。只是一个神经网络。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902194941956.png" alt="image-20250902194941956"></p><h3 id="Basic-Idea-of-GAN"><a href="#Basic-Idea-of-GAN" class="headerlink" title="Basic Idea of GAN"></a>Basic Idea of GAN</h3><p>因为有天敌，对应的枯叶蝶就会变成枯叶一般。对应的鸟儿也会进化，具有更加高明的手段，比如生成对应的枯叶蝶的纹路，之后还会进化。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902195226247.png"></p><p>Discriminator和对应的genertor会进行博弈。产生更加清晰的二次元人物</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902195432671.png"></p><p>对应的生成器与对应的判别器之间会不断的进行对抗，这也就是生成式对抗神经网络的由来。adversarial。这也就是人类的比喻、</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>如何运作？</p><p>初始化是两个network</p><p><strong>1.定住生成器G，不断的去训练对应的判别器D。</strong></p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902195949563.png"></p><p>对真正的二次元任务和对应的产生的二次元人物进行评分。</p><p><strong>2.相反的操作，</strong>对应的G去欺骗判别器，争取以假乱真。G不断的更新对应的参数，看判别器的评分，两者接起来，当作一个大的network来看。整个大的结果其中某一个输出就是一张大的图片，调整对应的G的参数，不去调试对应的D的对应的参数。只去调整生成器。训练的方法没有什么不同的。对应的目标就越大越好（对应的D的积分）</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902200218778.png"></p><p><strong>3.反复的训练</strong></p><p>一个训练另一个就不训练。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902200558561.png" alt="image-20250902200558561"></p><h2 id="GAN的理论部分"><a href="#GAN的理论部分" class="headerlink" title="GAN的理论部分"></a>GAN的理论部分</h2><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250902202005160.png" alt="image-20250902202005160"></p><p>衡量对应的PG与Pdata之间的相似度。这两者越接近越好。G*越小越好。divergence。对应的计算很难。</p><p>从PG和Pdata之间进行抽样。评估两者的分布，之间越接近越好。这两个分布之间的某种距离，越小越好。</p><p>只要知道怎么去取样，就有办法去计算距离。</p><p>GAN,对应的取样方法。从对应的数据库中取样即可。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250903155651525.png" alt="image-20250903155651525"></p><p>用判别器的力量，一大堆数据分别有不同的结果，看到realdata就给他很高的分数，看到生成的图就给他低分。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250903160143974.png"></p><p>尝试去训练一个二分类的模型，对应的二分类的模型的分类效果越好，对应的两个实际的和生成的分布之间的差距就会很大，对应的生成的效果就不好，也就是说实际的分布与生成的分布之间的距离是很大的。</p><p>相反，对应的二分类的分类效果越差，对应的两个实际的分布与生成的分布之间的差距就很小，对应的生成的分布就比较优秀。</p><p>训练一个discriminator，可以直接将divergence换成对应的距离，让这个最大距离的值最小，对应的生成就越逼真。可以获得各种各样的距离。</p><h2 id="TIPS-FOR-GAN"><a href="#TIPS-FOR-GAN" class="headerlink" title="TIPS FOR GAN"></a>TIPS FOR GAN</h2><h3 id="JS-divergence。"><a href="#JS-divergence。" class="headerlink" title="JS divergence。"></a>JS divergence。</h3><p>自然数据与实际数据之间的重叠部分往往非常的少 二维空间的两条直线是PG AND PDATA ，对应的重叠往往只是理论上的，实际利用计算是不造成影响的。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250903162521995.png" alt="image-20250903162521995"></p><p>对应的只要不重叠，对应的JS的值全都是ln2。</p><p>对应的二元分类器往往正确率是百分之百，没有什么意义</p><h3 id="Wasserstein-distance"><a href="#Wasserstein-distance" class="headerlink" title="Wasserstein distance."></a>Wasserstein distance.</h3><p>想想我们再开一台推土机，看推土机移动土的平均距离，有很多种的移动方法。穷举所有的推土计划，最小的推土的平均距离就是对应的Wd。</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250903163402461.png" alt="image-20250903163402461"></p><p>WGAN，对应的距离如何计算呢？</p><p><img src="/2025/09/30/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20250903163800359.png" alt="image-20250903163800359"></p><p>D是一个足够平滑的函数</p><h2 id="GAN还是很难训练"><a href="#GAN还是很难训练" class="headerlink" title="GAN还是很难训练"></a>GAN还是很难训练</h2><p>G和D必须要齐头并进，否则对应的GAN是完全训练不出来的。网络上有很多对应的生成式对抗网络的代码文件。</p><h2 id="GAN生成文字是最困难的。"><a href="#GAN生成文字是最困难的。" class="headerlink" title="GAN生成文字是最困难的。"></a>GAN生成文字是最困难的。</h2><p>难点在于不能使用梯度下降来优化对应的模型。对应的函数并不能与对应的模型进行匹配，调整参数会有很多相同的结果，结果可能不会变化，根本没有办法算微分。RL硬做，都很难训练。生成式对抗模型很难。</p><p>能不能用监督学习的方法来进行运算，</p><h2 id="GAN的评价"><a href="#GAN的评价" class="headerlink" title="GAN的评价"></a>GAN的评价</h2><p>1.找人直接来看。</p><p>2.人脸侦测的系统，抓到动画人物的人脸的比例</p><p>3.几率的分布，影像分类系统的结果比较集中，对应的生成效果就比较好。</p><p>4.一张老脸进行模式的复制，都一样，没意思。，这样的评价也需要考虑</p><p>5.mode Dropping肤色都变成一样的，降维了。</p><p>6.一堆图片都进入CNN，判断对应的而平均分布，集中，多样性不够</p><p>7FID,计算当成高斯分布之间的距离</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成式对抗网络（GAN）&quot;&gt;&lt;a href=&quot;#生成式对抗网络（GAN）&quot; class=&quot;headerlink&quot; title=&quot;生成式对抗网络（GAN）&quot;&gt;&lt;/a&gt;生成式对抗网络（GAN）&lt;/h1&gt;&lt;p&gt;传统的对应的架构，生成架构&lt;/p&gt;
&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="机器学习" scheme="https://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="生成式对抗网络" scheme="https://example.com/tags/%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成</title>
    <link href="https://example.com/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <id>https://example.com/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</id>
    <published>2025-09-30T02:24:50.875Z</published>
    <updated>2025-10-24T11:55:30.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="本章知识回顾"><a href="#本章知识回顾" class="headerlink" title="本章知识回顾"></a>本章知识回顾</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/1.2.2.png" alt="1.2.2"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/1.2.2.1.png" alt="1.2.2.1"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/1.3.png" alt="1.3"></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>1)计算机由哪几部分组成?以哪部分为中心?计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称中央处理器。</p><p>在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。随着微电子技术的发展，同时计算机需要处理、加工的信息量也与日俱增，大量IO设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已发展为以存储器为中心，使 IO 操作尽可能地绕过 CPU，直接在IO设备和存储器之间完成，以提高系统的整体运行效率。</p><p>2)主频高的 CPU 一定比主频低的 CPU 快吗?为什么?</p><p>衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系,但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标(架构、缓存、指令集、CPU的位数、Cache 大小等)。由于主频并不直接代表运算速度,因此在一定情况下很可能会出现主频较高的 CPU 实际运算速度较低的现象。</p><p>3)翻译程序、汇编程序、编译程序、解释程序有什么差别?各自的特性是什么?<br>见常见问题和易混淆知识点1。</p><p>4)不同级别的语言编写的程序有什么区别?哪种语言编写的程序能被硬件直接执行?</p><p>机器语言和汇编语言与机器指令对应,而高级语言不与指令直接对应,具有较好的可移植性。<br>其中机器语言编写的程序可以被硬件直接执行。</p><h2 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h2><p><strong>1、翻译程序、解释程序、汇编程序、编译程序的区別和联系是什么?</strong></p><p><strong>翻译程序</strong>有两种;一种是<strong>编译程序</strong>，它将高级语言程序一次<strong>全部翻译成目标程序</strong>，只要程序不变，就<strong>无须重新翻译</strong>。另一种是<strong>解释程序</strong>，它将源程序的<strong>一条语言</strong>翻译成对应的<strong>机器目标代码</strong>，并立即执行，然后翻译下一条源程序语言并执行，直至所有源程序语全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</p><p><strong>汇编程序</strong>也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。编译程序与汇编程序的区别;若源语言是诸如C、c、javs等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</p><p><strong>2.什么是透明性?透明是指什么都能看见吗?</strong></p><p>在计算机领域中，站在某类用户的角度，若<strong>感觉不到</strong>某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是<strong>透明的</strong>”。这与日常生活中的“<strong>透明</strong>”概念(公开、看得见)正好相反。例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的;而对于机器语言或汇编语言程序员来说，<strong>指令的格式、</strong>机器结构、数据格式等则不是透明的。在CPU中，<strong>IR、MAR和MDR对各类程序员都是透明的。</strong><br>成的间顾即使是回度的差异</p><p><strong>3、字、字长、机器字长、指令字长、春储字长的区别和联系是什么?</strong></p><p><strong>字长</strong>是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。</p><p><strong>字</strong>和<strong>字长</strong>的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。</p><p>**指令字长:**一个指令字中包含的二进制代码的位数。</p><p>**存储字长:**一个存储单元存储的二进制代码的位数。<br>它们都必须是字节的整数倍。</p><p>指令字长一般取存储字长的<strong>整数倍</strong>，若指令字长等于存储字长的<strong>2倍</strong>，则需要<strong>2个访存周期</strong>来取出一条指令;若指令字长等于存储字长，则取指令周期等于机器周期。</p><p><strong>早期的存储字长一般与指令字长、字长相等</strong>，因此访问一次主存储器便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是<strong>字节的整数倍。</strong></p><p><strong>4、计算机体系结构和计算机组成的区别和联系是什么?</strong><br>计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、<br>数据类型、存储器寻址技术等，大都属于抽象的属性。,分算机组成是指如何实现计算机体系结构所体现的属性，它包含许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题、因此，当两合机器的指令系统相同时，只能认为它们具有相同的格局，至于这两合机器如何实现其指令，则完全可以不同、即可以认为它们的组成方式是不同的销物、三台机器是否具备乘法指令是一个结构的问题，但安现法指采什么式则是一个组成的问题。许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。</p><p><strong>5.基准程序执行得越快说明机器的性能越好吗?一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在度的差异，因此运行结果并不能完全说明问题。</strong></p>]]></content>
    
    
    <summary type="html">计算机组成</summary>
    
    
    
    <category term="计算机组成" scheme="https://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="计算机组成" scheme="https://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="https://example.com/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <id>https://example.com/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</id>
    <published>2025-09-30T02:24:50.868Z</published>
    <updated>2025-10-24T11:57:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络体系结构"><a href="#第一章-计算机网络体系结构" class="headerlink" title="第一章 计算机网络体系结构"></a>第一章 计算机网络体系结构</h1><h2 id="1-1计算机网络概述"><a href="#1-1计算机网络概述" class="headerlink" title="1.1计算机网络概述"></a>1.1计算机网络概述</h2><h3 id="1-1-1计算机网络的概念"><a href="#1-1-1计算机网络的概念" class="headerlink" title="1.1.1计算机网络的概念"></a>1.1.1计算机网络的概念</h3><table><thead><tr><th></th><th></th><th>由若干节结点（node）和链接这些节点的链路（link）组成。结点可以是计算机、集线器、交换机、路由器等</th></tr></thead><tbody><tr><td></td><td>计算机网络</td><td>主要功能：数据通信（信息共享）、资源共享</td></tr><tr><td></td><td>|路由器连接|</td><td></td></tr><tr><td></td><td>互连网（internet）</td><td>多个计算机网络通过路由器互相连接而成</td></tr><tr><td>计算机网络的概念</td><td>|世界上最大规模的互连网|</td><td>可使用任何通信协议</td></tr><tr><td></td><td>互联网（Internet）</td><td>或译为因特网。特指全世界最大的计算机网络，由各大ISP和国际机构组建</td></tr><tr><td></td><td></td><td>使用tcp&#x2F;ip协议族作为通信规则</td></tr><tr><td></td><td></td><td>ISP（Internet Service Provider），互联网服务提供商</td></tr><tr><td></td><td>其他拓展</td><td>集线器、交换机用于链接统一网络内的不同节点；路由器用于连接不同的网络</td></tr><tr><td></td><td></td><td>家用路由器&#x3D;路由器+交换机+其他功能</td></tr></tbody></table><h3 id="1-1-2计算机网络的组成与功能"><a href="#1-1-2计算机网络的组成与功能" class="headerlink" title="1.1.2计算机网络的组成与功能"></a>1.1.2计算机网络的组成与功能</h3><table><thead><tr><th></th><th></th><th></th><th><strong>主机，即端系统（end system）–如电脑手机物联网设备</strong></th><th><strong>内部安装网卡</strong></th></tr></thead><tbody><tr><td></td><td></td><td><strong>硬件</strong></td><td><strong>通信设备–如集线器，交换机，路由器</strong></td><td><strong>|将主机数据发到网络上</strong></td></tr><tr><td></td><td></td><td></td><td><strong>通信链路–如网线，光纤，同轴电缆</strong></td><td><strong>|接受来自网络的数据</strong></td></tr><tr><td></td><td><strong>从组成部分看</strong></td><td><strong>软件</strong></td><td><strong>方便用户使用，实现资源共享。如email客户端，聊天软件。网盘软件</strong></td><td><strong>|</strong></td></tr><tr><td></td><td></td><td></td><td><strong>规定计算机网络中的通信规则</strong></td><td><strong>|</strong></td></tr><tr><td></td><td></td><td><strong>协议</strong></td><td><strong>由硬件、软件共同实现，如：网络适配器+软件 实现网络通信协议</strong></td><td><strong>&lt;–|</strong></td></tr><tr><td></td><td></td><td></td><td><strong>工作方式：直接为用户服务（通信，资源共享）</strong></td><td></td></tr><tr><td></td><td></td><td><strong>边缘部分</strong></td><td><strong>主要有链接到互联网上的主机及其软件构成</strong></td><td></td></tr><tr><td><strong>计算机网络的组成</strong></td><td><strong>从工作方式看</strong></td><td></td><td><strong>工作方式：为边缘部分提供服务（连通性，交换服务）</strong></td><td></td></tr><tr><td></td><td></td><td><strong>核心部分</strong></td><td><strong>由大量网络和连接这些网络的路由器组成</strong></td><td></td></tr><tr><td></td><td></td><td></td><td><strong>计算机网络中运行应用程序，向用户提供可共享的硬件，软件和信息资源的部分</strong></td><td></td></tr><tr><td></td><td></td><td><strong>资源子网</strong></td><td><strong>主要由连接到互联网上的主机组成</strong></td><td></td></tr><tr><td></td><td><strong>从逻辑功能看</strong></td><td></td><td><strong>计算机网络中负责计算机间信息传输的部分。即把计算机和其他用户装置互联在一起的所有通信设备和介质的总称</strong></td><td></td></tr><tr><td></td><td></td><td><strong>通信子网</strong></td><td><strong>主要由 通信链路+通信设备+协议构成</strong></td><td></td></tr><tr><td></td><td></td><td></td><td><strong>注：主机内部实现信息传输的网络适配器&#x2F;底层协议 属于通信子网的范畴</strong></td><td></td></tr></tbody></table><table><thead><tr><th></th><th><strong>数据通信</strong></th><th><strong>实现计算机之间数据传输。是最基本最重要的功能</strong></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td><strong>如：智能音箱 请求服务器处理</strong></td></tr><tr><td></td><td><strong>资源共享</strong></td><td><strong>硬件、软件、数据资源</strong></td><td><strong>如：应用商店</strong></td></tr><tr><td><strong>计算机网络的功能</strong></td><td></td><td></td><td><strong>如：分享视频</strong></td></tr><tr><td></td><td><strong>分布式处理</strong></td><td><strong>将某个复杂任务分配给网络中多台计算机处理</strong></td><td><strong>如：大矩阵计算，mapreduce</strong></td></tr><tr><td></td><td><strong>提高可靠性</strong></td><td><strong>网络中各台计算机互为替代机</strong></td><td><strong>如：某网盘服务器集群网络，数据冗余备份</strong></td></tr><tr><td></td><td><strong>负载均衡</strong></td><td><strong>网络中各台计算机共同分担繁重工作</strong></td><td><strong>如：某游戏用多台服务器均衡处理玩家请求</strong></td></tr><tr><td></td><td><strong>其他</strong></td><td><strong>满足社会需求，生活需求</strong></td><td><strong>如远程办公，远程教育，娱乐等</strong></td></tr></tbody></table><h3 id="1-1-3三种交换方式"><a href="#1-1-3三种交换方式" class="headerlink" title="1.1.3三种交换方式"></a>1.1.3三种交换方式</h3><h4 id="1-1-3-1三种交换方式的优缺点"><a href="#1-1-3-1三种交换方式的优缺点" class="headerlink" title="1.1.3.1三种交换方式的优缺点"></a>1.1.3.1三种交换方式的优缺点</h4><p><strong>电路交换基本原理</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916103009214.png" alt="image-20240916103009214"></p><p><strong>电路交换的优点</strong>：</p><p>通信前从主叫端到被叫端建立一条专用的物理通路，在通信的全部时间内，两个用户始终占用端到端的线路资源。数据直送，传输速率高（电路交换更适用于（低频次。大量的传输数据）</p><p><strong>若应用于计算机网络有何缺点：</strong></p><p>建立释放连接需要额外的时间开销</p><p>线路被通信双方独占，利用率低</p><p>线路分配的灵活性差</p><p>交换节点不支持“差错控制”（无法发现传输过程中发生的数据错误）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机之间的数据往往是“突发式”传输，即往往会高频次，少量地传输数据。</span><br></pre></td></tr></table></figure><p><strong>报文交换的过程</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916104405988.png" alt="image-20240916104405988"></p><p><strong>报文交换的优点</strong></p><p>通信前无需建立连接</p><p>数据以“报文”为单位被交换节点间“存储转发：，通信线路可以灵活分配</p><p>在通信时间内，两个用户无需独占一整条物理线路。相比于电路交换，线路利用率高</p><p>交换节点中支持“差错控制”（通过校验技术）</p><p><strong>报文交换的缺点</strong></p><p>报文不定长，不方便存储转发管理</p><p>长报文的存储转发时间开销大、缓存开销大</p><p>长报文容易出错，重传代价高</p><p><strong>分组交换的原理：</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916104851576.png" alt="image-20240916104851576"></p><p><strong>分组交换的优点：</strong></p><p>通信前无需建立连接</p><p>数据以“分组”为单位被交换节点间“存储转发”，通信线路可以灵活分配</p><p>在通信时间内两个用户无需独占一条物理线路。相比于电路交换，线路利用率高</p><p>交换节点支持“差错控制”（通过校验技术）</p><p>相比于报文交换，分组交换改进了如下问题：</p><p>分组定长，方便存储转发管理</p><p>分组的存储转发时间开销小，缓存开销小</p><p>分组不易出错，重传代价低</p><p><strong>分组交换的缺点</strong></p><p>相比于报文交换，控制信息占比增加</p><p>想比于电路交换，依然存在存储转发时延</p><p>报文被拆分成多个分组，传输过程中可能出现失序，丢失等问题，增加处理的复杂<strong>度</strong></p><p><strong>虚电路交换技术</strong>原理</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916105651346.png" alt="image-20240916105651346"></p><h4 id="1-1-3-2三种交换方式的性能分析"><a href="#1-1-3-2三种交换方式的性能分析" class="headerlink" title="1.1.3.2三种交换方式的性能分析"></a>1.1.3.2三种交换方式的性能分<strong>析</strong></h4><p><strong>电路交换性能分析</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113317203.png" alt="image-20240916113317203"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113341828.png" alt="image-20240916113341828"></p><p><strong>报文交换性能分析</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113421619.png" alt="image-20240916113421619"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113436223.png" alt="image-20240916113436223"></p><p><strong>分组交换性能分析</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113522702.png" alt="image-20240916113522702"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113541364.png" alt="image-20240916113541364"></p><p><strong>三种交换方式的性能对比</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916113618478.png" alt="image-20240916113618478"></p><p><strong>三种交换方式的表格对比</strong></p><table><thead><tr><th></th><th>电路交换</th><th>报文交换</th><th>分组交换</th></tr></thead><tbody><tr><td>完成传输所需时间</td><td>最少（排除建立&#x2F;释放连接耗时）</td><td>最多</td><td>较少</td></tr><tr><td>存储转发时延</td><td>无</td><td>较高</td><td>较低</td></tr><tr><td>通信前是否需要建立连接？</td><td>是</td><td>否</td><td>否</td></tr><tr><td>缓存开销</td><td>无</td><td>高</td><td>低</td></tr><tr><td>是否支持差错控制？</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>报文数据有序到达？</td><td>是</td><td>是</td><td>否</td></tr><tr><td>是否需要额外的控制信息</td><td>否</td><td>是</td><td>是（控制信息占比最大）</td></tr><tr><td>线路分配灵活性</td><td>不灵活</td><td>灵活</td><td>非常灵活</td></tr><tr><td>线路利用率</td><td>低</td><td>高</td><td>非常高</td></tr></tbody></table><h3 id="1-1-4计算机网络的分类"><a href="#1-1-4计算机网络的分类" class="headerlink" title="1.1.4计算机网络的分类"></a>1.1.4计算机网络的分类</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240916121413817.png" alt="image-20240916121413817"></p><h3 id="1-1-5计算机网络的性能指标"><a href="#1-1-5计算机网络的性能指标" class="headerlink" title="1.1.5计算机网络的性能指标"></a>1.1.5计算机网络的性能指标</h3><p><strong>速率</strong>：又名：数据率，比特率，<em><strong>数据传输速率</strong></em></p><p><strong>带宽</strong>：表示某信道允许通过的<em><strong>最高数据率</strong></em></p><p><strong>吞吐量</strong>：描述某个网络（或节点、信道）的在单位时间内通过的实际数据量（<em><strong>实际的综合数据率，包括接受到的和发送出去的</strong></em>）</p><p>上述的三种性能指标的单位为bit&#x2F;s&#x3D;b&#x2F;s&#x3D;bps</p><p>bps,<strong>k</strong>bps,<strong>M</strong>bps,<strong>T</strong>bps(10^3递增)</p><p><em><strong>注意：</strong></em>1B&#x3D;8b</p><p><strong>带宽（另一种含义）</strong>：表示某信道允许通过的<em><strong>信道频带范围</strong></em>，单位<em><strong>Hz</strong></em></p><p><strong>时延</strong>：指数据一端传送到另一端的所需时间</p><p><strong>总时延</strong>&#x3D;<strong>发送时延</strong>+<strong>传播时延</strong>+<em><strong>处理时延+排队时延</strong></em></p><p><strong>发送时延：</strong>也称传输时延。节点将分组的所有比特推向链路所需要的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需要的时间</p><p>​                                                            <strong>发送时延</strong>&#x3D;<strong>分组长度</strong>&#x2F;<strong>发送速率</strong></p><p><strong>传播时延：</strong>电磁波在信道（传输介质）中传播一定的距离所花的时间，即一个比特从链路的一端传送到另一端所需的时间</p><p>​                                                           <strong>传输时延</strong>&#x3D;<strong>信道长度</strong>&#x2F;<strong>电磁波在信道上的传播速率</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">区分传输时延和传播时延。传输时延是路由器将分组推出所需的时间，是分组长度和链路传输速率的函数。传播时延是一个比特从一台路由器传播至另一个路由器所需的时间，是两台路由器之间距离的函数，而与分组长度或链路传播速率无关</span><br></pre></td></tr></table></figure><p><strong>处理时延</strong>：数据在交换节点为存储转发而进行的一些必要处理所需的时间。例如，分析分组的首部，从分组中提取数据、差错检验或查找合适的路由等。</p><p><strong>排队时延</strong>：分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发。这就产生了排队时延。</p><p><strong>时延带宽积：</strong>单向传播时延*带宽</p><p>**往返时延RTT:**表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间。</p><p><strong>信道利用率：</strong>某个信道有百分之多少的时间是有数据通过的</p><p>利用率低会浪费带宽资源，利用率太高可能导致网络拥塞</p><h3 id="1-1-6习题"><a href="#1-1-6习题" class="headerlink" title="1.1.6习题"></a>1.1.6习题</h3><h4 id="二-综合应用题-纯文字部分"><a href="#二-综合应用题-纯文字部分" class="headerlink" title="二.综合应用题(纯文字部分)"></a>二.综合应用题(纯文字部分)</h4><h4 id="03"><a href="#03" class="headerlink" title="03."></a>03.</h4><p><strong>在两台计算机之间传输一个文件有两种可行的确认策略。第一种策略把文件截成分组，接收方逐个确认分组，但就整体而言，文件没有得到确认。第二种策略不确认单个分组，但当文件全部收到后，对整个文件予以确认。讨论这两种方式的优缺点。</strong></p><p>若网络容易丢失分组，则对每个分组逐一进行确认较好,此时仅重传丢失的分组。另一方面若网络高度可靠，则在不发生差错的情况下，仅在整个文件传送的结尾发送一次确认，以减少确认次数，进而节省带宽。不过，即使只有单个分组丢失，也要重传整个文件。</p><h2 id="1-2计算机网络体系结构与参考模型"><a href="#1-2计算机网络体系结构与参考模型" class="headerlink" title="1.2计算机网络体系结构与参考模型"></a>1.2计算机网络体系结构与参考模型</h2><h3 id="1-2-1-计算机网络分层结构"><a href="#1-2-1-计算机网络分层结构" class="headerlink" title="1.2.1 计算机网络分层结构"></a>1.2.1 计算机网络分层结构</h3><ul><li><p><strong>网络的体系结构</strong></p><p><strong>定义</strong>:计算机网络各层及其协议的集合称为网络的体系结构。</p><p>“<strong>体系结构</strong>”精确定义了网络的层次划分、各层功能、各层协议等，不涉及具体实现。</p><p><strong>三种常见的网络体系结构</strong></p><p>OSI参考模型，7层（法律标准）</p><p>TCP&#x2F;IP模型，4层（事实标准）</p><p>五层模型，5层（教学用标准）</p></li><li><p><strong>实体、协议、接口、服务</strong></p><p><strong>实体：</strong>第n层中的活动元素（软件+硬件）称为第n层实体</p><p><strong>协议：</strong>是控制对等实体之间进行通信的规则的集合，<em><strong>是水平的</strong></em></p><p><strong>服务：</strong>是指下层为紧邻的上层提供的功能调用，<em><strong>是垂直的</strong></em>    服务的分类再试不讨论</p><p><strong>接口：</strong>又称为服务访问点（SAP），上一层实体通过“接口”请求下一层实体的服务</p></li><li><p><strong>PDU、SDU、PCI</strong></p><p>PDU（协议控制单元），SDU（服务数据单元），PCI（协议控制信息）</p><p>n-SDU+n-PCI&#x3D;n-PDU&#x3D;(n-1)-SDU</p><p><strong>翻译成人话就是：</strong>当层的服务数据单元，加上当层的协议控制信息就是当层的协议控制单元，而当层的协议控制单元就代表着下一层的服务数据单元，等待加入下一层的协议控制信息。</p></li><li><p><strong>三要素</strong></p><p>语法，语义，同步。</p><p><strong>语法：</strong>数据与控制信息的格式</p><p><strong>语义：</strong>即需要发出何种控制信息、完成何种动作及做出何种应答（成功或失败）</p><p><strong>同步（或时序）：</strong>执行各种操作的条件、时序关系等。</p></li></ul><h3 id="1-2-2-ISO-x2F-OSI参考模型和TCP-x2F-IP模型"><a href="#1-2-2-ISO-x2F-OSI参考模型和TCP-x2F-IP模型" class="headerlink" title="1.2.2 ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型"></a>1.2.2 ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型</h3><h4 id="1-2-2-1OSI参考模型"><a href="#1-2-2-1OSI参考模型" class="headerlink" title="1.2.2.1OSI参考模型"></a>1.2.2.1OSI参考模型</h4><p>国际标准化组织（ISO）提出的网络体系结构模型称为<em><strong>开放系统互连参考模型</strong></em>（OSI&#x2F;RM）,通常简称为<em><strong>OSI参考模型</strong></em>。共有七层对应的结构表格如下</p><table><thead><tr><th>口诀</th><th>OSI参考模型</th><th>任务</th><th>功能</th><th>各层传输单位</th><th>协议</th></tr></thead><tbody><tr><td><em><strong>用</strong></em></td><td>#7 应<em><strong>用</strong></em>层</td><td>实现特定网络应用</td><td>略（因为功能的种类太多了）</td><td>报文</td><td>FTP,HTTP,DNS,SMTP</td></tr><tr><td><em><strong>使</strong></em></td><td>#6 表<em><strong>示</strong></em>层</td><td>解决不同主机上信息表示不一致的问题</td><td>数据格式转换</td><td></td><td></td></tr><tr><td><em><strong>会</strong></em></td><td>#5 <em><strong>会</strong></em>话层</td><td>管理进程间会话</td><td>会话管理</td><td></td><td></td></tr><tr><td><em><strong>叔</strong></em></td><td>#4传<em><strong>输</strong></em>层</td><td>实现端到端（进程到进程）通信</td><td>复用和分用、差错控制、流量控制、连接管理、可靠传输管理、拥塞控制</td><td>报文段</td><td>TCP,UDP</td></tr><tr><td><em><strong>网</strong></em></td><td>#3 <em><strong>网</strong></em>络层</td><td>把分组从源节点转发到目的节点</td><td>路由选择、分组转发、拥塞控制、网际互联、差错控制、流量控制、连接管理、可靠传输管理</td><td>数据报（分组）</td><td>IP,ICMP,RIP,OSPF,BGP,IGMP</td></tr><tr><td><em><strong>联</strong></em></td><td>#2 数据<em><strong>链</strong></em>路层</td><td>确保相邻节点之间的链路逻辑上无差错</td><td><strong>差错控制、流量控制、寻址、成帧</strong></td><td>帧</td><td>PPP,ARP,RARP,MTU</td></tr><tr><td><em><strong>物</strong></em></td><td>#1<em><strong>物</strong></em>理层</td><td>实现相邻节点之间的比特的传输</td><td>需定义电路接口参数、信号的含义、电气特性等</td><td>比特</td><td>IEEE 802.1A,IEEE 802.2</td></tr></tbody></table><h4 id="1-2-2-2TCP-x2F-IP模型"><a href="#1-2-2-2TCP-x2F-IP模型" class="headerlink" title="1.2.2.2TCP&#x2F;IP模型"></a>1.2.2.2TCP&#x2F;IP模型</h4><table><thead><tr><th>口诀</th><th>TCP&#x2F;IP模型</th><th>任务</th><th>功能</th></tr></thead><tbody><tr><td>用</td><td>应用层</td><td>实现特定网络应用</td><td>略</td></tr><tr><td>叔</td><td>传输层</td><td>实现端到端（进程到进程）通信</td><td>复用和分用、差错控制、流量控制、连接管理。可靠传输管理</td></tr><tr><td>网</td><td>网络层</td><td>把分组从源节点转发到目的节点</td><td>路由选择、分组转发、拥塞控制、网际互联。不用考虑<em><strong>（差错控制、流量控制、连接管理、可靠传输管理）</strong></em></td></tr><tr><td>接</td><td>网络接口层</td><td><em><strong>实现相邻节点之间的数据传输（为网络层传输“分组”）</strong></em></td><td><em><strong>无具体规定</strong></em></td></tr></tbody></table><p><strong>OSI参考模型</strong>与<strong>TCP&#x2F;IP模型</strong>在应用层与网络接口层的区别</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240917122155005.png" alt="image-20240917122155005"></p><p><strong>OSI参考模型</strong>与<strong>TCP&#x2F;IP模型</strong>在传输层与网络层的区别</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240917122405985.png" alt="image-20240917122405985"></p><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-通信基础"><a href="#2-1-通信基础" class="headerlink" title="2.1 通信基础"></a>2.1 通信基础</h2><h3 id="2-1-1通信基础的基本概念"><a href="#2-1-1通信基础的基本概念" class="headerlink" title="2.1.1通信基础的基本概念"></a>2.1.1通信基础的基本概念</h3><p><strong>信源：</strong>信号来源，数据的发送方</p><p><strong>信宿：</strong>信号的“归宿”，数据的接收方</p><p><strong>信号：</strong>是数据的载体</p><p>​             <strong>数字信号：</strong>值是离散的</p><p>​              <strong>模拟信号：</strong>值是连续的</p><p><strong>信道：</strong>即信号的通道，分别对应模拟信道和数字信道</p><p><strong>码元：</strong>一个“信号周期”内可能出现几种信号？每一类信号就是一个码元。“码元宽度”：指的是一个“信号周期”的长度</p><p>若一个周期可能出现K种信号，就是K进制码元—-<strong>一码元携带log2(K)n&#x3D;bit</strong></p><p><strong>速率：</strong></p><p><strong>波特率：</strong>每秒传输几个码元。单位：码元&#x2F;秒，或<strong>波特（Baud）</strong></p><p><strong>比特率：</strong>每秒传输几个比特。单位：bit&#x2F;s,或b&#x2F;s,bps</p><p><strong>内在联系：</strong>一个码元携带几个比特</p><h3 id="2-1-2信道的极限容量"><a href="#2-1-2信道的极限容量" class="headerlink" title="2.1.2信道的极限容量"></a>2.1.2信道的极限容量</h3><p><strong>带宽：</strong>信道允许通过的信号频带范围。单位Hz</p><p><strong>噪声:</strong>  噪声会对信号的传播产生干扰，会影响信道的数据传输效果</p><p><strong>奈奎斯特定理：</strong></p><p><strong>无噪声</strong>情况下的信道的<strong>极限波特率</strong>&#x3D;2W（单位：波特，即码元&#x2F;秒）</p><p><strong>无噪声</strong>情况下信道的<strong>极限比特率</strong>&#x3D;<br>$$<br>2Wlog_2(K)（单位：bps)<br>$$<br>若一个码元有K种状态</p><p><strong>香农定理：</strong></p><p><strong>信噪比S&#x2F;N：</strong></p><p><strong>分贝记法</strong><br>$$<br>10lg(S&#x2F;N)(单位：dB)<br>$$<br>单位dB</p><p><strong>无单位记法</strong><br>$$<br>S&#x2F;N&#x3D;信号功率&#x2F;噪声功率<br>$$<br>有噪声情况下的信道的<strong>极限比特率</strong>&#x3D;<br>$$<br>Wlog_2(1+S&#x2F;N)(单位：b&#x2F;s)<br>$$<br>其中采用无单位记法</p><h3 id="2-1-3编码与调制"><a href="#2-1-3编码与调制" class="headerlink" title="2.1.3编码与调制"></a>2.1.3编码与调制</h3><p><strong>概念：</strong></p><p><strong>编码：</strong>二进制数据—&gt;数字信号，逆过程为“解码”</p><p><strong>调制：</strong>二进制数据—&gt;模拟信号，逆过程为“解调”</p><h4 id="2-1-3-1编码技术"><a href="#2-1-3-1编码技术" class="headerlink" title="2.1.3.1编码技术"></a>2.1.3.1编码技术</h4><p><strong>不归零编码（NRZ）：</strong>低0高1中不变。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918102708868.png" alt="image-20240918102708868"></p><p>**归零编码（RZ):**低0高1，中归零。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918102843971.png" alt="image-20240918102843971"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918102902470.png" alt="image-20240918102902470"></p><p><strong>反向非归零编码（NRZI）：</strong>跳0不跳1看起点，中不变</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103429195.png" alt="image-20240918103429195"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103503263.png" alt="image-20240918103503263"></p><p><strong>曼彻斯特编码：</strong>跳0反跳1看中间，中必变</p><p>①上0下1（考研常用标准）②下0上1</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103759010.png" alt="image-20240918103759010"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918103752339.png" alt="image-20240918103752339"></p><p><strong>差分曼彻斯特编码：</strong>跳0不跳1看起点，中必变</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918104000451.png" alt="image-20240918104000451"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918104021251.png" alt="image-20240918104021251"></p><p>各种编码的特点：</p><p><strong>注：以太网默认使用曼彻斯特编码</strong></p><table><thead><tr><th>优缺点</th><th>不归零（NRZ)</th><th>归零（NR）</th><th>反向非归零（NRZI）</th><th>曼彻斯特</th><th>差分曼彻斯特</th></tr></thead><tbody><tr><td>自同步能力（时钟）</td><td>无</td><td>有</td><td>若能增加冗余位可实现自同步</td><td>有</td><td>有</td></tr><tr><td>浪费带宽</td><td>无</td><td>浪费</td><td>不太浪费</td><td>浪费</td><td>浪费</td></tr><tr><td>抗干扰能力</td><td>弱</td><td>弱</td><td>弱</td><td>强</td><td>强</td></tr></tbody></table><h4 id="2-1-3-2调制技术"><a href="#2-1-3-2调制技术" class="headerlink" title="2.1.3.2调制技术"></a>2.1.3.2调制技术</h4><ul><li><strong>调幅（AM）</strong>或<strong>幅移键控（ASK）</strong>：若信号波有K种振幅，则1码元&#x3D;log2K bit</li><li><strong>调频（FM）</strong>或<strong>频移键控（FSK）</strong>:     若信号波有K种频率，则1码元&#x3D;log2K bit</li><li><strong>调相（PM）</strong>或<strong>相移键控（PSK）</strong>：若信号波有K种相位，则1码元&#x3D;log2K bit</li></ul><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240918104831646.png" alt="image-20240918104831646"></p><p><strong>正交幅度调制（QAM）</strong></p><p><strong>AM</strong>与<strong>PM</strong>结合，形成叠加信号，若有m种振幅，n种相位，则<strong>1码元&#x3D;log2mn bit</strong></p><p><strong>补充：</strong>QAM16的含义是采用QAM调制技术，有16种码元。</p><h2 id="2-2传输介质"><a href="#2-2传输介质" class="headerlink" title="2.2传输介质"></a>2.2传输介质</h2><p><strong>双绞线：</strong>两根导线相互绞合而成。有屏蔽层称为<strong>屏蔽双绞线（STP）</strong>，没有屏蔽层称为<strong>非屏蔽双绞线（UTP）</strong></p><p><strong>同轴电缆：</strong>内导体（用于传输信号）+外导体屏蔽层（用于抗电磁干扰）</p><p><strong>光纤：</strong>纤芯（高折射率）+包层（低折射率）。利用光的全反射特性，在纤芯内传输光脉冲信号</p><p>分类：</p><p><strong>单模光纤：</strong>只有一条光线在一根光纤中传输，适合长距离传输，信号传输损耗小。</p><p><strong>多模光纤：</strong>多条光线在一根光纤中传输，适合近距离传输，远距离传输光信号容易失真</p><p><em><strong>以上的传输介质都是导向性介质，从上至下，抗干扰能力依次增强，信号传输损耗依次降低</strong></em></p><p><strong>无线传输介质：</strong></p><p>本质都是<strong>电磁波</strong>，波长不同而已（长波-&gt;短波），波长与信号频率成反比</p><p>短波信号<strong>指向性强，</strong>数据<strong>传输能力强；</strong>长波信号<strong>绕射性好、指向性弱</strong></p><p><em><strong>注：卫星通信属于短波（或微波）通信</strong></em></p><p>物理层接口的特性</p><p><strong>机械特性：</strong>指明接口所用的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</p><p><strong>电气特性：</strong>指明在接口电缆的各条线上出现的电压的范围。传输速率。距离限制等</p><p><strong>功能特性：</strong>指明某条线上出现的某一电平的电压意义</p><p><strong>过程特性（规程特性）</strong>——指明对于不同功能的各种可能事件的出现顺序。</p><h2 id="2-3物理层设备"><a href="#2-3物理层设备" class="headerlink" title="2.3物理层设备"></a>2.3物理层设备</h2><p><strong>中继器：</strong></p><p>中继器只有两个端口。通过一个端口接收信号，将失真信号整形再生，并转发至另一端口（会产生一些时延）</p><p>仅支持半双工通信（两端连接的节点不可同时发送数据，会导致“冲突”</p><p>中继器两个端口对应两个“网段”</p><p><strong>集线器（Hub）</strong></p><p>本质上是多端口中继器。集线器将其中一个端口接收到的信号整形再生后，转发到所有其他端口。</p><p>各端口连接的节点不可同时发送数据，会导致“冲突”</p><p>集线器的N个端口对应N个“网段”，各网段属于同一个“冲突域”（同一冲突域的主机同时发送信号会导致“冲突”，因此需要“信道争用”。</p><p>一些特性</p><p><strong>集线器、中继器不能无限串联</strong></p><p><strong>集线器连接的网络，物理上是星型拓扑，逻辑上是总线型拓扑</strong></p><p><strong>集线器连接的各网段“共享带宽”</strong></p><p><strong>集线器可以连接不同的传输介质，因此两个网段的物理层接口特性可以不同(这就意味着集线器连接的网段，“物理层协议”可以不同)</strong></p><p><strong>集线器如果连接了速率不同的网段，会导致所有网段“速率向下兼容”</strong></p><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1数据链路层的功能"><a href="#3-1数据链路层的功能" class="headerlink" title="3.1数据链路层的功能"></a>3.1数据链路层的功能</h2><p><strong>封装成帧（组帧）</strong></p><p><strong>帧定界：</strong>如何让接收方能够确定帧的界限</p><p><strong>透明传输：</strong>接收方链路层要能从收到的帧内恢复原始的SDU，让网络层“感受不到”将分组封装成帧的过程。</p><p><strong>差错控制</strong>：发现并解决一个帧内部的“位错”</p><p>解决方案一：接收方发现比特错后<strong>丢弃帧</strong>，发送方<strong>重传帧</strong>（仅需采用 检错编码）</p><p>解决方法二：<strong>由接收方发现并纠正比特错误</strong>（需采用纠错编码）</p><p><strong>可靠传输：</strong>发现并解决“<strong>帧错</strong>”</p><p><strong>帧丢失：</strong>eg:发送帧①②③④，收到帧①②④</p><p><strong>帧重复：</strong>eg:发送帧①②③④，收到帧①②③③④</p><p><strong>帧失序：</strong>eg:发送帧①②③④，收到帧①③②④</p><p><strong>流量控制：</strong>控制发送方发送帧的速度别太快，让接收方来得及“接受”</p><p><strong>介质访问控制：</strong></p><p>“<strong>广播信道</strong>”需要实现此功能。广播信道在逻辑上是总线型拓扑，<strong>多个节点需争抢传输介质的使用权</strong></p><p>“<strong>点对点信道</strong>”通常不需要实现此功能。点对点信道通常意味着<strong>两个节点之间有专属的传输介质，不用抢。</strong></p><h2 id="3-2组帧（封装成帧）"><a href="#3-2组帧（封装成帧）" class="headerlink" title="3.2组帧（封装成帧）"></a>3.2组帧（封装成帧）</h2><p><strong>主要问题：</strong></p><p><strong>帧定界：</strong>如何让接收方能够确定帧的界限</p><p><strong>透明传输：</strong>接收方要能够去除“帧定界”的附加信息，把帧“恢复原貌”</p><p><strong>字符计数法：</strong></p><p>在每个帧开头，用一个定长的计数字段表示帧长</p><p><strong>注意</strong>：<strong>帧长&#x3D;计数字段长度+帧的数据部分长度</strong></p><p><strong>最大缺点：</strong>任何一个计数字段出错，都会导致后续所有帧无法定界</p><p><strong>字节填充法：</strong></p><p><strong>特殊字符：</strong>标记帧开头的字符SOH；标志帧结尾的字符EOT</p><p><strong>转义字符：</strong>ESC</p><p>如果帧的数据部分包含“<strong>特殊字符</strong>”，则发送方需要在这些“<strong>特殊字符</strong>”前填充“<strong>转义字符ESC</strong>”（<strong>接收方要做逆处理</strong>）</p><p><strong>零比特传输法：</strong></p><p>用特殊的比特串01111110标记帧开始、帧结尾</p><p>发送方需要对帧的数据部分进行处理，每当遇到了连续5个1，就填充一个0</p><p>接收方需要对帧的数据部分进行逆处理，每当遇到连续5个1，就删掉后面的0</p><p><strong>HDLC协议、PPP协议使用此方法</strong></p><p><strong>违规编码法：</strong></p><p>使用“<strong>违规信号</strong>”，表示帧的开头、结尾（这种方法需要物理层配合）</p><p>如：采用<strong>曼彻斯特编码</strong>时，使用“<strong>中间不跳变</strong>”作为“<strong>违规信号</strong>”，标记帧的开头、结尾。</p><h2 id="3-3差错控制"><a href="#3-3差错控制" class="headerlink" title="3.3差错控制"></a>3.3差错控制</h2><h3 id="3-3-1检错编码"><a href="#3-3-1检错编码" class="headerlink" title="3.3.1检错编码"></a>3.3.1检错编码</h3><h4 id="3-3-1-1奇偶校验"><a href="#3-3-1-1奇偶校验" class="headerlink" title="3.3.1.1奇偶校验"></a>3.3.1.1奇偶校验</h4><p><strong>概念：</strong></p><p><strong>信息位（有效数据）：</strong>指的是帧的“数据部分”</p><p><strong>校验位（冗余位）：</strong>即为了给帧的“数据部分”检错&#x2F;纠错而附加的一些冗余比特。</p><p><strong>校验原理</strong></p><p>在信息位的首部或尾部添加一个校验位</p><p>奇校验：整个校验码（信息位和校验位）中的“1”的个数为奇数</p><p>偶校验：整个校验码（信息位和校验位）中的“1”的个数为偶数</p><p>奇偶校验码仅<strong>能检测出奇数位错误，无法检测出偶数位错误，无纠错能力。</strong></p><p><strong>异或运算（模2加）</strong></p><p>两个比特进行异或运算，当二者“相异”时计算结果为1</p><p>将“偶校验”的信息位、校验位全部异或，若结果为0说明没有错误</p><h4 id="3-3-1-1循环冗余校验码"><a href="#3-3-1-1循环冗余校验码" class="headerlink" title="3.3.1.1循环冗余校验码"></a>3.3.1.1循环冗余校验码</h4><p><strong>构造：</strong></p><p>由生成多项式确定“除数”。若生成多项式中x的最高次为R，则“除数”有R+1位</p><p>K个信息位+R个0，作为“被除数”</p><p>被除数、除数进行“模二除”，的R位余数</p><p>K个信息位+R位余数&#x3D;CRC码</p><p><strong>校验：</strong></p><p>收到K+R位数据，与生成多项式模二除，计算R位余数</p><p>余数为0，说明无错误</p><p>余数非0，代表出错</p><p><strong>检错、纠错能力</strong></p><p>1.可检测出所有奇数个错误</p><p>2.可检测出所有双比特的错误</p><p>3.可检测出所有小于等于校验位长度的连续错误</p><p>4.若选择合适的生成多项式，且2^R&gt;&#x3D;K+R+1,则可纠正单比特错误</p><h3 id="3-3-2纠错编码"><a href="#3-3-2纠错编码" class="headerlink" title="3.3.2纠错编码"></a>3.3.2纠错编码</h3><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><p><strong>基本思想：</strong>分组偶校验，多个校验位可反映出错位置</p><p><strong>求解步骤：</strong></p><p>确定校验位个数（k个校验位，n个信息位）<br>$$<br>2^k&gt;&#x3D;n+k+1<br>$$<br><strong>确定校验位分布：</strong></p><p>P1,P2,P3..分别在1,2,4,8,16…</p><p>空出来其他位置依次填入信息位</p><p><strong>求校验位：</strong></p><p>将信息位的位置序号用k位二进制数表示出来</p><p>校验位Pi与位置序号第i位为1的信息位归为同一组，进行偶校验</p><p><strong>纠错：</strong></p><p>对P1,P2,P3..所属个分组进行异或（相当于分组偶校验）求得S1,S2,S3</p><p>S3 S2 S1&#x3D;000 说明无错误</p><p>S3 S2 S1≠000,则其值反映出错位置</p><p><strong>补充</strong></p><p>海明码有1位纠错，2位检错能力</p><p>为了区分1位错和2位错，还需添加“全校验位”对整体进行偶校验</p><p><strong>注意：有的题目位置编号可能是从小到大的，但处理方法雷同。</strong></p><h2 id="3-4流量控制与可靠信息传输"><a href="#3-4流量控制与可靠信息传输" class="headerlink" title="3.4流量控制与可靠信息传输"></a>3.4流量控制与可靠信息传输</h2><h3 id="3-4-1流量控制与滑动窗口机制"><a href="#3-4-1流量控制与滑动窗口机制" class="headerlink" title="3.4.1流量控制与滑动窗口机制"></a>3.4.1流量控制与滑动窗口机制</h3><p><strong>滑动窗口机制：</strong></p><p>发送窗口WT&#x3D;1，接收窗口WR&#x3D;1;</p><p>发送窗口WT&gt;1，接收窗口WR&#x3D;1;</p><p>发送窗口WT&gt;1，接收窗口WR&gt;1;</p><p><strong>发送窗口内的帧允许被发送。接受窗口内的帧允许被接受</strong></p><p><strong>确认机制</strong></p><p><strong>确认帧：</strong>ACK_i：若接收方收到i号帧，且没有检测出差错，需要给发送方返回确认帧ACK_i</p><p><strong>否认帧：</strong>NAK_i：若接收方收到i号帧，但检测出i号帧有差错，需要丢弃该帧，并给发送方返回否认帧NAK_i</p><p><strong>重传机制</strong></p><p><strong>超时重传：</strong>若发送方超时未收到ACK_i,则重传i号帧</p><p><strong>请求重传：</strong>若发送方收到NAK_i,则重传i号帧</p><p><strong>帧编号：</strong></p><p>为了支持以上机制正确运行，至少需要n bit给帧“编号”</p><p><strong>要求</strong><br>$$<br>W_T+W_R&lt;&#x3D;2^n<br>$$</p><h3 id="3-4-2停止等待协议（S-W）"><a href="#3-4-2停止等待协议（S-W）" class="headerlink" title="3.4.2停止等待协议（S-W）"></a>3.4.2停止等待协议（S-W）</h3><p><strong>滑动窗口机制：</strong>发送窗口WT&#x3D;1，接受窗口WR&#x3D;1；</p><p><strong>确认机制</strong>：确认帧：ACK_i：若接受方收到i号帧，且没有检测出“差错”，需要给发送方返回确认帧ACK_i</p><p><strong>重传机制：</strong>超时重传，若发送方超时未收到ACK_i,则重传i号帧</p><p><strong>帧编号：</strong>仅需1 bit给帧“编号”</p><p><strong>要求：</strong><br>$$<br>W_T+W_R&lt;&#x3D;2^n<br>$$<br><strong>回顾：</strong></p><h4 id="正常窗口移动"><a href="#正常窗口移动" class="headerlink" title="正常窗口移动"></a>正常窗口移动</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919165327357.png" alt="image-20240919165327357"></p><p>发送方发出数据帧Data0,接收方接受并验证正确，返回确认帧ACK0，并给出信息，下一个要传送的这&#x3D;帧是Data1</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919165445809.png" alt="image-20240919165445809"></p><p>接收方接收到对应的数据帧之后就会将接收窗口进行右移，右移到帧序号为1的帧上，</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919165623351.png" alt="image-20240919165623351"></p><p>发送方收到对应的确认帧之后就会将发送窗口向右移动继续下一轮次的发送</p><h4 id="异常情况1："><a href="#异常情况1：" class="headerlink" title="异常情况1："></a>异常情况1：</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170026919.png" alt="image-20240919170026919"></p><p>在发送方到接受方的信道中存在网络噪声等因素，数据帧因网络噪声等原因丢失，接受方一直收不到下一个帧。</p><p>解决机制：超时重传，发出一个帧后，发送方需要启动“计时器”，若计时器超时，就自动重传。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170526283.png" alt="image-20240919170526283"></p><p>重传之后，在这次的计时器超时之前，发送方就很有可能会收到确认帧，之后的进程就和以前一样了。</p><h4 id="异常情况2："><a href="#异常情况2：" class="headerlink" title="异常情况2："></a>异常情况2：</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170701065.png" alt="image-20240919170701065"></p><p>确认帧在传送过程中丢失</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919170953936.png" alt="image-20240919170953936"></p><p>由于接收方已经接收到了对应的信息，所以接收窗口就会向右移动1位。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919171046355.png" alt="image-20240919171046355"></p><p>这会导致发送方在超时重传时发送到了当前滑动窗口的前一个帧的接收方位置上，这样接收方就收到了一个重复帧。帧序号落在接收窗口外：接收方完成两个动作①丢弃重复帧②返回重复帧的ACK。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919171729690.png" alt="image-20240919171729690"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919171746582.png" alt="image-20240919171746582"></p><p>发送方在收到了接受方发来的确认信息，发送窗口就可以继续向右移动</p><p>思考：在刚才的这个场景中，如果没有“帧序号”会发生什么？</p><p>答：接收方无法判别“重复帧”！</p><p>由于接收窗口和发送窗口的距离不超过1，因此用1bit表示帧序号足矣。</p><h4 id="异常情况3"><a href="#异常情况3" class="headerlink" title="异常情况3"></a>异常情况3</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919172247741.png" alt="image-20240919172247741"></p><p>接收方接收到错误的数据帧，接收方会将此帧丢弃，且不返回ACK、</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919172350699.png" alt="image-20240919172350699"></p><p>发送方超时未收到ACK自动对于ACK进行重传，这次的数据帧没有检测出差错，就可以继续进行以后的步骤。</p><h3 id="3-4-3后退N帧协议（GBN"><a href="#3-4-3后退N帧协议（GBN" class="headerlink" title="3.4.3后退N帧协议（GBN)"></a>3.4.3后退N帧协议（GBN)</h3><p><strong>滑动窗口机制：</strong>发送窗口WT&gt;1,接收窗口WR&#x3D;1</p><p><strong>确认机制：</strong>确认帧：ACK_i，若接收方收到i号帧，且没有检测出“差错”，需要给发送方返回确认帧ACK_i</p><p><strong>重传机制：</strong>超时重传，若发送方超时未收到ACK_i，则重传i号帧。</p><p><strong>帧编号：</strong></p><p>为了支持以上机制正确运行，至少需要用n bit给帧“编号”</p><p>要求<br>$$<br>W_T+W_R&lt;&#x3D;2^n<br>$$<br><strong>GBN的特殊规则：</strong></p><p>关于确认帧：接收方可以“累计确认”。即连续收到到多个数据帧时，可以仅返回最后一个帧的ACK（ACK_i代表接收方已收到i号帧及其之前的所有帧)</p><p>关于超时重传：若发送方超时未收到ACK_i,则重传i号帧，及其之后的所有帧</p><p><strong>要点：</strong></p><p>收到一个“非法帧”时，接收方会将此帧丢弃，并返回目前已接收的最后一个正确帧的ACK_i,以提醒发送方“后退”会i+1号重新发送</p><p>注：“非法帧”包括落在接收窗口之外的帧、检测出差错的帧</p><p><strong>缺点：</strong>如果接收方接受帧的速度很慢，或在信道误码率很高的情况下，可能会导致发送方的发送进度经常需要“后退”，传输效率低下。</p><h4 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919211300037.png" alt="image-20240919211300037"></p><p>三个发送窗口都发送数据，给接收方</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919211349714.png" alt="image-20240919211349714"></p><p>当接收方接受了一个帧之后，就可以移动接收窗口接受下一个帧</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919212756853.png" alt="image-20240919212756853"></p><p>以此类推，当整个发送窗口的帧都已经被接受了，最后一个帧的接受信息会被接收方发送给发送方，ACK_i表示接收方已经收到i号帧及其之前的所有帧</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213004293.png" alt="image-20240919213004293"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213034736.png" alt="image-20240919213034736"></p><p>之后向后移动完成对应的下一个发送窗口的帧的发送与接受</p><h4 id="异常情况1-数据帧丢失"><a href="#异常情况1-数据帧丢失" class="headerlink" title="**异常情况1 **数据帧丢失"></a>**异常情况1 **数据帧丢失</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213249647.png" alt="image-20240919213249647"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213312452.png" alt="image-20240919213312452"></p><p>当收到接受窗口之外的帧时，返回目前以正确接受的最后一个帧的ACK,完成对应的前序工作的整理。一号数据帧在接受窗口之外，直接丢弃</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240920112620791.png"></p><p>重新调整数据窗口，若i号帧超时，需要重传i号帧及其后续所有帧</p><p>为什么叫“后退”N帧协议，原本已经发送了1号帧，现在却后退回零号帧重新传送。这样即可实现“流量控制”</p><p>之后完成重传即可。</p><h4 id="异常情况2-确认帧丢失"><a href="#异常情况2-确认帧丢失" class="headerlink" title="异常情况2 确认帧丢失"></a>异常情况2 确认帧丢失</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213843058.png" alt="image-20240919213843058"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919213935656.png" alt="image-20240919213935656"></p><p>这样第一个传送帧就会超时，之后所有的后续帧都要重传，但会被丢弃（因为已经传送过了）</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919214037617.png" alt="image-20240919214037617"></p><h4 id="探讨：如果不满足WT-WR-lt-x3D-2-n会出现什么问题"><a href="#探讨：如果不满足WT-WR-lt-x3D-2-n会出现什么问题" class="headerlink" title="探讨：如果不满足WT+WR&lt;&#x3D;2^n会出现什么问题"></a>探讨：如果不满足WT+WR&lt;&#x3D;2^n会出现什么问题</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919214146309.png" alt="image-20240919214146309"></p><p>超时后窗口的帧会发现不能确定这是新的帧，还是重传的旧帧，数据帧会被错误的接受。</p><h3 id="3-4-4选择重传协议（SR）"><a href="#3-4-4选择重传协议（SR）" class="headerlink" title="3.4.4选择重传协议（SR）"></a>3.4.4选择重传协议（SR）</h3><p><strong>滑动窗口机制：</strong>发送窗口WT&gt;1,接收窗口E&#x3D;WR&gt;1</p><p><strong>确认机制：</strong></p><p><strong>确认帧：</strong>ACK_i:若接收方收到i号帧，且没有检测出“差错”，需要给发送方返回确认帧ACK_i</p><p><strong>否认帧：</strong>NAK_i：若接收方收到i号帧，但检测出i号帧由”差错”，需要丢弃该帧，并给发送方返回否认帧NAK_i</p><p><strong>重传机制</strong></p><p><strong>超时重传：</strong>若发送方超时未收到ACK_i，则重传i号帧</p><p><strong>请求重传：</strong>若发送方收到NAK_i，则重传i号帧</p><p><strong>帧编号</strong></p><p>为了支持以上机制正确运行，至少需要用n bit给帧“编号”</p><p>要求<br>$$<br>W_T+W_R&lt;&#x3D;2^n；</p><p>W_R&lt;&#x3D;W_T,即接收窗口不能大于发送窗口</p><p>若接收窗口大于发送窗口，<br>则接收窗口永远不可能填满，接收窗口多出的空间就毫无意义。<br>$$</p><p><strong>要点</strong></p><p>若接受方检测出帧差错，则丢弃帧，并返回NAK_i，主动请求重传</p><p><strong>接收方不能“累计确认”，必须“一帧一确认”</strong></p><h4 id="正常情况："><a href="#正常情况：" class="headerlink" title="正常情况："></a>正常情况：</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223313596.png" alt="image-20240919223313596"></p><p>每个发送方都向接收方的帧窗口发送帧</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223502882.png"></p><p>每收到一个帧，接收窗口就可以向右平移一位。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223535445.png"></p><p>发送方每收到一个应答信息就可以平移一次发送窗口。</p><p>最后完成平移，依次进行。</p><h4 id="异常情况1：数据帧丢失"><a href="#异常情况1：数据帧丢失" class="headerlink" title="异常情况1：数据帧丢失"></a>异常情况1：数据帧丢失</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223746395.png" alt="image-20240919223746395"></p><p>其中的一个数据帧因通信故障丢失。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919223808061.png" alt="image-20240919223808061"></p><p>由于出现了一个数据帧的丢失，所以对应的发送窗口和接收窗口的移动都会受到限制只能各移动一位</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224041546.png" alt="image-20240919224041546"></p><p>重传</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224056506.png" alt="image-20240919224056506"></p><p>重应答</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224113876.png" alt="image-20240919224113876"></p><p>完成最终的平移，以此类推。</p><h4 id="异常情况2-数据帧因差错而被丢弃"><a href="#异常情况2-数据帧因差错而被丢弃" class="headerlink" title="异常情况2:数据帧因差错而被丢弃"></a>异常情况2:数据帧因差错而被丢弃</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224329435.png" alt="image-20240919224329435"></p><p>检测出现错误，被接收方丢弃</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240920192203740.png"></p><p>返回5号“否认帧”</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224552444.png" alt="image-20240919224552444"></p><p>触发重传，0号是正常传递</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919224630899.png" alt="image-20240919224630899"></p><p>之后一次完成发送窗口以及接收窗口的平移。</p><h4 id="异常情况3：确认帧丢失"><a href="#异常情况3：确认帧丢失" class="headerlink" title="异常情况3：确认帧丢失"></a>异常情况3：确认帧丢失</h4><p>与一般的确认帧丢失差不多。也会限制对应的发送帧的平移</p><h4 id="探讨：如果不满足WT-WR-lt-x3D-2-n会有什么问题？"><a href="#探讨：如果不满足WT-WR-lt-x3D-2-n会有什么问题？" class="headerlink" title="探讨：如果不满足WT+WR&lt;&#x3D;2^n会有什么问题？"></a>探讨：如果不满足WT+WR&lt;&#x3D;2^n会有什么问题？</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919225402153.png"></p><p>假设所有的ACK帧都丢失了。</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240919225430320.png" alt="image-20240919225430320"></p><p>会有的重复帧被判定为正常帧，被接收方接收。</p><h3 id="3-4-5信道利用率的分析"><a href="#3-4-5信道利用率的分析" class="headerlink" title="3.4.5信道利用率的分析"></a>3.4.5信道利用率的分析</h3><p><strong>S-W</strong>,停止等待协议的信道利用率<br>$$<br>U&#x3D;T_D&#x2F;(T_D+RTT+TA)<br>$$<br>**TD:**一个数据帧的传输时延（发送时延）</p><p><strong>TA：</strong>一个ACK确认帧的传输时延（发送时延）</p><p><strong>RTT：</strong>往返时延，即两倍的单向传播时延</p><p><strong>注意：很多题目会忽略确认帧的传输时延TA</strong></p><p><strong>GBN&#x2F;SR，</strong>剩余两项协议的信道利用率<br>$$<br>U&#x3D;N*T_D&#x2F;(T_D+RTT+TA)<br>$$<br><strong>N</strong>表示发送窗口大小</p><p><strong>注意：信道利用率不能超过1</strong></p><p>常结合“<strong>帧编号</strong>”考察。</p><p>用n bit给帧“编号”，要求WT+WR&lt;&#x3D;2^n</p><p><strong>GBN协议的WR&#x3D;1,SR协议WR&gt;1.因此用同样多的比特数给帧编号，GBN的发送窗口WT更大，因此GBN的信道利用率也会很高。</strong></p><p><strong>术语补充</strong></p><p>滑动窗口协议：GBN或SR协议</p><p>ARQ协议：指的是S-W,GBN或SR协议</p><p>连续ARQ协议：GBN或SR协议</p><h2 id="3-5介质访问控制"><a href="#3-5介质访问控制" class="headerlink" title="3.5介质访问控制"></a>3.5介质访问控制</h2><h3 id="3-5-1信道划分介质访问控制"><a href="#3-5-1信道划分介质访问控制" class="headerlink" title="3.5.1信道划分介质访问控制"></a>3.5.1信道划分介质访问控制</h3><h4 id="时分复用（TDM"><a href="#时分复用（TDM" class="headerlink" title="时分复用（TDM)"></a>时分复用（TDM)</h4><p>将时间片（时间片大小固定），各节点依次分配一个时间片</p><h4 id="统计时分复用（STDM"><a href="#统计时分复用（STDM" class="headerlink" title="统计时分复用（STDM)"></a>统计时分复用（STDM)</h4><p>在时分复用 的基础上，按需分配时间片</p><h4 id="频分复用（FDM"><a href="#频分复用（FDM" class="headerlink" title="频分复用（FDM)"></a>频分复用（FDM)</h4><p>将信道的总频带拆分为几条互不相交的子频带，为每一个发送节点分配一条子频带</p><h4 id="波分复用（WDM"><a href="#波分复用（WDM" class="headerlink" title="波分复用（WDM)"></a>波分复用（WDM)</h4><p>本质上是光的频分复用（光的波长与频率有关）</p><h4 id="码分复用（CDM"><a href="#码分复用（CDM" class="headerlink" title="码分复用（CDM)(***)"></a>码分复用（CDM)(***)</h4><p>①给各节点分配专属“码片序列”</p><p><strong>“码片序列”</strong>包含m个码片（信号值），可看做<strong>“m维向量”（分量通常取1或-1）</strong></p><p>要求：各节点的“m维向量”<strong>必须相互正交</strong></p><p>Tips：相互通信的各节点知道彼此的“码片序列”</p><p>②发送方如何发送数据</p><p>节点发出m个信号值与<strong>“码片序列”相同</strong>，表示<strong>比特1</strong>；</p><p>节点发出m个信号值与<strong>“码片序列”不同</strong>，表示<strong>比特0</strong>；</p><p>③信号在传输过程中“叠加”</p><p>当多个发送方同时发送数据使，<strong>信号值会叠加</strong>（注：本质是多个m维向量的加法）</p><p>④接收方如何接收数据</p><p>接收方接收到的是“叠加”信号，需要从中“分离”出各发送方的数据</p><p>叠加信号与发送方的码片序列做“规格化内积”</p><p><strong>结果为1，表示比特1</strong></p><p><strong>结果为-1，表示比特0</strong></p><h3 id="3-5-2随机访问介质访问控制"><a href="#3-5-2随机访问介质访问控制" class="headerlink" title="3.5.2随机访问介质访问控制"></a>3.5.2随机访问介质访问控制</h3><h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><p><strong>纯ALOHA</strong></p><p>节点一旦准备好数据帧，就立即发送到信道上</p><p>若超时未收到ACK,随机等一段时间后重传</p><p><strong>时隙ALOHA</strong></p><p>“时隙”大小固定&#x3D;传输一个最长帧所需时间</p><p>各节点只能在时隙内传输帧，相比于纯ALOHA，降低了冲突的概率</p><h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><p><strong>1-坚持CSMA</strong></p><p>发送前先监听信道，若信道空闲立即发送数据帧（发送概率为1）</p><p>“坚持”意味着如果信道不空闲，节点会坚持监听信道</p><p><strong>非坚持CSMA</strong></p><p>可记忆为“1-非坚持”，即发送前先监听信道，若信道空闲立即发送数据帧（发送概率为1）</p><p>“非坚持”意味着如果信道不空闲，节点不会坚持监听信道，而是随机推迟一段时间后再尝试监听</p><p><strong>p-坚持CSMA</strong></p><p>发送前先监听信道，若信道空闲则以概率p立即发送帧，以概率1-p推迟一段时间再发送</p><p>“坚持”同上</p><h4 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><p><strong>协议要点：</strong></p><p>先听后发，边听边发，冲突停发，随机重发</p><p><strong>如何随机重发？</strong></p><p>截断二进制指数退避算法：</p><p>随机等待一段时间&#x3D;r倍争用期，其中r是随机数</p><p>①如果k&lt;&#x3D;10,在[0,(2^k-1)]区间随机取一个整数r</p><p>②如果k&gt;10,在[0,(2^10-1)]区间随机取一个整数r</p><p><strong>特别注意：</strong></p><p>第10次冲突，是“随机重发”的分水岭</p><p>第16次重发，直接躺平，放弃传帧，报告上级（网络层）</p><p><strong>争用期</strong>&#x3D;2*最大单向传播时延（考虑距离最远的两个节点）</p><p>若<strong>争用期</strong>内未发生冲突，就不可能再次发生冲突</p><p>CSMA&#x2F;CD<strong>没有ACK机制</strong>，若发送过程中未检测到冲突，就认为帧发送成功</p><p><strong>最短帧长</strong>&#x3D;2* 最大单向传播时延 *信道带宽</p><p>若收到的帧小于最短帧长，视为无效帧</p><p>原因：可能会导致所有的帧都已经发出了，但是在这之后的一段时间，一个冲突信息才感到，这样会被认为没有发生冲突，就算是当成冲突，也没有剩余的帧长可以用来收回了。</p><p><strong>最长帧长：</strong>规定最长帧长可防止某些节点一直占用信道。</p><p><strong>以太网规定：</strong>最短帧长&#x3D;64B；最长帧长&#x3D;1518B</p><h4 id="CSMA-x2F-CA协议"><a href="#CSMA-x2F-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h4><p><strong>协议要点：</strong></p><p>发送方：先听后发，忙则退避</p><p>若信道空闲，间隔DIFS（很长的时间）后，再发送帧（一口气发完，发送过程中不用检测冲突）</p><p>若信道不空闲，则进行“随机退避”</p><p><strong>“随机退避”原理</strong></p><p>①用二进制指数退避算法确定一段随机退避时间（倒计时）</p><p>②发送方会保持监听信道，只有信道空闲时才“扣除倒计时”，倒计时结束后立即发送帧（此时信道“听起来”一定空闲）</p><p><strong>接收方：停止等待协议</strong></p><p>每收到一个正确数据都返回ACK：若发送方超时未收到ACK，则进行“随机退避”</p><p><strong>信道预约机制（可选功能）</strong></p><p>①发送方广播RTS控制帧（先听后发，忙则退避）</p><p>②AP广播CTS控制帧（需在RTS、CTS中指明预约时长）</p><p>③其他无关节点收到CTS后自觉“禁言”一段时间（即：虚拟载波监听机制）；发送方收到CTS后，就可以发送数据帧</p><p>④AP收到数据帧后，进行CRC校验，若无差错就返回ACK帧</p><p><strong>帧间间隔IFS</strong></p><p>**DIFS,**最长的IFS</p><p>每次“帧事务”开始之前需要等待的时间</p><p>**SIFS,**最短的IFS</p><p>收到一个帧后需要预留的一段处理时间</p><p>**PIFS,**中等长度的IFS</p><p>考研不考虑PIFS</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240922202058917.png" alt="image-20240922202058917"></p><h3 id="3-5-3轮询访问：令牌传递协议"><a href="#3-5-3轮询访问：令牌传递协议" class="headerlink" title="3.5.3轮询访问：令牌传递协议"></a>3.5.3轮询访问：令牌传递协议</h3><p><strong>协议要点：</strong></p><p><strong>令牌帧</strong></p><p>需知明当前获得令牌的节点编号</p><p>只有获得令牌（Token）的节点才能往信道上发送数据帧</p><p>如果获得令牌的节点没有数据要发送，就将令牌传递下一个节点</p><p><strong>数据帧</strong>（发送数据时令牌帧转换成数据帧）</p><p>需指明数据帧的源地址和目的地址、是否已被接收、获得令牌的节点编号</p><p>数据帧从源节点发出，“传递一圈”后回到源节点</p><p>数据帧“传递一圈”过程中，会为<strong>目的节点</strong>复制一份数据，并将数据帧标记为<strong>“已接收”</strong></p><p>数据帧回到源节点后，如果发现异常状况，就尝试重发；若<strong>无异常</strong>，就<strong>将令牌传递下一个节点</strong></p><p><strong>其他补充：</strong></p><p>无论是令牌帧还是数据帧，都只能单向传递</p><p>获得令牌的节点，每次只能发一帧，发完就释放令牌</p><p>需要用专门的网络设备（MAU）实现<strong>集中控制</strong></p><p>令牌传递协议很<strong>适用于负载高</strong>的网络（不会发生冲突，效率高）（重发少））</p><h2 id="3-6局域网"><a href="#3-6局域网" class="headerlink" title="3.6局域网"></a>3.6局域网</h2><h3 id="3-6-0局域网与IEEE"><a href="#3-6-0局域网与IEEE" class="headerlink" title="3.6.0局域网与IEEE"></a>3.6.0局域网与IEEE</h3><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240930204125634.png" alt="image-20240930204125634"></p><h3 id="3-6-1局域网的基本概念和体系结构"><a href="#3-6-1局域网的基本概念和体系结构" class="headerlink" title="3.6.1局域网的基本概念和体系结构"></a>3.6.1局域网的基本概念和体系结构</h3><h4 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20240930204432070.png" alt="image-20240930204432070"></p><h3 id="3-6-2以太网与IEEE-802-3"><a href="#3-6-2以太网与IEEE-802-3" class="headerlink" title="3.6.2以太网与IEEE 802.3"></a>3.6.2以太网与IEEE 802.3</h3><h4 id="3-6-2-1物理层标准"><a href="#3-6-2-1物理层标准" class="headerlink" title="3.6.2.1物理层标准"></a>3.6.2.1物理层标准</h4><p><strong>速度+Base+传输介质信息</strong></p><p>如：10Base5、10Base2–同轴电缆</p><p>如：10BaseT、100BaseTX、2.5GBaseT–双绞线</p><p>如：10BaseF、100BaseFX、40GBaseFR–光纤(很少考)</p><p><strong>key：如果一个网段工作在半双工模式下，才需要使用CSMA&#x2F;CD协议实现介质访问控制</strong></p><p><strong>做题技巧</strong></p><p><strong>同轴电缆网段</strong></p><p>仅支持半双工</p><p><strong>双绞线网段</strong></p><p>如果连接集线器，就只能工作在半双工模式下</p><p>如果连接交换机，就默认工作在全双工模式下</p><p><strong>光纤网段（很少考）</strong></p><p>仅支持<strong>全双工</strong></p><p>以太网的物理层使用<strong>曼彻斯特编码（跳0反跳1看中间，中必变）</strong></p><h4 id="3-6-2-2MAC层标准"><a href="#3-6-2-2MAC层标准" class="headerlink" title="3.6.2.2MAC层标准"></a>3.6.2.2MAC层标准</h4><p><strong>以太网MAC帧格式</strong></p><p>V2标准（默认） 662N4,收发协数验</p><p>802.3标准 662N4，收发长数验</p><p>N是46-1500</p><p><strong>一个MAC地址是6B,48bit。目的地址全1表示广播帧</strong></p><p>交换机会将受到的广播帧转发至其他端口</p><p>路由器不会转发广播帧</p><p><strong>物理层会在MAC帧前添加8B前导码（7同步、1定界）</strong></p><h3 id="3-6-3VLAN虚拟局域网"><a href="#3-6-3VLAN虚拟局域网" class="headerlink" title="3.6.3VLAN虚拟局域网"></a>3.6.3VLAN虚拟局域网</h3><p><strong>大型局域网需要面临的问题：</strong></p><p>整个局域网是一个很大的广播域，容易出现广播风暴。</p><p>不利于信息安全。</p><p><strong>VLAN的特征</strong></p><p>可将一个大型局域网分割成若干个较小的VLAN每个VLAN是一个广播域</p><p>需要使用支持VLAN功能的以太网交换机来实现</p><p><strong>每个VLAN对应一个VID</strong></p><p><strong>三种划分VLAN的方式</strong></p><p>基于接口</p><p>VID&lt;–&gt;接口号</p><p>基于MAC地址</p><p>VID&lt;–&gt;MAC地址</p><p>基于IP地址</p><p>VID&lt;–&gt;IP地址</p><p>这种方式可以让VLAN范围跨越路由器，让多个局域网的主机组成一个VLAN（需要网络层功能支持）</p><p><strong>802.1Q帧</strong></p><p><strong>主机与交换机</strong>之间，传输<strong>标准以太网帧</strong>（6 6 2 N 4，收发协数验）</p><p><strong>交换机与交换机</strong>之间（干线链路），传输<strong>802.1Q</strong>帧（6 6 <strong>4</strong> 2 N 4，收发<strong>V</strong>协数验）</p><p><strong>4</strong>字节<strong>V</strong>LAN标签&#x3D;16+4+<strong>12</strong>bit&#x3D;固定+随便+<strong>VID</strong>（<strong>V的构成</strong>）</p><h2 id="3-8数据链路层设备"><a href="#3-8数据链路层设备" class="headerlink" title="3.8数据链路层设备"></a>3.8数据链路层设备</h2><h3 id="3-8-1以太网交换机"><a href="#3-8-1以太网交换机" class="headerlink" title="3.8.1以太网交换机"></a>3.8.1以太网交换机</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>交换机&#x3D;多端口<strong>网桥</strong>（408大纲已经删除网桥）</p><p>交换机工作在数据链路层，可以根据目的MAC地址转发帧</p><h4 id="自学习功能（支持即插即用）"><a href="#自学习功能（支持即插即用）" class="headerlink" title="自学习功能（支持即插即用）"></a>自学习功能（支持即插即用）</h4><p><strong>交换表</strong></p><p>初始为空，记录[MAC地址，端口号]的对应关系</p><p>每<strong>收到一个帧</strong>，就将<strong>“发送方”</strong>的[MAC地址，端口号]更新到交换表</p><p>①如果<strong>不知道“接收方”在哪里</strong>，就把帧<strong>广播到除入口外的其他端口</strong></p><p>②如果<strong>知道“接收方”在哪里</strong>，就把帧<strong>精准转发至某个端口</strong></p><p>交换表中每个表项都有“有效时间”，<strong>过期表项自动作废</strong>，以防某些节点拔线跑路</p><h4 id="两种交换方式"><a href="#两种交换方式" class="headerlink" title="两种交换方式"></a>两种交换方式</h4><p><strong>直通交换</strong></p><p>只检查帧的目的MAC地址，以决定帧的转发端口</p><p>优点：转发时延低</p><p>缺点：不适用于需要速度匹配、协议转换或差错检测的线路</p><p><strong>存储转发转换</strong></p><p>先把帧完整地接受到交换机内部的高速缓存中，进行差错检测等必要处理，再根据交换表决定从哪个端口转发出去</p><p>优点：适用于需要速率匹配、协议转换或差错检测的线路</p><p>缺点：转发时延高</p><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="4-1网络层的功能"><a href="#4-1网络层的功能" class="headerlink" title="4.1网络层的功能"></a>4.1网络层的功能</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241101205456840.png" alt="image-20241101205456840"></p><h2 id="4-2-IPv4"><a href="#4-2-IPv4" class="headerlink" title="4.2 IPv4"></a>4.2 IPv4</h2><h3 id="4-2-1-IPv4分组的格式"><a href="#4-2-1-IPv4分组的格式" class="headerlink" title="4.2.1 IPv4分组的格式"></a>4.2.1 IPv4分组的格式</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107205838548.png" alt="image-20241107205838548"></p><ol><li><strong>版本</strong>。占4位。指的是IP的版本，IPv4数据包中的该字段值是4</li><li><strong>首部长度。</strong>占4位。以4B为单位，最大可表示的首部长度为60B（15*4B）。最常用的首部长度是20B（5乘以4B），该字段值是5，此时不使用任何可选字段。</li><li><strong>总长度。</strong>占16位。指的是首部和数据之和的长度，单位为字节，因此数据报的最大长度为65535B。以太网帧的最大传送单元（MTU）为1500B，因此当一个IP数据报封装成帧时，数据报的总长度（首部加数据）一定不能超过下面的数据链路层的MTU值</li><li><strong>标识。</strong>占16位。他是一个计数器，每产生一个数据报就加1，并赋值给标识字段</li><li><strong>标志。</strong>占3位。标志字段的最低位为MF，MF&#x3D;1表示后面还有分片，MF&#x3D;0表示最后一个分片、标志字段中间的一位是DF，只有当DF&#x3D;0时才允许分片。</li><li><strong>片偏移。</strong>占13位。他指出较长的数据报在分片后，某片在原数据报中的相对位置，片偏移以8B为偏移单位。除最后一个分片外，每个分片的长度一定是8B的整数倍</li><li><strong>生存时间。</strong>占8位。数据报在网络中可通过的路由器数的最大值，标识数据报在网络中的寿命，以确保数据报不会永远在网络中循环。路由器在转发数据报前，现将TTL减一。若TTL被减为0，则该数据报必须丢弃。</li><li><strong>协议。</strong>占8位。指出此数据报携带的数据使用何种协议，即数据报的数据部分应上交给哪个协议进行处理，如TCP,UDP等。其中值为<strong>6</strong>表示<strong>TCP</strong>，值为<strong>17</strong>表示<strong>UDP</strong></li><li><strong>首部检验和。</strong>占16位。它只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，都要重新计算首部检验和（有些字段，如生存时间。。。。）不检验数据部分可以减少计算的工作量、</li><li><strong>源地址字段。</strong>占4B，标识发送方的IP地址。</li><li><strong>目标地址字段。</strong>占4B，标识接收方的IP地址。</li></ol><p><strong>易错：</strong>除了最后一个分片外，其他每个分片的“数据部分”必须是8B的整数倍</p><h3 id="4-2-2-IP地址"><a href="#4-2-2-IP地址" class="headerlink" title="4.2.2 IP地址"></a>4.2.2 IP地址</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212143880.png" alt="image-20241107212143880"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212242485.png" alt="image-20241107212242485"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212354347.png" alt="image-20241107212354347"></p><p><strong>一些特殊的用途的IP地址</strong></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212456289.png" alt="image-20241107212456289"></p><h3 id="4-2-3子网划分，子网掩码"><a href="#4-2-3子网划分，子网掩码" class="headerlink" title="4.2.3子网划分，子网掩码"></a>4.2.3子网划分，子网掩码</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212823844.png" alt="image-20241107212823844"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107212906369.png" alt="image-20241107212906369"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213033881.png" alt="image-20241107213033881"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213333299.png" alt="image-20241107213333299"></p><h2 id="4-3IPv6"><a href="#4-3IPv6" class="headerlink" title="4.3IPv6"></a>4.3IPv6</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213543824.png" alt="image-20241107213543824"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213521559.png" alt="image-20241107213521559"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213502015.png" alt="image-20241107213502015"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213620097.png" alt="image-20241107213620097"></p><p><strong>位数多，彻底解决了IP地址不够用的问题</strong>IPv6</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213709212.png" alt="image-20241107213709212"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107213742029.png" alt="image-20241107213742029"></p><h2 id="4-4路由算法及路由协议"><a href="#4-4路由算法及路由协议" class="headerlink" title="4.4路由算法及路由协议"></a>4.4路由算法及路由协议</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214127781.png" alt="image-20241107214127781"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214237249.png" alt="image-20241107214237249"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214350839.png" alt="image-20241107214350839"></p><h3 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a>RIP协议及距离向量算法</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214621410.png" alt="image-20241107214621410"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214750666.png" alt="image-20241107214750666"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107214910886.png" alt="image-20241107214910886"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215411724.png" alt="image-20241107215411724"></p><h3 id="OSPF协议及链路状态算法"><a href="#OSPF协议及链路状态算法" class="headerlink" title="OSPF协议及链路状态算法"></a><strong>OSPF协议及链路状态算法</strong></h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215540852.png" alt="image-20241107215540852"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215616889.png" alt="image-20241107215616889"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215714329.png" alt="image-20241107215714329"></p><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215814268.png" alt="image-20241107215814268"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215844525.png" alt="image-20241107215844525"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107215913791.png" alt="image-20241107215913791"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220022511.png" alt="image-20241107220022511"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220103983.png" alt="image-20241107220103983"></p><h2 id="4-5IP组播"><a href="#4-5IP组播" class="headerlink" title="4.5IP组播"></a>4.5IP组播</h2><p>略</p><h1 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h1><p>5.1传输层提供的服务</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220440767.png" alt="image-20241107220440767"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220621755.png" alt="image-20241107220621755"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107220858742.png" alt="image-20241107220858742"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221031989.png" alt="image-20241107221031989"></p><h2 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221213475.png" alt="image-20241107221213475"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221309028.png" alt="image-20241107221309028"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221419740.png" alt="image-20241107221419740"></p><p>UDP差错检验</p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221602144.png" alt="image-20241107221602144"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221743456.png" alt="image-20241107221743456"></p><h2 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h2><h3 id="5-3-1TCP结构"><a href="#5-3-1TCP结构" class="headerlink" title="5.3.1TCP结构"></a>5.3.1TCP结构</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221925513.png" alt="image-20241107221925513"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107221939990.png" alt="image-20241107221939990"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222005762.png" alt="image-20241107222005762"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222445180.png" alt="image-20241107222445180"></p><p>原理与UDP雷同，计算检验和之前也需要添加12B 伪首部（只需将UDP 伪首部的协议字段的 17 改成6，UDP 长度字段改成 TCP 长度）</p><h3 id="5-3-2连接管理"><a href="#5-3-2连接管理" class="headerlink" title="5.3.2连接管理"></a>5.3.2连接管理</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222814427.png" alt="image-20241107222814427"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222835791.png" alt="image-20241107222835791"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222912482.png" alt="image-20241107222912482"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107222928138.png" alt="image-20241107222928138"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223001982.png" alt="image-20241107223001982"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223056761.png" alt="image-20241107223056761"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223115096.png" alt="image-20241107223115096"></p><h3 id="5-3-3可靠传输，流量控制"><a href="#5-3-3可靠传输，流量控制" class="headerlink" title="5.3.3可靠传输，流量控制"></a>5.3.3可靠传输，流量控制</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223236033.png" alt="image-20241107223236033"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223320213.png" alt="image-20241107223320213"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223357503.png" alt="image-20241107223357503"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223503577.png" alt="image-20241107223503577"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223559678.png" alt="image-20241107223559678"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223619505.png" alt="image-20241107223619505"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107223714965.png" alt="image-20241107223714965"></p><h3 id="5-3-4拥塞控制"><a href="#5-3-4拥塞控制" class="headerlink" title="5.3.4拥塞控制"></a>5.3.4拥塞控制</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224047888.png" alt="image-20241107224047888"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224135147.png" alt="image-20241107224135147"></p><h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><h2 id="6-1网络应用模型"><a href="#6-1网络应用模型" class="headerlink" title="6.1网络应用模型"></a>6.1网络应用模型</h2><h3 id="C-x2F-S模型，比如说百度网盘"><a href="#C-x2F-S模型，比如说百度网盘" class="headerlink" title="C&#x2F;S模型，比如说百度网盘"></a>C&#x2F;S模型，比如说百度网盘</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224619534.png" alt="image-20241107224619534"></p><h3 id="P2P模型，比如说BT种子"><a href="#P2P模型，比如说BT种子" class="headerlink" title="P2P模型，比如说BT种子"></a>P2P模型，比如说BT种子</h3><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224723432.png" alt="image-20241107224723432"></p><h2 id="6-2DNS解析"><a href="#6-2DNS解析" class="headerlink" title="6.2DNS解析"></a>6.2DNS解析</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224913614.png" alt="image-20241107224913614"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107224941151.png" alt="image-20241107224941151"></p><h2 id="6-3FTP"><a href="#6-3FTP" class="headerlink" title="6.3FTP"></a>6.3FTP</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225038206.png" alt="image-20241107225038206"></p><h2 id="6-4电子邮件"><a href="#6-4电子邮件" class="headerlink" title="6.4电子邮件"></a>6.4电子邮件</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225129513.png" alt="image-20241107225129513"></p><h2 id="6-5万维网和HTTP"><a href="#6-5万维网和HTTP" class="headerlink" title="6.5万维网和HTTP"></a>6.5万维网和HTTP</h2><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225231100.png" alt="image-20241107225231100"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225258837.png" alt="image-20241107225258837"></p><p><img src="/2025/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20241107225311819.png" alt="image-20241107225311819"></p>]]></content>
    
    
    <summary type="html">有关openVZ</summary>
    
    
    
    <category term="计算机网络" scheme="https://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="openVZ" scheme="https://example.com/tags/openVZ/"/>
    
  </entry>
  
  <entry>
    <title>操作系统笔记</title>
    <link href="https://example.com/2025/09/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <id>https://example.com/2025/09/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</id>
    <published>2025-09-30T02:24:50.860Z</published>
    <updated>2025-10-24T11:56:54.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><h2 id="2-1线程的属性"><a href="#2-1线程的属性" class="headerlink" title="2.1线程的属性"></a>2.1线程的属性</h2><p>①线程是处理机调动的单位。</p><p>②多cpu计算机中，各个线程可占用不同的CPU</p><p>③每个线程都有一个线程ID，线程控制块(TCB)</p><p>④线程也有就绪，阻塞运行三种基本状态</p><p>⑤线程几乎不拥有任何系统资源</p><p>⑥同一进程的不同线程间共享进程的资源。</p><p>⑦由于共享内存地址空间，同一进程的线程间通信甚至无需系统干预</p><p>⑧同一进程中的线程切换不会引起进程切换</p><p>⑨与⑧相反</p><p>⑩切换同进程内的线程，系统开销很小</p><p>⑪切换进程，系统开销很小。</p><h2 id="2-2调度"><a href="#2-2调度" class="headerlink" title="2.2调度"></a>2.2调度</h2><h3 id="三种调度的联系对比"><a href="#三种调度的联系对比" class="headerlink" title="三种调度的联系对比"></a>三种调度的联系对比</h3><table><thead><tr><th>调度方法</th><th>细节描述</th><th>数据流动方向</th><th align="center">发生频率</th><th align="center">状态转换</th></tr></thead><tbody><tr><td>高级调度（作业调度）</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td>外存-&gt;内存（面向作业）</td><td align="center">发生频率最低</td><td align="center">不存在-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度（内存调度）</td><td>按照某种规则，从挂起队列中选择合适的进程将数据调回内存。</td><td>外存-&gt;内存（面向进程）</td><td align="center">中等</td><td align="center">挂起态-&gt;就绪态（阻塞挂起）-&gt;阻塞态</td></tr><tr><td>低级调度（进程调度）</td><td>按照某种规则从就绪队列中选择一个进程为其分配处理机</td><td>内存-&gt;CPU</td><td align="center">最高</td><td align="center">就绪态-&gt;运行态</td></tr></tbody></table><h3 id="需要进行切换的调度与切换状况"><a href="#需要进行切换的调度与切换状况" class="headerlink" title="需要进行切换的调度与切换状况"></a>需要进行切换的调度与切换状况</h3><table><thead><tr><th align="left">当前运行的进程主动放弃处理机</th><th align="left">①进程正常终止②运行过程中出现异常而终止③进程主动请求阻塞</th></tr></thead><tbody><tr><td align="left">当前运行的进程被动放弃处理机</td><td align="left">①分给进程的时间片用光②有更紧急的是需要处理（如优先级调度剥夺形式的短作业（进程）优先调度或者I&#x2F;O中断)③有更高优先级的进程进入就绪队列</td></tr></tbody></table><p>小知识点</p><p>进程在操作系统内核程序临界区中不能进行地调度与切换</p><p><strong>临界资源：</strong>一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源</p><p><strong>临界区：</strong>访问临界资源的那段代码</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p><p>如果还没有退出临界区（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利地进行进程调度</p><p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理操作。因此访问内核程序临界区期间不能进行调度与切换。</p><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理操作。因此在访问普通临界区时可以进行调度与切换。</p><h3 id="2-2-1-习题"><a href="#2-2-1-习题" class="headerlink" title="2.2.1 习题"></a>2.2.1 习题</h3><p>为什么说多级反馈队列调度算法能较好地满足各类用户的需要？</p><p>多级反馈队列调度算法能够较好的满足各种类型用户的需要。对终端型作业用户而言，由于他们所提交的作业大多属于交互性作业，作业通常比较短小，系统只要能使这类作业在第一梯队队列对规定的时间片内完成，便可使终端型作业用户得到满意：对于短批处理作业用户而言，他们与终端型作业用户一样，只要能在对应的给定的时间片内完成，便可获得与终端作业用户一样的响应时间。对于稍长的作业，通常也只需要在第二个队列与第三级队列中各运行一个时间片即可完成，其周转时间依旧较短。对于长批处理作业用户而言，他们的长作业将一次在1-n级队列完成，然后按照时间片轮转的方式运行，用户不必担心作业长期得不到处理。</p><h2 id="2-3同步与互斥"><a href="#2-3同步与互斥" class="headerlink" title="2.3同步与互斥"></a>2.3同步与互斥</h2><h3 id="2-3-1同步互斥"><a href="#2-3-1同步互斥" class="headerlink" title="2.3.1同步互斥"></a>2.3.1同步互斥</h3><p><strong>进程同步：</strong>并发性带来了异步性，有时需要通过进程同步解决这种异步问题。有的进程之间需要相互配合的完成工作，各进程之间的工作推进需要遵循一定的先后顺序。</p><p><strong>进程互斥：</strong>对进程临界资源的访问，需要互斥的进行，即同一时间段内只允许一个进程访问该资源。</p><p>四个部分：</p><p><strong>进入区：</strong>检查是否可进入临界区，若可进入则需“上锁”</p><p><strong>临界区：</strong>用来访问临界资源的那段代码。</p><p><strong>退出区：</strong>负责解锁</p><p><strong>剩余区：</strong>其余代码部分</p><p>需要遵循的原则：</p><p><strong>空闲让进：</strong>临界区空闲时，应允许一个进程访问。</p><p><strong>忙则等待：</strong>临界区正在被访问时，其他试图访问的进程需要等待</p><p><strong>有限等待：</strong>要在有效时间内进入临界区，保证不会饥饿</p><p><strong>让权等待：</strong>进不了临界区的进程，要释放处理机，防止忙等</p><h4 id="2-3-1-1进程互斥的软件实现方法"><a href="#2-3-1-1进程互斥的软件实现方法" class="headerlink" title="2.3.1.1进程互斥的软件实现方法"></a>2.3.1.1进程互斥的软件实现方法</h4><h5 id="单标志法："><a href="#单标志法：" class="headerlink" title="单标志法："></a>单标志法：</h5><p>在进入区只做“检查”，不上锁，在退出区把临界区的使用权转交给另一个进程（相当于在退出区既给另一进程解锁）</p><p><strong>主要问题：</strong>不遵循空闲让进的原则。</p><p>该算法可以实现每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程在某一时刻不在进入临界区，则另一个进程也无法进入临界区（不遵循空闲让进的原则）这样很容易造成资源利用不充分。</p><p><strong>通俗解释：</strong>若P0顺利进入临界区并从临界区离开，则此时临界区是空闲的，但P1并没有进入临界区的打算，而turn&#x3D;1一直成立，则P0就无法再次进入临界区。</p><h5 id="双标志先检查法："><a href="#双标志先检查法：" class="headerlink" title="双标志先检查法："></a>双标志先检查法：</h5><p>在进入区先“检查”后“上锁”，退出区“解锁”（检查对方的标志，设置自己的标志）</p><p><strong>优点：</strong>不用交替进入，可连续使用</p><p><strong>主要问题：</strong>不遵循“忙则等待”原则。</p><p><strong>缺点：</strong>P0和P1可能同时进入临界区。即检查对方标志后和设置自己的标志前可能发生进程切换，结果双方都被检查通过，会同时即进入临界区（不遵循“忙则等待”原则）原因是在于检查对方标志和设置自己标志两个过程不能一气呵成。</p><p><strong>通俗解释：</strong>在进入临界区之后有可能在被上锁之前就会另一个进程可以避过另一个进程进入临界区的锁，直接两个进程全部使用临界资源。</p><h5 id="双标志后检查法："><a href="#双标志后检查法：" class="headerlink" title="双标志后检查法："></a>双标志后检查法：</h5><p>再进区先“加锁”后检查，退出区“解锁”</p><p><strong>主要问题：</strong>不遵循“空闲让进，有限等待”原则，可能导致饥饿</p><p>即两个进程依次设置自己的标志，并依次检查对方的标志，发现对方也想进入临界区，双方都争着进入临界区，结果谁都进不了（违背“空闲让进”原则）于是各进程都长期无法访问临界区而导致“饥饿现象”（违背有限等待原则）</p><p><strong>通俗解释：</strong></p><p>你等我不想进去，我等你不想进去，最后谁都想去，谁也进不去</p><h5 id="peterson算法："><a href="#peterson算法：" class="headerlink" title="peterson算法："></a>peterson算法：</h5><p>在进入区“主动争取，主动谦让，检查对方是否想进，己方是否谦让”</p><p><strong>主要问题：</strong>不遵循“让权等待”原则，会发生忙等</p><p><strong>一般是最后一个表示意愿的就是最终两个人合作的意愿。</strong></p><h4 id="2-3-1-2进程互斥的硬件实现方法"><a href="#2-3-1-2进程互斥的硬件实现方法" class="headerlink" title="2.3.1.2进程互斥的硬件实现方法"></a>2.3.1.2进程互斥的硬件实现方法</h4><h5 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h5><p>使用“开关中断”指令实现</p><p><strong>优点：</strong>简单高效</p><p><strong>缺点：</strong>只适用于单处理机；只适用于操作系统内核进程。</p><p><strong>这种方法的缺点：</strong></p><p>①限制了CPU交替执行程序的能力，因此系统效率会明显降低</p><p>②对内核来说，在它执行更新变量的几条指令期间，关中断时很方便的，但将关中断权限交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p><p>③不适用于多处理器系统，因为在一个CPU上关中断并不能防止进程在其他的CPU上执行相同的临界区代码。</p><h5 id="Test-and-Set-TS-x2F-TSL指令"><a href="#Test-and-Set-TS-x2F-TSL指令" class="headerlink" title="Test and Set(TS&#x2F;TSL指令)"></a>Test and Set(TS&#x2F;TSL指令)</h5><p>old记录是否已经被上锁；</p><p>再将lock设为true；</p><p>检查临界区是否已经被上锁</p><p>（若已上锁，则循环重复前几步）</p><p><strong>优点：</strong>实现简单，适用于多处理器环境</p><p><strong>缺点：</strong>不满足“让权等待”</p><h5 id="Swap指令（XCHG指令）"><a href="#Swap指令（XCHG指令）" class="headerlink" title="Swap指令（XCHG指令）"></a>Swap指令（XCHG指令）</h5><p>逻辑上和上面的指令一样。</p><h5 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h5><p>整型信号量：用一个整数型变量作为信号量，数值表示某种资源数，整型信号量与普通整型变量区别：对信号量只能执行初始化,p,v,两种操作。</p><p>整型信号量的问题：不满足让权等待原则。</p><p>记录型信号量：S.value表示某种资源数，S.L指向等待该资源的队列,</p><p>P操作中一定是先S.value–,之后可能需要执行block原语。</p><p>V操作中一定是先S.value++,之后可能需要执行wake up原语。</p><p>注意要能够自己腿短在什么条件下需要执行block或wake up</p><p>可以用记录型信号量实现系统资源的“申请”和“释放”</p><p>可以用记录型信号量实现进程互斥，进程同步。</p><p>信号量机制实现进程同步互斥和前驱关系</p><h4 id="2-3-1-3进程互斥同步的基本问题"><a href="#2-3-1-3进程互斥同步的基本问题" class="headerlink" title="2.3.1.3进程互斥同步的基本问题"></a>2.3.1.3进程互斥同步的基本问题</h4><h5 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a><strong>实现进程互斥</strong></h5><p>分析问题：确定临界区</p><p>设置互斥信号量：<strong>初值为1</strong></p><p>临界区之前对信号量执行P操作</p><p>临界区之后对信号量执行V操作</p><h5 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a><strong>实现进程同步</strong></h5><p>分析问题：找出哪里需要实现“一前一后”的同步关系</p><p>设置同步信号量，<strong>初始值为0；</strong></p><p>在“前操作”之后执行V操作</p><p>在“后操作”之前执行P操作</p><h5 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h5><p>分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题</p><p>为每对前驱关系设置同步信号量，初值为0</p><p>在“前操作”之后执行V操作</p><p>在“后操作”之前执行P操作</p><p>本质是多级同步问题。</p><p>除了互斥，同步关系之外，还会考察有多个资源的问题，有多少资源就把信号量初值设为多少。申请资源时进行P操作，释放资源时进行V操作即可</p><h3 id="2-3-2常见的几个经典互斥同步问题"><a href="#2-3-2常见的几个经典互斥同步问题" class="headerlink" title="2.3.2常见的几个经典互斥同步问题"></a>2.3.2常见的几个经典互斥同步问题</h3><p>PV操作题目的解题思路</p><p>1.关系分析。找出题目中描述的各个进程，分析他们之间的同步、互斥关系</p><p>2.整理思路。根据各进程的操作流程确定PV操作的大致顺序</p><p>3.设置信号量：设置需要的信号量，并根据题目条件确定信号量初值。（互斥）信号量初值一般为1，同步信号量的初值要看对应资源的初始值是多少。</p><h4 id="2-3-2-1生产者消费者问题"><a href="#2-3-2-1生产者消费者问题" class="headerlink" title="2.3.2.1生产者消费者问题"></a>2.3.2.1生产者消费者问题</h4><p>生产者消费者问题是一个互斥、同步的综合问题</p><p>对于初学者来说最难的是发现题目中隐含的两对同步关系</p><p>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后”问题，因此需要设置两个同步信号量。</p><p><img src="/2025/09/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20240921174455888.png" alt="image-20240921174455888"></p><p>易错点：实现互斥和实现同步的两个P操作的前后顺序（死锁问题）</p><p>自己理解：生产者只有满足缓冲区条件则可以开始生产，如果开始加锁之后在进行生产，又发现无法生产，而消费者也先检查互斥关系的锁导致消费者也没有办法进行消费，这样就既不能生产，也不能消费，死锁形成、</p><h4 id="2-3-2-2多生产者—多消费者问题"><a href="#2-3-2-2多生产者—多消费者问题" class="headerlink" title="2.3.2.2多生产者—多消费者问题"></a>2.3.2.2多生产者—多消费者问题</h4><p>解决”多生产者—多消费者问题”的关键在于理清复杂的同步关系</p><p>在分析同步问题（一前一后）问题的时候不能从单个进程行为的角度来分析要把“一前一后”发生的事看做是两种“事件”的先后关系</p><p>比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：</p><p>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才可以放入水果</p><p>如果盘子里装有橘子，那么一定要女儿取走橘子后父亲或母亲才可以放入水果</p><p>这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系？</p><p>正确的分析方法应该是从“事件”的角度来考虑我们可以把上述四对“进程行为的前后关系”抽象为一对“时间的先后关系”</p><p>盘子变空事件–&gt;放入水果事件“盘子变空事件即可以由儿子引发，也可以由女儿引发</p><p>“放水果事件”既可能是父亲执行，也可能是母亲执行，这样的话，就可以用一个同步信号量解决问题了</p><h4 id="2-3-2-3吸烟者问题"><a href="#2-3-2-3吸烟者问题" class="headerlink" title="2.3.2.3吸烟者问题"></a>2.3.2.3吸烟者问题</h4><p>吸烟者问题可以为我们解决“可以生产多个商品的单生产者”问题提供一个思路</p><p>值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要轮流的在桌子上放上组合1,2,3.注意体会我们是如何用一个整型变量；实现这个“轮流”过程的，若一个生产者要生产多种产品（或者说会引发多种前驱事件）那么各个V操作应该放在格子对应的“事件”发生之后的位置。</p><h4 id="2-3-2-4读者写者问题"><a href="#2-3-2-4读者写者问题" class="headerlink" title="2.3.2.4读者写者问题"></a>2.3.2.4读者写者问题</h4><p>读者–写者问题为我们解决复杂的互斥问题提供了一个参考思路</p><p>其核心思想在于设置一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理</p><p>另外，对count的检查和赋值不能一气呵成导致了一个错误，如果需要实现“一气呵成”，必须要使用互斥信号量。最后，还要认真体会我们是如何解决“写进程饥饿”问题。绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p><h4 id="2-3-2-5哲学家进餐问题"><a href="#2-3-2-5哲学家进餐问题" class="headerlink" title="2.3.2.5哲学家进餐问题"></a>2.3.2.5哲学家进餐问题</h4><p>哲学家进餐问题的关键在于解决进程死锁。</p><p>这些进程之间仅存在互斥关系，但是与之前接触到的互斥关系不同的是，每个</p><p>进程都需要同时执有两个临界资源，因此就有了“死锁”的问题的隐患。</p><p>如果考试中遇到了一个进程需要同时执有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁，可以参考哲学家问题解决死锁的三种思路</p><p><strong>①</strong>五个哲学家只允许四个哲学家拿筷子，第五个哲学家拿筷子时会被阻塞，等禁食的某个哲学家结束进食放下筷子，第五个哲学家才可以不去思考去拿起筷子。</p><p><strong>②</strong>使相邻的奇偶编号哲学家不去同时抢左侧或同时取右侧的一个筷子而造成死锁，只有（会造成无死锁的情况）</p><p><strong>③</strong>当一名哲学家左右两边的筷子都可用时，才允许他抓取筷子，抓筷子的过程中不允许中断，两边筷子全要抓起来。</p><h3 id="2-3-4管程"><a href="#2-3-4管程" class="headerlink" title="2.3.4管程"></a>2.3.4管程</h3><h4 id="2-3-4-1为什么要引入管程？"><a href="#2-3-4-1为什么要引入管程？" class="headerlink" title="2.3.4.1为什么要引入管程？"></a>2.3.4.1<strong>为什么要引入管程？</strong></h4><p>解决信号量机制编程麻烦，易出错的问题。</p><h4 id="2-3-4-2组成"><a href="#2-3-4-2组成" class="headerlink" title="2.3.4.2组成"></a>2.3.4.2组成</h4><p>共享数据结构，对数据结构初始化的语句，一组用来访问数据结构的过程（函数）</p><h4 id="2-3-4-3基本特征"><a href="#2-3-4-3基本特征" class="headerlink" title="2.3.4.3基本特征"></a>2.3.4.3基本特征</h4><p>各外部进程&#x2F;线程只能通过管程提供的特定“入口”才能访问共享数据。</p><p>每次仅允许一个进程在管程内执行某个内部过程</p><h4 id="2-3-4-4补充"><a href="#2-3-4-4补充" class="headerlink" title="2.3.4.4补充"></a>2.3.4.4补充</h4><p>各进程必须互斥访问管程的特性是由编译器实现的可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题。</p><h4 id="2-3-4-5拓展1-用管程解决生产者消费者问题"><a href="#2-3-4-5拓展1-用管程解决生产者消费者问题" class="headerlink" title="2.3.4.5拓展1 用管程解决生产者消费者问题"></a>2.3.4.5拓展1 用管程解决生产者消费者问题</h4><p>引入管程的目的无非就是要更方便地实现进程的互斥和同步</p><p>1.需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</p><p>2.需要在管程中定义用于访问这些共享数据的“入口”–其实是就是一些函数（如生产者，消费者），问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数从缓冲区取出产品</p><p>3.只有通过这些特定的“入口”才能访问共享数据</p><p>4.管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或“线程进入（如生产者，消费者问题中，各进程需要互斥地访问共享缓冲区，管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的。</p><p>5.可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题，可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出入口），可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</p><p>程序员可以用某种特殊的语法定义一个管程（比如monitor .producer,consumer,end monitor)之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步互斥了（封装思想）</p><h2 id="2-4死锁"><a href="#2-4死锁" class="headerlink" title="2.4死锁"></a>2.4死锁</h2><h3 id="2-4-1什么是死锁？"><a href="#2-4-1什么是死锁？" class="headerlink" title="2.4.1什么是死锁？"></a>2.4.1<strong>什么是死锁？</strong></h3><p>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进</p><h3 id="2-4-2死锁、饥饿、死循环的区别"><a href="#2-4-2死锁、饥饿、死循环的区别" class="headerlink" title="2.4.2死锁、饥饿、死循环的区别"></a>2.4.2<strong>死锁、饥饿、死循环的区别</strong></h3><p>死锁：至少是两个进程一起死锁，死锁进程处于阻塞态。</p><p>饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可以是就绪态</p><p>死循环：可能有一个进程陷入死循环，死循环的进程可以上处理机</p><p>死锁和饥饿是操作系统要解决的问题，死循环是应用程序员来解决的</p><h3 id="2-4-3死锁产生的必要条件"><a href="#2-4-3死锁产生的必要条件" class="headerlink" title="2.4.3死锁产生的必要条件"></a>2.4.3<strong>死锁产生的必要条件</strong></h3><p><strong>互斥条件：</strong>对必须互斥使用的资源的争抢才会导致思索</p><p><strong>不剥夺条件：</strong>进程保持的资源只能主动释放，不可强行剥夺</p><p><strong>请求和保持条件</strong>：保持着某些资源不放的同时，请求别的资源</p><p><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，循环等待未必死锁，死锁必然循环等待</p><h3 id="2-4-4什么时候会发生死锁"><a href="#2-4-4什么时候会发生死锁" class="headerlink" title="2.4.4什么时候会发生死锁"></a>2.4.4<strong>什么时候会发生死锁</strong></h3><p>对不可剥夺资源的不合理分配，可能导致死锁</p><h3 id="2-4-5死锁的处理策略"><a href="#2-4-5死锁的处理策略" class="headerlink" title="2.4.5死锁的处理策略"></a>2.4.5<strong>死锁的处理策略</strong></h3><p>预防死锁（破坏死锁产生的四个必要条件）</p><p>避免死锁（避免系统进入不安全状态）</p><p>死锁的检测和解除（允许死锁发生，系统负责检测出死锁后解除）</p><p>预防死锁</p><h4 id="2-4-5-1预防死锁"><a href="#2-4-5-1预防死锁" class="headerlink" title="2.4.5.1预防死锁"></a>2.4.5.1预防死锁</h4><h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><p>将临界资源改造为可共享的资源（如SPOOLing技术）</p><p>缺点：可行性不高，很多时候无法破坏互斥条件</p><h5 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h5><p>方案一：申请的资源得不到满足时，立即释放所拥有的全部资源</p><p>方案二：申请的资源被其他进程占用时，由操作系统协助剥夺资源（考虑优先级）</p><p>缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放资源会导致系统开销大，可能导致饥饿</p><h5 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h5><p>运行前分配好所有需要的资源，之后一直保持。</p><p>缺点：资源利用率低；可能导致饥饿</p><h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><p>给资源编号，必须按照编号从小到大的顺序申请资源</p><p>缺点；不方便添加新设备，会导致资源浪费用户编程困难。</p><h4 id="2-4-5-2避免死锁"><a href="#2-4-5-2避免死锁" class="headerlink" title="2.4.5.2避免死锁"></a>2.4.5.2避免死锁</h4><p><strong>银行家算法</strong></p><p>数据结构：</p><p>长度为m的一维数组Available表示还有多少可有资源</p><p>n*m矩阵Max代表各进程对资源的最大需求数</p><p>n*m矩阵Allocation表示已经给各进程分配了多少资源</p><p>Max-Allocation&#x3D;Need矩阵表示各进程最多还需要多少资源</p><p>用长度为N的一位数组request表示进程此次申请的各种资源数。</p><p>银行家算法步骤</p><p>①检查此次申请是否超过了之前声明的最大需求数。</p><p>②检测此时系统剩余的可用资源是否还能满足这次请求。</p><p>③试探着分配，更改数据结构</p><p>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p>安全型算法步骤：</p><p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程持有的资源全部回收</p><p>不断重复上述过程，看最终是否能让所有进程都加入安全序列</p><p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态，系统处于安全 状态一定不会产生死锁。</p><h4 id="2-4-5-3死锁的检测和解除"><a href="#2-4-5-3死锁的检测和解除" class="headerlink" title="2.4.5.3死锁的检测和解除"></a>2.4.5.3死锁的检测和解除</h4><p><strong>如何检测：</strong></p><p><strong>数据结构（资源分配图）</strong></p><p>两种节点：进程节点，资源节点</p><p>两种边：进程节点-&gt;资源节点（请求边），资源节点-&gt;进程节点（分配边）</p><p><strong>死锁检测算法</strong>：依次消除与不阻塞进程相连的边，知道无边可消</p><p>注：所谓不阻塞进程是指其申请的资源数不足够进程</p><p><strong>死锁定理</strong>：若资源分配图是不可完全简化的，说明发生了死锁（题中会给出资源分配图）</p><p>不过也要小心与数据及结构结合考察</p><p><strong>如何解除死锁：</strong></p><p>资源剥夺法，撤销进程法（终止进程法）进程回退法</p><h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><h2 id="3-1内存管理"><a href="#3-1内存管理" class="headerlink" title="3.1内存管理"></a>3.1内存管理</h2><h3 id="3-1-1内存管理的基本原理和要求"><a href="#3-1-1内存管理的基本原理和要求" class="headerlink" title="3.1.1内存管理的基本原理和要求"></a>3.1.1内存管理的基本原理和要求</h3><h4 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h4><p><strong>什么是内存，有何作用？</strong></p><p>存储单元，内存地址的概念和联系。</p><p>按字节编址vs按字编址</p><p>指令的工作原理 操作码+若干参数（可能包含地址参数）</p><p>逻辑地址（相对地址）vs物理地址（绝对地址）</p><p><strong>从写程序到程序运行</strong></p><p>编译源代码文件</p><p>编译：由源代码文件生成目标模块（高级语言“翻译”为机器语言）</p><p>链接：由目标模块生成装入模块，链接后形成完整的逻辑地址</p><p>装入：将装入模块装入内存，装入后形成物理地址</p><p><strong>三种链接方式</strong></p><p>静态链接：装入前连接成一个完整装入模块</p><p>装入时动态链接：运行前边链接边装入</p><p>运行时动态链接：运行时需要目标模块才装入并链接</p><p><strong>三种装入方式</strong></p><p>绝对装入：编译时产生绝对地址</p><p>可重定位装入：装入时将编辑地址转换为物理地址</p><p>动态运行时装入：运行时将逻辑地址转换成物理地址，需重新设置重定位寄存器。。</p><h4 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h4><p><strong>内存空间的分配与回收</strong></p><p><strong>内存空间的扩充（实现虚拟性）</strong></p><p><strong>地址转换</strong></p><p>操作系统负责实现逻辑地址到物理地址的转换</p><p>三种方式：</p><p>绝对装入：编译器负责地址转换（单道程序阶段，无操作系统）</p><p>可重定位装入：装入程序负责地址转换（早期多道批处理阶段）</p><p>动态运行时装入：运行时才进行地址转换（现代操作系统)</p><p><strong>存储保护</strong></p><p>保证各进程在自己的内存空间的运行，不会越界访问</p><p>两种方式：设置上下限寄存器</p><p>利用重定位寄存器（基址寄存器），界地址寄存器（限长寄存器）进行判断</p><h4 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a><strong>进程的内存映像</strong></h4><img src="/2025/09/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/微信图片_20240928173202.jpg" alt="微信图片_20240928173202" style="zoom: 33%;"><h4 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h4><p><strong>一个固定区：</strong>存放最活跃的程序段，<strong>固定区中的程序段在运行过程中不会调入调出</strong></p><p><strong>若干覆盖区：</strong>不可能同时被访问程序段可共享一个覆盖区，<strong>覆盖区中的程序段在运行过程中会根据需要调入调出</strong></p><p>必须由<strong>程序员声明</strong>覆盖结构，操作系统完成自动覆盖</p><p><strong>缺点：</strong>对用户不透明，增加了用户编程负担</p><p><strong>交换技术</strong></p><p>内存紧张时，换出某些进程以腾出内存空间，再换入某些进程</p><p>磁盘分为文件区和对换区换出的进程放在对换区</p><p><strong>覆盖与交换的区别</strong></p><p>覆盖是在同一个程序或进程中的</p><p>交换是在不同进程或作业之间的。</p><h3 id="3-1-2连续分配管理方式"><a href="#3-1-2连续分配管理方式" class="headerlink" title="3.1.2连续分配管理方式"></a>3.1.2连续分配管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>只支持单道程序，内存分为系统区和用户区，用户程序放在用户区，（无外部碎片，有内部碎片）</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业（无外部碎片，有内部碎片）</p><p>两种分区方式分区大小相等，分区大小不等。</p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>支持多道程序，在进程装入内存时，根据进程大小动态地建立分区</p><p>（无内部碎片，有外部碎片）</p><p>外部碎片可用“紧凑”技术来解决</p><p>回收内存分区时，可能遇到四种情况（总之相邻的空闲分区要合并）</p><ol><li>回收区之后有相邻的空闲分区</li><li>回收区前、后都有相邻的空闲分区</li><li>回收区之前有相邻的空闲分区</li><li>回收区前后没有相邻的空闲分区</li></ol><p><strong>动态适应算法</strong></p><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应算法</td><td>从头到尾找合适的分区</td><td>空闲分区以地址递增的次序排列</td><td>综合看性能最好，算法开销小，回收分区一般不需要对空闲分区队列进行重新排序</td><td>无明显缺点</td></tr><tr><td>最佳适应算法</td><td>优先使用更小的分区，以保留更多的大分区</td><td>空闲分区按容量递增的次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区对队列进行重新排序</td></tr><tr><td>最坏适应算法</td><td>优先使用更大的分区，以防止太小的不可用的碎片</td><td>空闲分区按容量递减的次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区进程容易被用完，不利于大进程；算法开销大（原因同上）</td></tr><tr><td>邻近适应算法</td><td>由首次适应算法演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增的次序排列</td><td>不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应算法）</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h3 id="3-1-3基本分页存储管理"><a href="#3-1-3基本分页存储管理" class="headerlink" title="3.1.3基本分页存储管理"></a>3.1.3基本分页存储管理</h3><h4 id="基本分页存储管理的基本概念"><a href="#基本分页存储管理的基本概念" class="headerlink" title="基本分页存储管理的基本概念"></a>基本分页存储管理的基本概念</h4><p><strong>基本分页存储管理的思想：</strong>把进程分页，各个页面可离散地放到各个内存块中。</p><p><strong>易混概念</strong>：“页框，页帧，内存块，物理块，物理页”VS“页，页面”</p><p>​                    “页框号，页帧号，内存块号，物理块号，物理页号”vs“页号，页面号”</p><p><strong>页表：</strong>页表记录了页面和实际存放的内存块之间的映射关系</p><p>一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成</p><p>每个页表项的大小是相同的，页号是“隐含的”<br>$$<br>i号页表项存放地址&#x3D;页表始址+i*页表项大小<br>$$<br><strong>逻辑地址结构</strong>（可拆分为页号P页内偏移量w）<br>$$<br>页号&#x3D;逻辑地址&#x2F;页面大小<br>$$</p><p>$$<br>页内偏移量&#x3D;逻辑地址mod页面大小<br>$$<br>如果页面大小刚好是2的整数次幂呢！</p><p>这样就可以根据二进制原理对应前多少位为页号，后多少位为页内偏移量。</p><p><strong>如何实现地址转换</strong></p><ol><li>计算出逻辑地址对应的【页号，页内偏移量】</li><li>找到对应页面在内存中的存放位置（查页表）</li><li>找到物理地址&#x3D;页面始址+页内偏移量</li></ol><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><h5 id="页面寄存器的作用："><a href="#页面寄存器的作用：" class="headerlink" title="页面寄存器的作用："></a><strong>页面寄存器的作用：</strong></h5><h5 id="存放页表起始地址，存放页表长度"><a href="#存放页表起始地址，存放页表长度" class="headerlink" title="存放页表起始地址，存放页表长度"></a><strong>存放页表起始地址，存放页表长度</strong></h5><h5 id="地址变换过程："><a href="#地址变换过程：" class="headerlink" title="地址变换过程："></a><strong>地址变换过程：</strong></h5><ol><li>根据逻辑地址算出页号、页内偏移量</li><li>页号的合法性检查（与页表长度对比）</li><li>若页号合法，再根据页表起始地址、页号找到对应页表项。</li><li>根据页表项中记录的内存块号，页内偏移量得到最终的物理地址</li><li>访问物理内存对应的内存单元</li></ol><h5 id="其他小细节"><a href="#其他小细节" class="headerlink" title="其他小细节"></a><strong>其他小细节</strong></h5><p>页内偏移量位数与页面大小之间的关系（要能用其中一个条件推出另一个条件）</p><p>页式管理地址是一维的</p><p>实际应用中，通常使一个页框恰好能放入整个页表项</p><p>为了方便找到页表项，页表一般是放在连续的内存块中</p><h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a><strong>具有快表的地址变换机构</strong></h4><ol><li>算页号，页内偏移量</li><li>检查页号合法性</li><li>查快表。若命中，即可知道页面存放的内存块号，可直接进行5操作；若未命中则进行4</li><li>查页表，找到页面存放的内存块号并且将页表项复制到快表中</li><li>根据内存块号与页面的偏移量得到物理地址</li><li>访问目标内存单元</li></ol><p>TLB与普通Cache的区别：</p><p>TLB只有页表项的副本，而普通Cache可能有各种数据副本。</p><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><p><strong>单级页表存在的问题：</strong></p><p>所有页表项必须连续存放，页表过大时需要很大的连续空间</p><p>在一段时间内并非连续的所有页面都用得到，因此没有必要让整个页表常驻内存</p><p><strong>两级页表</strong></p><p>将长长的页表再分页。<br>$$<br>逻辑地址结构：（一级页号、二级页号、页内偏移量）<br>$$<br>注意几个术语:页目录表&#x2F;外层页表&#x2F;顶级页表</p><p>要能根据逻辑地址位数，页面大小，页表项大小，可以通过一个页表能容纳多少个页表项确定一级页表的位数。确定多级页表的逻辑地址结构。</p><p><strong>如何实现地址变换</strong></p><ol><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB中读出页目录表始址，根据一级页表查页目录表，找到下一级页表在内存中存放的位置</li><li>根据二级页号查表，找到最终想要访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ol><p><strong>几个细节</strong></p><p>多级页表中各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级</p><p>多级页表的访存次数（假设没有快表机构）–N级页表访问一个逻辑地址需要N+1次访存。</p><h3 id="3-1-4基本分段存储管理"><a href="#3-1-4基本分段存储管理" class="headerlink" title="3.1.4基本分段存储管理"></a>3.1.4基本分段存储管理</h3><p><strong>分段：</strong></p><p>将地址空间按照程序自身的逻辑关系划分为若干个段，每段从0开始编址</p><p>每个段在内存中占据连续空间，但各段之间可以不相邻</p><p>逻辑地址结构：（段号，段内地址）</p><p><strong>段表：</strong></p><p>记录逻辑段到实际存储地址的映射关系</p><p>每个段对应一个段表项各段表项长度相同，由段号（隐含），段长，基址组成</p><p><strong>地址变换：</strong></p><ol><li>由逻辑地址得到段号，段内地址</li><li>段号与段表寄存器中的段长度比较，检查是否越界</li><li>由段表始址，段号找到对应段表项</li><li>根据段表中记录的段长，检查段内地址是否越界</li><li>由段表中的“基址+段内地址”得到最终的物理地址</li><li>访问目标单元</li></ol><p><strong>分段vs分页</strong></p><ol><li>分页的页面长度相同，分段的页面长度不同</li><li>分页对于用户不可见，分段对于用户可见</li><li>分页的地址是一维的，分段的地址是二维的</li><li>分段更容易实现信息的共享和保护（纯代码，可重入代码，可共享）</li><li>分页（单级页表），分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构</li></ol><h3 id="3-1-5段页式管理"><a href="#3-1-5段页式管理" class="headerlink" title="3.1.5段页式管理"></a>3.1.5段页式管理</h3><p><strong>分段+分页</strong></p><p>将地址空间按照程序的自身逻辑关系划分为若干段，再将各段分为大小相等的页面</p><p>将内存空间分为与页面相等的一个个内存块，系统以块为单位为进程分配内存<br>$$<br>逻辑地址&#x3D;（段号，页号，页内偏移量）<br>$$<br><strong>段表，页表</strong></p><p>每个段对应一个段表项，各段表项长度相同，由段号（隐含）页表长度，页表存放地址组成</p><p>各个页对应一个页表项，各页表项长度相同，由页号（隐含）页面存放那个的内存块号组成</p><p><strong>地址变换</strong></p><ol><li>由逻辑地址得到段号、页号、页内偏移量</li><li>段号与段表寄存器中的段长度比较，检查是否越界</li><li>由段表始址、段号找到对应段表项</li><li>根据段表中记录的页面长度，检查页号是否越界</li><li>由段表中的页表地址、页号得到查询页表，找到对应页表项</li><li>由页面存放的内存块号、页内偏移量得到最终的物理地址</li><li>访问目标单元</li></ol><p><strong>访问一个逻辑地址所需的访存次数</strong></p><p>第一次：查段表，第二次：查页表，第三次：访问目标单元</p><p>可引入快表机构，以段号和页号为关键字查询快表，即可找到最终的目标页面，存放位置、引入快表后仅需要一次访存。</p><h2 id="3-2虚拟内存"><a href="#3-2虚拟内存" class="headerlink" title="3.2虚拟内存"></a>3.2虚拟内存</h2><h3 id="3-2-1虚拟内存的基本概念"><a href="#3-2-1虚拟内存的基本概念" class="headerlink" title="3.2.1虚拟内存的基本概念"></a>3.2.1虚拟内存的基本概念</h3><h4 id="3-2-1-1传统存储管理方式的特征（缺点）"><a href="#3-2-1-1传统存储管理方式的特征（缺点）" class="headerlink" title="3.2.1.1传统存储管理方式的特征（缺点）"></a><strong>3.2.1.1传统存储管理方式的特征（缺点）</strong></h4><p>一次性：作业数据必须一次全部调入内存</p><p>驻留性：作业数据在整个运行期间都会常驻内存</p><h4 id="3-2-1-2局部性原理"><a href="#3-2-1-2局部性原理" class="headerlink" title="3.2.1.2局部性原理"></a><strong>3.2.1.2局部性原理</strong></h4><p><strong>时间局部性：</strong>现在访问的指令，数据在不久之后很可能会被再次访问。</p><p><strong>空间局部性：</strong>现在访问的内存单元周围的内存单元，很可能在不久后会被访问。</p><p><strong>高速缓存技术：</strong>使用频繁的数据放到更高速的存储器中。</p><h4 id="3-2-1-3虚拟内存的定义和特征"><a href="#3-2-1-3虚拟内存的定义和特征" class="headerlink" title="3.2.1.3虚拟内存的定义和特征"></a><strong>3.2.1.3虚拟内存的定义和特征</strong></h4><p><strong>定义：</strong>程序不需要全部装入即可运行，运行时根据需要动态调入数据。若内存不够，还需换出一些数据。</p><p><strong>特征：</strong></p><p><strong>多次性：</strong>无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</p><p><strong>对换性：</strong>无需在作业运行时一直常驻内存，而是允许在作业运行过程中，讲作业换入换出。</p><p><strong>虚拟性：</strong>从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量</p><h4 id="3-2-1-4如何实现虚拟内存技术"><a href="#3-2-1-4如何实现虚拟内存技术" class="headerlink" title="3.2.1.4如何实现虚拟内存技术"></a>3.2.1.4如何实现虚拟内存技术</h4><p>访问的信息不在内存中，由操作系统负责将所需信息，从外存调入内存（请求调页功能）。</p><p>内存空间不够，将内存中暂时用不到的信息换出内存（页面置换功能）</p><p><strong>虚拟内存的实现：</strong></p><p>请求分页存储管理、请求分段存储管理、请求段页式存储管理。</p><h3 id="3-2-2请求分页管理方式"><a href="#3-2-2请求分页管理方式" class="headerlink" title="3.2.2请求分页管理方式"></a>3.2.2请求分页管理方式</h3><p><strong>页表机制：</strong>在基本分页的基础上增加了几个表项</p><p><strong>状态位：</strong>标识页面是否已在内存中</p><p><strong>访问字段：</strong>记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考。</p><p><strong>修改位：</strong>表示页面调入内存后是否被修改过，只有修改过的页面才在需要置换时写入外存。</p><p><strong>外存地址：</strong>页面在外存中存放的位置</p><p><strong>缺页中断机构</strong></p><p>找到页表项后检查页面是否已在内存，若没有在内存中，则产生缺页中断</p><p>缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面，缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常，一条指令在执行过程中可能产生多次缺页中断</p><p><strong>地址变换机构（重点关注与基本分页不同的地方）</strong></p><p>找到页表项是需要检查页面是否在内存中。</p><p>若页面不在内存中，需要请求调页。</p><p>若内存空间不够，还需换出页面</p><p>页面调入内存中后，需要修改相应页表项</p><p><img src="/2025/09/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20241005105926343.png" alt="image-20241005105926343"></p><h3 id="3-2-3页框分配"><a href="#3-2-3页框分配" class="headerlink" title="3.2.3页框分配"></a>3.2.3页框分配</h3><p>**驻留集:**指的是请求分页存储管理中给进程分配的内存块的集合</p><p><strong>页面分配置换策略：</strong></p><p><strong>固定分配VS可变分配</strong>：区别在于进程运行期间驻留集大小是否可变</p><p><strong>局部置换VS全局置换：</strong>区别在于发生缺页时是否只能从进程自己的页面中选择一个换出</p><p><strong>固定分配局部置换：</strong>进程运行前就分配一定数量物理块，缺页时只能换出进程自己的某一页</p><p><strong>可变分配全局置换：</strong>只要缺页就分配新物理块，可能来自空闲物理块，也可能需换出别的进程页面</p><p>**可变分配局部置换:**频繁缺页的进程，多分配一些物理块；缺页率很低的进程，回收一些物理块，直到缺页率合适</p><p><strong>何时调入页面：</strong></p><p><strong>预调页策略：</strong>一般用于进程运行前</p><p><strong>请求调页策略：</strong>进程运行时，发现缺页再调页</p><p><strong>从何处调页：</strong></p><p><strong>对换区：</strong>采用连续存储方式，速度更快；文件区—采用离散存储方式，速度更慢</p><p><strong>对换区足够大：</strong>运行将数据从文件区复制到对换区，之后所有的页面调入调出，都是在内存与对换区之前进行。</p><p><strong>对换区不够大：</strong>不会修改的数据每次都从文件区调入；会修改的数据调出到对换区，需要时再从对换区调入。</p><p><strong>Unix方式：</strong>第一次使用的页面都从文件区调入调出的页面都写会对换区，再次使用时从对换区调入。</p><p><strong>抖动颠簸现象：</strong>页面频繁换入换出的现象。主要原因是分配给进程的物理块不够</p><p><strong>工作集：</strong>在某段时间间隔里；进程实际访问页面的集合。驻留集大小一般不能小于工作集大小</p><h3 id="3-2-4页面置换算法"><a href="#3-2-4页面置换算法" class="headerlink" title="3.2.4页面置换算法"></a>3.2.4页面置换算法</h3><table><thead><tr><th>算法</th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单，但性能很差，可能出现贝拉迪异常</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问的的页面</td><td>性能很好，但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK(NRU)</td><td>循环扫描各页面，第一轮访问淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1，若第一轮未选中，则进行第二轮扫描</td><td>实现简单，算法开销小。但未考虑页面是否被修改</td></tr><tr><td>改进型CLOCK(改进型NRU)</td><td>若用（访问位，修改位）的形式表述，第一轮淘汰（0,0），第二轮淘汰（0,1），并将扫描过的页面访问位都置为0，第三轮淘汰（1,0），第四轮淘汰（1,1）（优先级）</td><td>算法开销小，性能也不错</td></tr></tbody></table><h3 id="3-2-5内存映射文件"><a href="#3-2-5内存映射文件" class="headerlink" title="3.2.5内存映射文件"></a>3.2.5内存映射文件</h3><p><strong>特性：</strong>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间，以访问内存的方式读写文件。进程关闭文件时，操作系统负责将文件数据写回磁盘，以解除内存映射，多个进程可以映射同一个文件，方便共享。</p><p><strong>优点：</strong>程序员编程更简单，已建立映射的文件，只需访问内存的方式读写即可。文件数据的读入写出完全由操作系统负责优化。</p><h1 id="第四章-文件"><a href="#第四章-文件" class="headerlink" title="第四章 文件"></a>第四章 文件</h1><h2 id="4-1文件系统基础"><a href="#4-1文件系统基础" class="headerlink" title="4.1文件系统基础"></a>4.1文件系统基础</h2><h3 id="①文件管理"><a href="#①文件管理" class="headerlink" title="①文件管理"></a>①文件管理</h3><p><strong>文件的定义：</strong>一组有意义的信息的集合。</p><p><strong>文件的属性：</strong>文件名，标识符，类型，位置，大小，保护信息</p><p>文件内部应该如何被组织起来（文件的逻辑结构）</p><p>文件之间该如何被组织起来（目录结构）</p><p>操作系统应向上提供哪些功能（create,delete,open,close,read,write系统调用）</p><p>文件应如何存放在外存中（文件的物理结构）</p><p>操作系统如何管理外存中的空闲块（存储空间的管理）</p><p>操作系统需要提供的其他文件管理功能（文件共享，文件保护）</p><h3 id="②有结构文件"><a href="#②有结构文件" class="headerlink" title="②有结构文件"></a>②有结构文件</h3><p><strong>顺序文件</strong></p><p>串结构：记录顺序与关键字无关。</p><p>顺序结构：记录按关键字顺序排列</p><p>可变长记录的顺序文件无法实现随机存取，定长记录可以。（可变长记录的顺序文件在每次查询时只能从头一次查找）</p><p>定长记录、顺序结构的顺序文件可以快速检索（根据关键字可快速找到记录）</p><p>最大缺点：不方便增加&#x2F;删除记录。</p><p><strong>索引文件</strong></p><p>建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加&#x2F;删除记录。</p><p>索引表本身就是定长记录的顺序文件，一个索引表项就是一条定长记录，因此索引文件可支持随机存取。</p><p>若索引表按关键字顺序排列，则可支持快速检索</p><p>解决了顺序文件不方便增删记录的问题，同时让不定长记录的文件实现了随机存取，但索引表可能占用很多空间。</p><p><strong>索引顺序文件</strong></p><p>将记录分组，每组对应一个索引表项</p><p>检索记录时先顺序查索引表，找到分组，再顺序查找分组（会 查 ，计算平均查找次数）</p><p>当记录过多时，可建立多级索引表。</p><h3 id="③文件的基本操作"><a href="#③文件的基本操作" class="headerlink" title="③文件的基本操作"></a>③文件的基本操作</h3><p><strong>创建文件：</strong>分配外存空间，创建目录项</p><p><strong>删除文件：</strong>回收外存空间，删除目录项</p><p><strong>打开文件：</strong></p><p>将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户，打开文件后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作。</p><p>每个进程有自己的打开文件表，系统中也有一张总的打开文件表，进程打开文件表中特有的属性，读写指针，访问权限（只读？读写?)</p><p>系统打开文件表中特有的属性：打开计数器（有多少个进程打开了该文件）</p><p>**关闭文件:**将进程打开文件表中的相应表项删除，系统打开文件表的打开计数器减，若打开计数器为，则删除系统表的表项</p><p><strong>读文件：</strong>根据读指针、读入数据量，内存位置将文件数据从外存读入内存</p><p><strong>写文件：</strong>根据写指针，写出数据量，内存位置将文件数据从内存写出外存</p><p><em><strong>“读写文件”用“文件描述符”即可，指明文件，不再需要用到“文件名”</strong></em></p><p><em><strong>打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”</strong></em></p><h3 id="④文件的物理结构"><a href="#④文件的物理结构" class="headerlink" title="④文件的物理结构"></a>④文件的物理结构</h3><p><strong>连续分配（总结）</strong></p><p><strong>连续分配</strong>方式要求<strong>每个文件在磁盘上占有一组连续的块</strong></p><p><strong>优点：</strong>支持顺序访问和直接访问（即随机访问），连续分配的文件在顺序访问时速度最快</p><p><strong>缺点：</strong>不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p><p><strong>链接分配（总结）</strong></p><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显示连接两种。</p><p><strong>隐式链接</strong>—除文件的最后一个盘块之外，每个盘块中都存在指向下一个盘块的指针。文件目录包含文件第一块的指针和最后一块的指针</p><p><strong>优点：</strong>很方便文件拓展，不会有碎片问题，外存利用率高</p><p><strong>缺点：</strong>只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针，也需要耗费少量的存储空间</p><p><em><strong>（考试题目中遇到未指明隐式&#x2F;显式的“链接分配，默认指的是隐式链接的链接分配）</strong></em></p><p><strong>显式链接：</strong>把用于链接文件各物理块的指针显式的存放在一张表中，即文件分配表（FAT，File Allocation Table)一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><p><strong>优点：</strong>很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</p><p><strong>缺点：</strong>文件分配表的需要占有一定的存储空间</p><p>​</p><p><strong>索引分配（总结）</strong></p><p><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中<strong>记录了文件的各个逻辑块所对应的物理块</strong>（索引表的功能类似与内存管理中的页表–建立逻辑页面到物理页面的映射关系），索引表的存放的磁盘块称为索引块，文件数据存放的磁盘块称为<strong>数据块。</strong></p><p>若文件太大、索引表项太多，可以采取以下三种方法解决：</p><p>①</p><p><strong>链接方案：</strong>如果索引表太大，一个索引块装不下，那么可以将多个索引块连接起来存放。</p><p><strong>缺点：</strong>若文件很大，索引表很长，就需要将很多个索引块连接起来，想要找到i号索引块，必须献一次读入0-i-1号索引块，这就导致磁盘I&#x2F;O次数过多，查找效率低下</p><p>②</p><p><strong>多层索引：</strong>建立多层索引（<strong>原理类似于多级页表</strong>）是第一层索引块指向第二层的索引块。还可以根据文件大小的的要求在建立第三层，第四层索引块。采用K层索引结构，且<strong>顶级索引表未调入内存</strong>，则访问一个数据块只需要K+1次读磁盘操作。<strong>缺点：</strong>即便是小文件，访问一个数据块依然需要K+1次读磁盘</p><p>③</p><p><strong>混合索引：</strong>多次索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<strong>直接地址索引</strong>（直接指向数据块），有包含<strong>一级间接索引</strong>（指向单层索引表），还包含<strong>两级间接索引</strong>（指向两层索引表）</p><p><strong>优点：</strong>对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><p><strong>超级超级超级重要考点：</strong>①要会根据多层索引，混合索引的结构计算出文件的最大长度（<strong>KEY：</strong>各级索引表最大不能超过一个块）②要能分析访问某个数据块所需要的读磁盘次数（<strong>KEY：</strong>FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块，每次读入下一级的索引块都需要一次读磁盘操作，另外，要注意题目条件–<strong>顶级索引块是否已经调入内存</strong>）</p><h4 id="顺序分配，链接分配与索引分配"><a href="#顺序分配，链接分配与索引分配" class="headerlink" title="顺序分配，链接分配与索引分配"></a>顺序分配，链接分配与索引分配</h4><table><thead><tr><th>分配方式</th><th>how?</th><th>目录项内容</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>顺序分配</td><td>为文件分配的必须是连续的磁盘块</td><td>起始块号，文件长度</td><td>顺序存取速度快，支持随机访问</td><td>会产生碎片，不利于文件拓展</td></tr><tr><td>隐式链接</td><td>读文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针</td><td>起始块号，结束块号</td><td>可解决碎片问题，外存利用率高，文件拓展实现方便</td><td>只能顺序访问，不能随机访问</td></tr><tr><td>显式链接</td><td>建立一张文件分配表（FAT），显式记录盘块的先后关系（开机后FAT常驻内存）</td><td>起始块号</td><td>除了拥有隐式链接的优点之外，还可以通过查询内存中的FAT实现随机访问</td><td>FAT需要占用一定的存储空间</td></tr><tr><td>索引分配</td><td>为文件数据块建立索引表，若文件太大，可采用连接方案，多层索引，混合索引</td><td>连接方案记录的是第一个索引块的块号，多层混合索引记录的是顶级索引号的块号</td><td>支持随机访问，易于实现文件的拓展</td><td>索引表需要占用一定的存储空间访问数据块前需要读入索引块。若采用链接方案，查找索引块时需要很多次读磁盘操作</td></tr></tbody></table><h3 id="逻辑结构VS物理结构"><a href="#逻辑结构VS物理结构" class="headerlink" title="逻辑结构VS物理结构"></a>逻辑结构VS物理结构</h3><p><strong>逻辑结构：</strong>用户（文件创建者）的视角看到的样子，在用户看来，整个文件占有连续的逻辑地址空间文件内部的信息组织完全由用户自己决定，操作系统并不关心。</p><p><strong>物理结构：</strong>由操作系统决定文件采用什么物理结构存储，操作系统负责将逻辑地址转变为（逻辑块号，块内偏移量）的形式，并负责实现逻辑块号到物理块号的映射。</p><h2 id="4-2目录"><a href="#4-2目录" class="headerlink" title="4.2目录"></a>4.2目录</h2><h3 id="4-2-1文件目录"><a href="#4-2-1文件目录" class="headerlink" title="4.2.1文件目录"></a>4.2.1文件目录</h3><p><strong>文件目录的实现：</strong></p><p>一个文件对应一个FCB，1个FCB就是一个目录项，多个FCB组成文件目录</p><p>对目录的操作：搜索，创建文件，删除文件，显示文件，修改文件</p><p><strong>目录结构：</strong></p><p><strong>单级目录结构：</strong>一个系统只有一张目录表，不允许文件重名。</p><p><strong>两级目录结构：</strong>不同用户的文件可以重名，但不能对文件进行分类</p><p><strong>多级目录结构（树形）：</strong></p><p>不同目录下的文件可以对文件进行分类，不方便文件共享</p><p>系统根据“文件路径”找到目标文件</p><p>从根目录出发的路径是“绝对路径”</p><p>从当前目录出发的路径是“相对路径”</p><p><strong>无环图目录结构：</strong></p><p>在树形目录结构的基础上，增加一些指向同一节点的有向性，使整个目录称为一个有向无环图</p><p>为共享节点设置一个共享计数器，计数器为0时才真正删除节点</p><p>索引节点：除了文件名之外的所有信息都放到索引节点中，每个文件对应一个索引节点，目录项中只包含文件名，索引节点指针，因此每个目录项的长度大幅减少，由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时的磁盘I&#x2F;O的次数就少了很多。</p><h3 id="4-2-2文件共享"><a href="#4-2-2文件共享" class="headerlink" title="4.2.2文件共享"></a>4.2.2文件共享</h3><p><strong>硬链接：</strong></p><p>各个用户的目录项指向同一个索引节点，索引节点中需要有链接计数count，某用户想删除文件时，只是删除该文件的目录项，且count–，只有count&#x3D;&#x3D;0时才能真正删除文件数据和索引节点，否则会导致指针悬空</p><p><strong>软链接：</strong></p><p>在一个Link型的文件中记录共享文件的存放路径（windows快捷方式）操作系统根据路径一层层查找目录，最终找到共享文件。即使软链接指向的共享文件已被删除，link型文件依然存在，只是通过Link型文件中的路径会查找共享文件会失败（找不到对应目录项），由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O.</p><h3 id="4-2-3文件保护"><a href="#4-2-3文件保护" class="headerlink" title="4.2.3文件保护"></a>4.2.3文件保护</h3><p><strong>口令保护:</strong></p><p>为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确，实现开销小，但“口令”一般存放在FCB或索引节点中（也就是存放在系统中）因此不太安全。</p><p><strong>加密保护：</strong></p><p>用一个“密码”对文件加密，用户想要访问文件时，需要提供相同的“密码”才能正确的解密。</p><p>安全性高，但加密&#x2F;解密需要耗费一定的时间。</p><p><strong>访问控制：</strong></p><p>用一个访问控制表（ACL)记录各个用户（或各组用户）时文件的访问权限，对文件的访问类型可以分为读写执行删除等。实现灵活，可以实现复杂的文件保护功能。</p><p><strong>如果对于某个记录进行了访问控制，那也要对目录下的所有文件进行相同的访问权限控制。</strong></p><h2 id="4-3文件层次结构"><a href="#4-3文件层次结构" class="headerlink" title="4.3文件层次结构"></a>4.3文件层次结构</h2><h3 id="文件层次结构"><a href="#文件层次结构" class="headerlink" title="文件层次结构"></a>文件层次结构</h3><ol><li>用户需要通过操作系统提供的借口发出上述请求——<strong>用户接口。</strong></li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——<strong>文件目录结构</strong></li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——<strong>存取控制模块（存取控制验证层）</strong></li><li>验证用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——<strong>逻辑文件系统与文件信息缓冲区</strong></li><li>知道了目标记录对应的逻辑地址后，还需要转化成实际的物理地址——<strong>物理文件系统</strong></li><li>要删除这条记录，必定要对磁盘设备发出请求——<strong>设备管理程序模块</strong></li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——<strong>辅助分配模块</strong></li></ol><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p><strong>存储空间的划分与初始化</strong></p><p>文件卷（逻辑卷），目录区，文件区的概念</p><p>目录区包含文件目录，空闲区，位示图，超级块等用于文件管理的数据</p><p><strong>空闲表法</strong></p><p>空闲表中记录每个连续空闲区的起始盘块号，盘块数。</p><p>分配时可采用<strong>首次适用，最佳适应</strong>等策略；回收时注意表项的合并问题</p><p><strong>空闲链表法</strong></p><p><strong>空闲盘块链：</strong>以盘块为单位组成一条空闲链。分配时从链头依次取出空闲块，回收时将空闲块查到链尾，以盘区为单位组成一条空闲链。</p><p>**空闲盘区链:**分配可采用首次适应，最佳适应等策略；回收时注意相邻空闲盘区合并的问题。</p><p><strong>位示图法：</strong></p><p>一个二进制位对应一个盘块（字号，位号）或（行号，列号）与盘块号一一对应，</p><p><strong>重要考点：</strong>要能够自己推出盘块号——&gt;（字号，位号）之间的相互转换公式。</p><p>需要注意的题目条件：二进制011到底哪个代表空闲，哪个代表不空闲，字号、位号、盘块号到底是从0开始，还是从1开始</p><p>成组链接法：UNIX采用的策略，适合大型文件系统，理解即可，不方便用文字描述的知识点也很难作为考题。</p><h1 id="第五章-输入输出I-x2F-O管理"><a href="#第五章-输入输出I-x2F-O管理" class="headerlink" title="第五章 输入输出I&#x2F;O管理"></a>第五章 输入输出I&#x2F;O管理</h1><h2 id="5-1-I-x2F-O管理概述"><a href="#5-1-I-x2F-O管理概述" class="headerlink" title="5.1 I&#x2F;O管理概述"></a>5.1 I&#x2F;O管理概述</h2><h3 id="5-1-1I-x2F-O设备"><a href="#5-1-1I-x2F-O设备" class="headerlink" title="5.1.1I&#x2F;O设备"></a>5.1.1I&#x2F;O设备</h3><p><strong>什么是I&#x2F;O设备？</strong></p><p>将数据Input&#x2F;Output(输入&#x2F;输出)计算机的外部设备</p><p><strong>按使用特性分类：</strong></p><p>人机交互类外部设备，存储设备，网络通信设备</p><p><strong>按传输速率分类：</strong></p><p>低速设备，中速设备，高速设备</p><p><strong>按信息交换的单位分类：</strong></p><p>块设备（传输快，可寻址）</p><p>字符设备（传输慢，不可寻址）</p><p><strong>I&#x2F;O控制器</strong></p><p>用于实现对I&#x2F;O设备的控制，I&#x2F;O设备由机械部件和电子部件组成。、</p><p><strong>主要功能：</strong></p><p>接受和识别CPU发出的命令（要有控制寄存器）</p><p>向CPU报告设备的状态（要有状态寄存器）</p><p>数据交换：要有数据寄存器，暂存输入和输出的数据</p><p>地址识别：（由I&#x2F;O逻辑实现）</p><p><strong>组成：</strong></p><p>CPU与控制器之间的接口（实现控制器与CPU之间的通信）</p><p>I&#x2F;O逻辑（负责识别CPU发出的命令，并向设备发出命令）</p><p>控制器与设备之间的接口（实现控制器与设备之间的通信）</p><p><strong>两种寄存器编址方式：</strong></p><p><strong>内存映射I&#x2F;O</strong></p><p>控制器中的寄存器与内存统一编址，可以采用对内存进行操作的指令来对控制器进行操作</p><p><strong>优点：</strong></p><p>不需要专门的I&#x2F;O指令，使得CPU访问I&#x2F;O的操作更加灵活和方便，还使用端口具有较大的编址空间。I&#x2F;O访问的保护机制可有虚拟存储管理系统来实现，无需专门设置。</p><p><strong>缺点：</strong></p><p>端口地址占用了部分主存地址空间，使主存的可用容量变小，此外，由于在识别I&#x2F;O端口是全部地址线都要参加译码，使得译码电路更加复杂，降低了寻址速度。</p><p><strong>寄存器独立编制：</strong></p><p>控制器中的寄存器独立编制</p><p>需要设置专门的指令来操作控制器。</p><p><strong>优点：</strong></p><p>I&#x2F;O端口数比主存单元少得多，只需要少量的地址线，使得I&#x2F;O端口译码简单，寻址速度更快，使用专用的I&#x2F;O指令，可使程序更加清晰，便于理解和检查。</p><p><strong>缺点：</strong></p><p>I&#x2F;O指令少，只提供简单的传输操作，所以程序设计的灵活性较差，此外，CPU需要提供两组独立的存储器和设备的读写控制信号，增加了控制的复杂性。</p><h3 id="5-1-2I-x2F-O控制方式"><a href="#5-1-2I-x2F-O控制方式" class="headerlink" title="5.1.2I&#x2F;O控制方式"></a>5.1.2I&#x2F;O控制方式</h3><table><thead><tr><th>方式</th><th>完成读写的过程</th><th>CPU干预频率</th><th>每次I&#x2F;O数据传输单位</th><th>数据流向</th></tr></thead><tbody><tr><td>程序直接控制方式</td><td>CPU发出I&#x2F;O命令后需要不断轮询</td><td>极高</td><td>字</td><td>设备–》CPU–》内存，内存–》CPU–》设备</td></tr><tr><td>中断驱动方式</td><td>CPU发出I&#x2F;O命令后可以做其他事，本次I&#x2F;O完成后设备控制器发出中断信号</td><td>高</td><td>字</td><td>设备–》CPU–》内存，内存–》CPU–》设备</td></tr><tr><td>DMA方式</td><td>CPU发出I&#x2F;O命令后可以做其他事，本次I&#x2F;O完成后DMA控制器发出中断信号</td><td>中</td><td>块</td><td>设备–》内存，内存–》设备</td></tr><tr><td>通道控制方式</td><td>CPU发出I&#x2F;O命令后可以做其他事，通道会执行通道程序以完成I&#x2F;O，完成后通道向CPU发出中断信号</td><td>低</td><td>一组块</td><td>设备–》内存，内存–》设备</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优缺点：</span><br><span class="line">每个阶段的优点都是解决了上一阶段的最大缺点；总体来说：整个发展过程就是要减少CPU对I/O过程的干预，把CPU从繁杂的I/O控制事务中解脱出来，以便更多的去完成数据处理任务。</span><br></pre></td></tr></table></figure><h3 id="5-1-3I-x2F-O软件层次结构"><a href="#5-1-3I-x2F-O软件层次结构" class="headerlink" title="5.1.3I&#x2F;O软件层次结构"></a>5.1.3I&#x2F;O软件层次结构</h3><p><strong>I&#x2F;O软件层次</strong></p><p><strong>用户层软件</strong></p><p>实现与用户交互的接口，向上提供方便易用的库函数</p><p><strong>设备独立性软件</strong></p><p>①向上层提供统一的调用接口（如read&#x2F;write系统调用）</p><p>②设备的保护</p><p>③差错处理</p><p>④设备的分配与回收</p><p>⑤数据存储区管理</p><p>⑥建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</p><p><strong>设备驱动程序</strong></p><p>设置设备寄存器，检查设备状态</p><p><strong>中断处理程序</strong></p><p>进行中断处理</p><p><strong>硬件</strong></p><p>执行I&#x2F;O操作，有机械部件，电子部件组成（参考I&#x2F;O控制器）</p><p>理解并记住I&#x2F;O软件各个层次之间的次序，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立型软件，设备驱动程序这两层。只需理解一个特点即可。直接涉及到硬件具体细节，且与中断无关的操作肯定是在设备驱动程序层完成的，没有涉及硬件的，对各种设备都需要进行的管理工作都是在设备独立性软件层完成的）</p><h3 id="5-1-4应用程序I-x2F-O接口"><a href="#5-1-4应用程序I-x2F-O接口" class="headerlink" title="5.1.4应用程序I&#x2F;O接口"></a>5.1.4应用程序I&#x2F;O接口</h3><p><strong>I&#x2F;O接口的分类</strong></p><p>字符设备接口，快设备接口，网络设备接口。</p><p><strong>阻塞I&#x2F;O</strong></p><p>阻塞I&#x2F;O是指当用户进程调用I&#x2F;O操作时，进程就被阻塞，并移到阻塞队列，I&#x2F;O操作完成后进程才被唤醒，移到就绪队列</p><p><strong>例如：****你和女友去奶茶店买奶茶，点完单之后，因为不知道奶茶什么时候做好，所以只能一直等待，其他什么事也不能干。</strong></p><p><strong>优点：</strong>操作简单，实现难度低，适合并发量小的应用开发</p><p><strong>缺点：</strong>I&#x2F;O执行阶段进程会一直阻塞下去。</p><p><strong>非阻塞I&#x2F;O：</strong></p><p>非阻塞I&#x2F;O是指当前用户进程调用I&#x2F;O操作时，不阻塞该进程但进程需要不断询问I&#x2F;O操作是否完成，在I&#x2F;O执行阶段，进程还可以做其他事情。</p><p><strong>例如：</strong>你和女友去奶茶店买奶茶，汲取了上次的教训，点完单口顺便去逛逛商场，由于担心错过取餐，所以每隔一段时间就过来询问服务员</p><p><strong>优点；</strong>进程在等待I&#x2F;O期间不会阻塞，可以做其他事情，适合并发量大的应用开发</p><p><strong>缺点：</strong>轮询方式询问I&#x2F;O结果，会占用CPU的时间</p><h2 id="5-2设备独立性软件"><a href="#5-2设备独立性软件" class="headerlink" title="5.2设备独立性软件"></a>5.2设备独立性软件</h2><h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p><strong>SPOOLING</strong></p><p><strong>脱机技术：</strong>外围控制机+更高速的涉笔——磁带</p><p><strong>作用：</strong>缓解设备与CPU的速度矛盾实现预输入，缓输出</p><p><strong>假脱机技术：</strong></p><p>又叫SPooling技术，用软件的方式模拟脱机技术</p><p><strong>输入井和输出井：</strong>模拟脱机输入输出时的磁带</p><p><strong>输入进程和输出进程：</strong>模拟脱机输入输出的外围控制机</p><p><strong>输入缓冲区和输出缓冲区：</strong>内存中的缓冲区，输入输出时的“中转站”</p><p><strong>共享打印机：</strong></p><p>用假脱机技术将独占式的打印机“虚拟”成共享打印。</p><h3 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h3><p><strong>应考虑的因素</strong></p><p><strong>固有属性：</strong>独占设备，共享设备，虚拟设备</p><p><strong>分配算法：</strong>先来先服务，优先级高者优先，短任务优先</p><p><strong>安全性：</strong>安全分配方式、不安全分配方式（死锁避免，银行家算法）</p><p><strong>静态分配与动态分配：</strong></p><p><strong>静态分配：</strong>进程运行前为其分配全部所需资源，运行结束后归还资源</p><p><strong>动态分配：</strong>进程运行过程中动态申请设备资源（动态）</p><p><strong>设备分配管理中的数据结构</strong></p><p>**设备控制表（DCT)**每个设备对应一个DCT，关键字段：类型&#x2F;标识符&#x2F;状态&#x2F;指向COCT的指针&#x2F;等待队列指针</p><p>**控制器控制表（COCT)**每个控制器对应一个COCT，关键字段：类型&#x2F;标识符&#x2F;状态&#x2F;指向CHCT的指针&#x2F;等待队列指针</p><p>**通道控制表（CHCT)**每个控制器对应一个CHCT，关键字段：类型&#x2F;标识符&#x2F;状态&#x2F;等待队列指针</p><p><strong>系统设备表（SDT）</strong>记录整个系统中所有设备的情况，每个设备对应一个表目，关键字段：设备类型&#x2F;标识符&#x2F;DCT&#x2F;驱动程序入口</p><p><strong>设备分配的步骤：</strong></p><p>①根据进程请求的物理设备名查找SDT</p><p>②根据SDT找到DCT并分配设备</p><p>③根据DCT找到COCT并分配控制器</p><p>④根据COCT找到CHCT并分配通道</p><p><strong>注：</strong>只有设备，控制器，通道，三者都分配成功时，这次设备分配才算成功之后便可启动I&#x2F;O设备进行数据传送。</p><p><strong>缺点：</strong>用户编程时必须使用“物理设备名”若换了一个物理设备，则程序无法运行。若进程请求的物理设备正在忙碌，即使系统中还有同类型的设备，进程必须阻塞等待。</p><p><strong>设备分配步骤的改进：</strong>用户编程时使用逻辑设备名申请设备，操作系统负责实现从逻辑设备名到物理设备名的映射（通过LUT）</p><p><strong>逻辑设备表的设置问题：</strong></p><p>整个系统只有一张LUT；各个用户所用的逻辑设备名不允许重复</p><p>每个用户一张LUT，各个用户的逻辑设备名可重复</p><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p><strong>缓冲区的概念：</strong></p><p>一般利用内存作为缓冲区，缓解CPU与设备的速度矛盾，减少对CPU的中断频率，解决数据粒度不匹配的问题，提高CPU与I&#x2F;O设备之间的并行性</p><p><strong>单缓冲：</strong></p><p>设备-（T）-缓冲区-（M）工作区-(C)处理</p><p>处理一块数据平均耗时Max(C,T)+M</p><p>分析问题的初始状态：工作区满，缓冲区空</p><p><strong>双缓冲：</strong></p><p>处理一块数据平均耗时max(T,C+M)</p><p>分析问题的初始状态；工作区空，一个缓冲区满，另一个缓冲区空</p><p><strong>循环缓冲：</strong></p><p>多个缓冲区连接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区</p><p><strong>缓冲池：</strong></p><p><strong>三个队列：</strong>空缓冲队列，输入队列，输出队列</p><p><strong>四种工作缓冲区：</strong>用于收容输入数据的工作缓冲区，用于提取输入数据的工作缓冲区</p><p>用于收容输出数据的工作缓冲区，用于提取输出数据的工作缓冲区</p><h2 id="5-3磁盘和固态硬盘"><a href="#5-3磁盘和固态硬盘" class="headerlink" title="5.3磁盘和固态硬盘"></a>5.3磁盘和固态硬盘</h2><h3 id="5-3-1磁盘的结构"><a href="#5-3-1磁盘的结构" class="headerlink" title="5.3.1磁盘的结构"></a>5.3.1磁盘的结构</h3><p><strong>磁盘、磁道、扇区的概念</strong></p><p>磁盘由表面涂有磁性物质的圆形盘片组成</p><p>每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区</p><p><strong>如何在磁盘中读写数据</strong></p><p>磁头移动到目标位置，盘片旋转，对应盘区划过磁道才能完成读写</p><p><strong>盘面，柱面的概念：</strong></p><p>磁盘有多个盘片“摞起来”，每个盘片有两个盘面</p><p>所有盘面中相对位置的磁道组成柱面</p><p><strong>磁盘的物理地址：</strong></p><p>（柱面号，盘面号，扇区号）</p><h3 id="5-3-2磁盘的分类"><a href="#5-3-2磁盘的分类" class="headerlink" title="5.3.2磁盘的分类"></a>5.3.2磁盘的分类</h3><p><strong>根据磁头是否可移动</strong></p><p>固定头磁盘（每个磁道有一个磁头）</p><p>移动头磁盘（每个盘面只有一个磁头）</p><p><strong>根据盘面是否可以更换</strong></p><p>固定盘磁盘，可换盘磁盘</p><h3 id="5-3-3磁盘的调度算法"><a href="#5-3-3磁盘的调度算法" class="headerlink" title="5.3.3磁盘的调度算法"></a>5.3.3磁盘的调度算法</h3><p><strong>一次磁盘读写操作需要的时间</strong></p><p>寻道时间：移动磁臂，移动磁头所需要的的时间</p><p>延迟时间：将目标扇区转到磁头下面所花的时间</p><p>传输时间：读写数据花费的时间</p><p><strong>磁盘调度算法：</strong></p><table><thead><tr><th>先来先服务（FCFS）</th><th>①按访问请求到达的先后顺序进行处理</th></tr></thead><tbody><tr><td>最短寻找时间优先（SSTF）</td><td>每次都优先响应距离磁头最近的磁道的访问请求，贪心算法的思想，能保证眼前最优，但无法保证总的寻道时间最短，缺点，可能导致饥饿</td></tr><tr><td>扫描算法（电梯算法，SCAN）</td><td>只有磁头移动到最边缘的磁道时才可以改变磁头方向，缺点：对各个位置磁道的响应频率不平均</td></tr><tr><td>循环扫描算法（C-SCAN）</td><td>只有需磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，返回途中不响应任何请求</td></tr><tr><td>LOOK算法</td><td>SCAN算法的改进，只要在磁头移动方向上不再有请求，就立即改变磁头方向</td></tr><tr><td>C-LOOK算法</td><td>C-SCAN算法的改进 ，只要在磁头移动方向上不在有请求，就立即让磁头返回序号最小的磁头</td></tr></tbody></table><p>若题目中无特别说明，则SCAN就是Look，C-SCAN就是C-LOOK</p><h3 id="5-3-4减少延迟时间的方法"><a href="#5-3-4减少延迟时间的方法" class="headerlink" title="5.3.4减少延迟时间的方法"></a>5.3.4减少延迟时间的方法</h3><p><strong>交替编号：</strong></p><p>具体做法：让编号相邻的扇区在物理上不相邻</p><p>原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</p><p><strong>错位命名：</strong></p><p>具体做法：让相邻的盘面的扇区编号“错位”</p><p>原理：与“交替编号”的原理相同。”错位命名法“可以降低延迟时间</p><p><strong>磁盘地址结构的设计：</strong></p><p>理解为什么要用（柱面号，盘区号，扇区号）的结构</p><p>理解为什么不用（盘区号，柱面号，扇区号）的结构</p><p>原因：在读取地址连续的磁盘块时，前者更不需要移动磁头</p><h3 id="5-3-5磁盘的管理："><a href="#5-3-5磁盘的管理：" class="headerlink" title="5.3.5磁盘的管理："></a>5.3.5<strong>磁盘的管理：</strong></h3><p><strong>磁盘初始化：</strong></p><p>低级格式化&#x2F;物理格式化：划分扇区</p><p>磁盘分区（C盘，D盘，E盘）</p><p>逻辑格式化：建立文件系统（建立根目录文件，建立用于存储空间管理的数据结构）</p><p><strong>引导块：</strong></p><p>计算机启动时需要运行初始化程序（自举程序）未完成初始化</p><p>ROM存放很小的自举装入程序</p><p>完整的自举程序存放在初始化块（引导块）中</p><p><strong>坏块的管理：</strong></p><p>简单的磁盘：逻辑格式化时将坏块标记出来</p><p>复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区。</p><h3 id="5-3-6固态硬盘SSD"><a href="#5-3-6固态硬盘SSD" class="headerlink" title="5.3.6固态硬盘SSD"></a>5.3.6固态硬盘SSD</h3><p>原理：基于闪存技术Flash Memory,属于可擦除ROM，即EEPROM</p><p>组成：闪存翻译层-负责翻译逻辑块号，找到对应页（Page)</p>]]></content>
    
    
    <summary type="html">有关系统</summary>
    
    
    
    <category term="操作系统" scheme="https://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>deeplearning 鱼与熊掌可以兼得</title>
    <link href="https://example.com/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/"/>
    <id>https://example.com/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/</id>
    <published>2025-09-30T02:24:50.838Z</published>
    <updated>2025-10-24T11:54:12.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鱼与熊掌兼得（deeplearning的好处）"><a href="#鱼与熊掌兼得（deeplearning的好处）" class="headerlink" title="鱼与熊掌兼得（deeplearning的好处）"></a>鱼与熊掌兼得（deeplearning的好处）</h1><h2 id="一-两难境地"><a href="#一-两难境地" class="headerlink" title="一.两难境地"></a>一.两难境地</h2><p>在deep learning过程中，对应的参数量过多，可能会造成过拟合的现象，而相反的，参数量过少有可能获得不了比较良好的效果，这让我们进入了两难的境地。</p><h2 id="二-piecewise-linear-分段线性曲线回顾"><a href="#二-piecewise-linear-分段线性曲线回顾" class="headerlink" title="二.piecewise linear(分段线性曲线回顾)"></a>二.piecewise linear(分段线性曲线回顾)</h2><p>分段线性曲线可以看作常数项加上一系列的Z形函数。</p><p><img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902092334684.png" alt="image-20250902092334684"></p><p>而对应的hard sigmoid的一段函数又可以有对应的两端RELU函数进行组合表示。</p><p><img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902092535998.png" alt="image-20250902092535998"></p><h2 id="三-是否深度学习表现更加优异"><a href="#三-是否深度学习表现更加优异" class="headerlink" title="三.是否深度学习表现更加优异"></a>三.是否深度学习表现更加优异</h2><p><img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902092655642.png" alt="image-20250902092655642"></p><p>可以看到，随着对应的深度学习的层数增加对应的语音识别的错误率也有所降低。</p><p>那么瘦高的神经网络，和矮胖的神经网络哪个更好。</p><p><img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902092819086.png" alt="image-20250902092819086"></p><p>若采取同样的参数量，这里两种神经网络那个更加的优秀。</p><p><img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902092928669.png" alt="image-20250902092928669"></p><p>如图所示，采用相同的参数量，对应的更深的神经网络的表现要明显的优于矮胖的神经网络。</p><p>甚至到最后矮胖的神经网络随着参数的增多，对应的实验效果变得不那么优秀，甚至出现了倒退的行为。</p><h2 id="四-为什么我们需要更深的神经网络。"><a href="#四-为什么我们需要更深的神经网络。" class="headerlink" title="四.为什么我们需要更深的神经网络。"></a>四.为什么我们需要更深的神经网络。</h2><p>的确一层的神经网络可以拟合出任何的函数，但是利用深度学习网络对于效果的提升更加具有效率。例如：逻辑元器件进行组合，采用更深的 组合可以减少器件的数量。在编程的过程中比较深的递归的方法可以很大程度上的节省编程的程序篇幅，增加代码的可读性。</p><p><img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902093439091.png" alt="image-20250902093439091"></p><p>对应的剪纸的过程中，采用折叠的方式也可以类比到神经网络，剪纸的层数增加，从而使工匠对于制作的过程中更加的简洁，节省体力，增加效率。<img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902093612634.png" alt="image-20250902093612634"></p><h2 id="五-总之：：：：："><a href="#五-总之：：：：：" class="headerlink" title="五.总之：：：：："></a>五.总之：：：：：</h2><p><img src="/2025/09/30/deeplearning%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/image-20250902093655940.png" alt="image-20250902093655940"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;鱼与熊掌兼得（deeplearning的好处）&quot;&gt;&lt;a href=&quot;#鱼与熊掌兼得（deeplearning的好处）&quot; class=&quot;headerlink&quot; title=&quot;鱼与熊掌兼得（deeplearning的好处）&quot;&gt;&lt;/a&gt;鱼与熊掌兼得（deeplearni</summary>
      
    
    
    
    <category term="机器学习" scheme="https://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="deeplearning" scheme="https://example.com/tags/deeplearning/"/>
    
  </entry>
  
  <entry>
    <title>CNN</title>
    <link href="https://example.com/2025/09/30/CNN/"/>
    <id>https://example.com/2025/09/30/CNN/</id>
    <published>2025-09-30T02:24:50.836Z</published>
    <updated>2025-10-24T11:53:58.797Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/09/30/CNN/image-20250901110303393.png" alt="CNN"></p><h1 id="CNN的主要流程"><a href="#CNN的主要流程" class="headerlink" title="CNN的主要流程"></a>CNN的主要流程</h1><h2 id="①规格化图片"><a href="#①规格化图片" class="headerlink" title="①规格化图片"></a>①规格化图片</h2><p>在运行训练过程之前们需要将所有的图片<strong>scale</strong>成大小一样的对应图片，最终cross entropy越小越好，对应的误差也就越小。</p><p>模型的输入是对应的图片是一个三维矩阵，对应的前两位是<strong>对应的像素点的位置</strong>。而第三维是对应的<strong>rgb</strong>的一个3元数组，经过三维方向的拉直，形成一个可以用来训练的向量集合。</p><p><img src="/2025/09/30/CNN/image-20250901111401812.png" alt="image-20250901111401812"></p><p><strong>对应的机器和人都是会产生差异的</strong>，人和机器都是去寻找对应的图片中生物的特征之后就将这样的特征与人们所熟知的生物特征进行比对，形成结论，但是有可能出现错误。</p><p><img src="/2025/09/30/CNN/image-20250901111606390.png" alt="image-20250901111606390"></p><p>例如如上的图片，无论是人还是机器都会将其识别成一个鸟类：乌鸦，但是实际上这是一只猫，一只黑猫</p><h2 id="②分区"><a href="#②分区" class="headerlink" title="②分区"></a>②分区</h2><p>观察自己的小范围去判断特征，这是每一个neuron所作的事情。</p><p>将对应的小范围进行拉直，作为输入，之后利用多层的运算形成最终的判断。对应的范围的属性与分布是可以根据实际情况进行灵活调整的。多个范围之间可以进行重叠，亦可以两个神经元去守备同一块的范围，非正方形的范围也是可取的。理论上对应的范围也是可以不相连的。但是实际的图像识别中很难利用的上</p><p><img src="/2025/09/30/CNN/image-20250901112216965.png" alt="image-20250901112216965"></p><h2 id="③最经典的设计"><a href="#③最经典的设计" class="headerlink" title="③最经典的设计"></a>③最经典的设计</h2><p>对应的所有的<strong>channel</strong>都参与识别但是对应的小区域的范围很小，每个区域用一个neuron去守备，移动的范围叫做<strong>stride也就是步长</strong>，对应的步长使对应的每个区域有一个维度的重叠。</p><p><img src="/2025/09/30/CNN/image-20250901112720454.png" alt="image-20250901112720454"></p><p>超出对应的图的范围就用零进行补齐（其余的方式也是可取的）按照这种方式去守备整个图片。</p><h2 id="④一个小问题"><a href="#④一个小问题" class="headerlink" title="④一个小问题"></a>④一个小问题</h2><p>同样的pattern可能出现在图片的不同的位置，但是扫描是无死角的，总是会被探测出来的，不一定所有的区域都要加上对应的部位的检测</p><p><strong>解决方法：</strong>共享参数，对应的两个神经元的权重矩阵完全相同，由于对应的部位不同，所以对应位置的识别的结果也是客观的。</p><p><strong>注意：</strong>不能让守备同一块区域的神经元共享参数，会造成相同的结果，没有任何意义。</p><h2 id="⑤常见的共享参数的设定方法"><a href="#⑤常见的共享参数的设定方法" class="headerlink" title="⑤常见的共享参数的设定方法"></a>⑤常见的共享参数的设定方法</h2><p>不同的参数则代表守备的生物的部位是不同的，对应的参数集合叫做<strong>filter</strong>，也就是<strong>筛选器</strong></p><p><img src="/2025/09/30/CNN/image-20250901113523317.png" alt="image-20250901113523317"></p><p><strong>对应的卷积神经网络的优势</strong>：</p><p>对应的范围越大，对应的弹性就越大，就越容易出现overfitting，过拟合。filter可以利用矩阵相对应位置相乘再加和。</p><h2 id="⑥pooling-压缩"><a href="#⑥pooling-压缩" class="headerlink" title="⑥pooling(压缩)"></a>⑥pooling(压缩)</h2><p>大的图片识别的时候可以压缩成小的图片，本身没有参数，是一个设定好的部件。</p><p><strong>Max pooling</strong></p><p>分组选择代表，可以选择最大的当代表，卷积神经网络需要与pooling进行交替使用</p><h2 id="⑦flatten"><a href="#⑦flatten" class="headerlink" title="⑦flatten"></a>⑦flatten</h2><p>会将对应的矩阵进行拉直，判断最终的类别之前需要做这样的动作。</p><h2 id="⑧总体流程"><a href="#⑧总体流程" class="headerlink" title="⑧总体流程"></a>⑧总体流程</h2><p><img src="/2025/09/30/CNN/image-20250901114137921.png" alt="image-20250901114137921"></p><p><strong>注意</strong>：对应的pooling的工作会对最终结果造成影响，但是可以减少计算量。部分的问题是不可以使用pooling的,比如对应的围棋对弈的问题。</p><p><img src="/2025/09/30/CNN/image-20250901114308100.png" alt="image-20250901114308100"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/09/30/CNN/image-20250901110303393.png&quot; alt=&quot;CNN&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;CNN的主要流程&quot;&gt;&lt;a href=&quot;#CNN的主要流程&quot; class=&quot;headerlink&quot; title=&quot;CNN</summary>
      
    
    
    
    <category term="机器学习" scheme="https://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CNN卷积神经网络" scheme="https://example.com/tags/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://example.com/2025/09/30/Principle%20and%20Applications%20of%20Artificial%20Intelligence/"/>
    <id>https://example.com/2025/09/30/Principle%20and%20Applications%20of%20Artificial%20Intelligence/</id>
    <published>2025-09-30T02:20:45.296Z</published>
    <updated>2025-09-04T00:53:10.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Principle-and-Applications-of-Artificial-Intelligence"><a href="#Principle-and-Applications-of-Artificial-Intelligence" class="headerlink" title="Principle and Applications of Artificial Intelligence"></a>Principle and Applications of Artificial Intelligence</h1><h2 id="Chapter-0-Introduction-to-AI-2025秋"><a href="#Chapter-0-Introduction-to-AI-2025秋" class="headerlink" title="Chapter 0 Introduction to AI 2025秋"></a>Chapter 0 Introduction to AI 2025秋</h2><p><strong>Contents</strong><br><strong>Preface 引子</strong><br><strong>1 What is AI?</strong><br><strong>2 AI-Model：Agents-Environments</strong><br><strong>&amp; The Structure of Agents</strong><br><strong>3 Applied AI (应用)</strong><br><strong>4 AI Progress</strong><br><strong>5 AI：SOTA—大模型时代</strong><br><strong>6 Reasoning &amp; Inference</strong><br><strong>Summary</strong><br><strong>References</strong><br><strong>Introduction to AI</strong><br><strong>Introduction to AI</strong></p><h3 id="Preface（引子）"><a href="#Preface（引子）" class="headerlink" title="Preface（引子）"></a>Preface（引子）</h3><p>回顾历史：10+年前我国学者的认识<br>• 2008年，我国学者在回顾中国人工智能发展过程时写道(王飞跃等，2008)：<br>• 人工智能的发展一直流传着各种说法，诸如• 人工智能不热门了，走下坡路了• 要被其他学科取代了• 在国外的人工智能研究都申请不到基金资助了• 这些都是毫无根据的！人工智能是一门几乎<br>在所有方面都具有重要应用的技术<br>4<br>我国学者当时对于人工智能发展的观点<br> 当前(2008)中国AI发展的活跃领域<br>• 数学机械化<br>• 图像识别和模式识别<br>• 中文信息处理，特别是对机器翻译<br>• 机器学习和数据挖掘<br>• 形象思维模拟（进行书法创作）<br>• 知识网格环境<br>5<br>那个时期的AI发展<br>• AI的各个分支在蓬勃发展，比如机器学习<br>方法<br>• 2010年图灵奖授予Leslie Valiant，贡献：<br>计算学习理论<br>• 2011年图灵奖授予Judea Pearl，贡献：不<br>确定性推理（贝叶斯推理）<br>6<br>人工智能再次兴起<br>• 2013、2014年，深度学习（深度神经网络）<br>方法及其各种应用的文章在学术界开始流行<br>• 2016年3月，谷歌AlphaGo战胜韩国棋手李<br>世石<br>• 2017年10月，AlphaGo Zero版本问世，不使<br>用人类先验知识完胜之前版本<br>• 2014年以来，对话机器人、图片识别、无人<br>驾驶、语音翻译等各种成功案例被广泛报道 7<br>大语言模型(Large Language Models)<br>时代到来<br>8<br>以ChatGPT为代表的大语言模型的横空出世，不足3<br>年时间就展现了越来越强大的功能，表明新一代AI系<br>统的发展有望诞生强人工智能(通用智能AGI)<br>2024秋AI再掀高潮<br>Breaking news:<br>2024-10-08<br>9<br>10<br>Hopfield和Hinton的贡献 (来自DeepSeek)<br>约翰·霍普菲尔德的主要成就</p><ol><li>Hopfield网络与联想记忆模型<br>✓霍普菲尔德于1982年提出Hopfield网<br>络，这是一种基于物理学中自旋系统<br>原理的递归神经网络。该网络通过能<br>量函数模拟信息的存储与恢复，能够<br>从受损或不完整的数据中重建原始模<br>式，类似于人类记忆的联想机制。其<br>核心思想是将网络状态的能量最小化，<br>使网络在动态更新中收敛到稳定的模<br>式，这一机制被广泛应用于优化问题<br>（如旅行商问题）和图像识别领域。</li><li>物理学与信息处理的交叉创新<br>✓霍普菲尔德将物理学中的统计力学<br>方法引入神经网络研究，例如用自旋<br>系统的能量模型描述网络状态，为后<br>续机器学习技术提供了理论框架。<br>杰弗里·辛顿的主要成就</li><li>深度学习的理论与技术突破<br>✓辛顿被誉为“深度学习之父”，其反向传播算法<br>（Backpropagation）的改进使大规模神经网络的训<br>练成为可能，开启了深度学习的黄金时代。他提出<br>的玻尔兹曼机（Boltzmann Machine）基于统计物理<br>学原理，能够通过无监督学习发现数据中的特征，<br>为生成对抗网络（GAN）和自然语言处理（如GPT<br>模型）奠定了基础。</li><li>推动人工智能的实际应用<br>✓辛顿主导的AlexNet（2012年ImageNet竞赛冠军）<br>首次展示了深度卷积神经网络在图像识别中的强大<br>性能，彻底改变了计算机视觉领域。他的研究还促<br>进了自动驾驶、医疗影像分析、语音识别等技术的<br>发展。</li><li>多学科融合与伦理倡导<br>✓辛顿强调物理学、神经科学与计算的交叉研究，<br>其工作揭示了大脑学习机制与人工神经网络的相似<br>性；同时关注人工智能的伦理问题，呼吁在技术发<br>展中平衡创新与社会责任。<br>Hopfield和Hinton的贡献 (来自DeepSeek)<br>11<br>微信朋友圈评论<br>☆数字世界和物理世界没有了界限<br>☆以后计算机领域的最高奖是诺贝尔奖了<br>☆也许，未来学好人工智能，很有可能会比拒绝<br>人工智能的人，能更有效地工作、生活、形成<br>新的主要发现，甚至争夺各个方向的诺贝尔奖<br>☆感慨伟大时代，我们没有错过！<br>12<br>Breaking news:<br>2024-10-09<br>13<br>Hassabis和Jumper的贡献Hassabis和<br>Jumper的贡献<br>14<br>微信朋友圈评论<br>☆未来会不会成为常态<br>☆AI is all you need!<br>☆莫非，诺贝尔文学奖-ChatGPT；诺贝尔和平奖-<br>Ilya Sutskever；菲尔兹奖-AlphaMath？<br>☆事实证明，AI已经控制了人类<br>15<br>16<br>时间定位：第三次人工智能技术（AI）浪潮<br>17<br>高度：第4次工业革命<br>18<br>机械化<br>（1760<del>1840）<br>电气化<br>（1840</del>1950）<br>信息化<br>（1950<del>今）<br>智能化<br>（2010</del>今）<br>两自：自动化、<br>自主性<br>两高：高速度、<br>高精度<br>AI为什么现在火起来？<br>•条件好了<br>•有网了<br>•钱多了<br>19<br>技术交叠：大智移云物<br>20<br>大数据 移动计算<br>云计算 物联网<br>人工智能<br>AI在中国: 长期战略<br>• 国家战略：2018年10月31日，中共中央政治局下<br>午就人工智能发展现状和趋势举行第九次集体学<br>习，习总书记指出：人工智能是引领这一轮科技<br>革命和产业变革的战略性技术，具有溢出带动性<br>很强的“头雁”效应<br>• 科技计划：2017年7月8日，经中央政治局常委会、<br>国务院常务会议审议通过，国务院印发《新一代<br>人工智能发展规划》（国发201735号）<br>• 高等教育：专业、学院、研究院、园区（北大）<br>• 每年一度的各类AI大会（学术界、工业界）<br>21<br>AI在中国: 生成式AI服务管理<br>• 《生成式人工智能服务管理暂行办法》已经2023<br>年5月23日国家互联网信息办公室2023年第12次室<br>务会会议审议通过，并经国家发展和改革委员会、<br>教育部、科学技术部、工业和信息化部、公安部、<br>国家广播电视总局同意，现予公布，自2023年8月<br>15日起施行。<br>• 总则&#x2F;第二章 技术发展与治理：对服务商的训练<br>数据的要求<br>• 第三章 服务规范：服务商服务过程的管理<br>• 第四章 监督检查和法律责任：管理部门责任<br>22<br>AI在中国: 对生成式AI训练的要求<br>• 第七条 生成式人工智能服务提供者（以下称提供者）应当依法<br>开展预训练、优化训练等训练数据处理活动，遵守以下规定：<br>• （一）使用具有合法来源的数据和基础模型；<br>• （二）涉及知识产权的，不得侵害他人依法享有的知识产权<br>• （三）涉及个人信息的，应当取得个人同意或者符合法律、行<br>政法规规定的其他情形；<br>• （四）采取有效措施提高训练数据质量，增强训练数据的真实<br>性、准确性、客观性、多样性；<br>• （五）《中华人民共和国网络安全法》、《中华人民共和国数<br>据安全法》、《中华人民共和国个人信息保护法》等法律、行<br>政法规的其他有关规定和有关主管部门的相关监管要求。<br>23<br>Introduction to AI<br>1 What is AI?<br>人工智能是什么<br>Intelligence, (Intelligent) Agents<br>4 Categories of Approaches for AI Research<br>Modeling Human Behavior (algorithm preferred)<br>Introduction to AI<br>Intelligence 智能<br>• We call ourselves Homo sapiens（智人）—man t<br>he wise<br>• how we think （我们怎样思考）?<br>• How a mere handful of matter (brain) can perceive,<br>understand, predict, and manipulate a world far<br>larger and more complicated than itself ?<br>• Our intelligence (智能)! 因此，We must know:<br>intelligence and artificial intelligence<br>25<br>Introduction to AI<br>智能是什么(1)<br>• Intelligence — from Wiki<br>• is a term describing a property of the mind(智力&#x2F;心智<br>的属性) including related abilities, such as the<br>capacities for abstract thought, understanding,<br>communication, reasoning, learning, learning from past<br>experiences, planning, and problem solving.<br>• Intelligence is most widely studied in humans, but is<br>also observed in animals and plants.<br>• Artificial intelligence is the intelligence of machines or<br>the simulation of intelligence in machines.<br>26<br>Introduction to AI<br>智能是什么(2)<br>• Intelligence — from Encyclopedia Britannica<br>(不列颠百科全书)<br>• In psychology the term may more specifically denote<br>the ability to apply knowledge to manipulate one’s<br>environment or to think abstractly as measured by<br>objective criteria (such as the IQ (intelligence quotient)<br>test).<br>• Intelligence is usually thought of as deriving from a<br>combination of inherited characteristics and<br>environmental (developmental and social) factors (继承<br>与环境的结合)<br>27<br>Introduction to AI<br>Intelligence &amp; AI<br>• Artificial intelligence goes further:<br>• It attempts not just to understand intelligence<br>• but also to build intelligent entities (agents智能体)<br>• （但实际上后者在某些情况下更简单）<br>• AI is one of the newest fields in science and<br>engineering: to build systems or software of<br>agents to implement tasks and arrive goals which<br>usually done by human 人工智能就是具有某种&#x2F;<br>某些人类功能的软硬件系统<br>28<br>29<br>• Pioneering: work started after WWII, name<br>itself as AI in 1956<br>• Exciting: AI cited as the “field I would most<br>like to be in” by scientists in other isciplines<br>&#x2F; open to genius of full-time Einsteins and<br>Edisons<br>• Universal: 在AI第三次浪潮席卷之下，哪个领<br>域不可以应用AI技术呢？（本人一项调查<br>[2019]显示：中国国民经济行业分类中97个大<br>类中几乎全部都有应用）<br>Pioneering, Exciting and Universal Field<br>Introduction to AI<br>Introduction to AI<br>A Process to Understand AI<br>• 相关定义见仁见智，简单一句话：人工<br>智能是一种对人类行为建模的技术<br>• 目前AI技术还是以黑箱方法为主—以结果或<br>功能判断<br>• AI就是一种运行在我们自己机器中的程序，<br>其初始智能都是我们给的，但是大模型可以<br>出现智能涌现，解决之前没有专门给定&#x2F;训<br>练的问题<br>• 最重要：了解、掌握、应用AI思想解决<br>实际问题<br>30<br>31<br>Some Definitions of AI: 4 Categories<br>Thinking Humanly Thinking Rationally<br>要使计算机能思考……有头脑的<br>机器(Haugeland, 1985)<br>[使之自动化]与人类的思维相关<br>的活动,诸如决策、问题求解、学<br>习等活动(Bellman, 1978)<br>通过对计算模型的使用来进行心<br>智能力的研究(Charniak &amp;<br>McDemontt, 1985)<br>对使得知觉、推理和行动成为可<br>能的计算的研究(Winston, 1992)<br>Acting Humanly Acting Rationally<br>创造机器来执行人需要智能才能<br>完成的功能(Kurzweil, 1990)<br>研究如何让计算机能够做到那些<br>目前人比计算机做得更好的事情<br>(Rich &amp; Knight, 1991)<br>计算智能是对设计智能化智能体<br>的研究(Poole et al., 1998)<br>AI关心的是人工制品中的智能行<br>为(Nilsson, 1998)<br>Introduction to AI<br>模仿游戏与图灵测试（Turing Test）*<br>1950年，阿兰•图灵在那篇名垂青史的论文《计算机械与<br>智力》的开篇说：“我建议大家考虑这个问题：‘机器能<br>思考吗？’”但是由于我们很难精确地定义思考，所以图<br>灵提出了他所谓的“模仿游戏”：一场正常的模仿游戏有<br>ABC三人参与，A是男性，B是女性，两人坐在房间里；C<br>是房间外的裁判，他的任务是要判断出这两人谁是男性谁<br>是女性。但是男方是带着任务来的：他要欺骗裁判，让裁<br>判做出错误的判断<br>图灵问：“如果一台机器取代了这个游戏里的男方的地位，<br>会发生什么？”这个问题取代了我们原本的问题：‘机器<br>能否思考？’”这就是图灵测试的本体<br>32 * 知乎：<a href="https://www.zhihu.com/topic/19565866/intro">https://www.zhihu.com/topic/19565866/intro</a><br>图灵测试*<br>让一个人坐在电脑前，跟另一边用键盘进行对话，如果这<br>个人分不清跟自己对话的是一个人还是一个机器，那么这<br>个对话机器就通过了图灵测试并具备人工智能。测试标准：<br>聊天时长25分钟，低于25分钟的不算通过测试<br>33 * <a href="https://easyai.tech/ai-definition/turing-test/">https://easyai.tech/ai-definition/turing-test/</a><br>图灵测试的意义<br> 图灵认为：这种模拟游戏的问答方法原则上适用于人类心<br>智的任何领域<br> 图灵测试的意义：<br>（1）给出了一个可操作的智能定义，也就是根据对一系<br>列特定问题的反应来决定一个客体是否是智能体，这就<br>为判断智能提供了一个客观标准，从而避免了有关智能<br>本质的无谓争论<br>（2）这项实验使我们免于受到目前无法回答的问题的牵<br>制，比如计算机的内部处理方法（内部机制）是否已知<br>，以及机器是否意识到其本身的动作等等（所谓自主意<br>识）<br>（3）由于询问者只关注回答问题的内容，这样就消除了<br>偏爱于生物体的设置<br>34<br>图灵测试：复述、文摘、问答、翻译<br>美国认知心理学家 G. M. Olson（奥尔森） 提出判别计<br>算机是否理解自然语言的四条标准分别是：问答、文<br>摘、复述和翻译。他认为，计算机只要达到了以上标<br>准的一条，就可以说它能够理解自然语言*<br>也就是说从语言理解方面具备了智能：因为图灵测试<br>主要关注了问答，而这四大任务包括了问答，所以能<br>够以更多形式理解语言，也就是通过了图灵测试<br>复述：同一语言转写；翻译：不同语言转写；文摘：<br>原文缩写；问答：自然语言交互</li></ol><ul><li>李维刚 等，复述技术研究综述<br>35<br>复述<br>文心一言（2024年3月测试）<br>原文<br>36<br>37<br>2024年3月测试 翻译<br>38<br>39<br>105字摘要<br>850字<br>2024年3月测试 文摘<br>40<br>2024年3月测试<br>问答<br>《全唐诗》共收录唐、五代350年间诗歌48900余首，收<br>入作家2246人—故宫博物院<br>Introduction to AI<br>2 AI-model：Agents and<br>Environments<br>人工智能模型：智能体与环境<br>components of agents, rational agents<br>task environments, their properties<br>Examples of environments and agents<br>Introduction to AI<br>智能体:从技术角度为AI建模<br>• 智能体：通过传感器感知所处环境并通<br>过执行器对该环境产生作用的计算机程<br>序及其控制的硬件<br>• 感知信息：表示任意给定时刻智能体的感知<br>输入 &#x2F; 感知序列：该智能体所收到的所有输<br>入数据的完整历史<br>• 智能体函数：把任意给定感知序列映射到智<br>能体行动的描述 &#x2F; 智能体程序：抽象的智能<br>体函数的一个具体实现，该程序在智能体自<br>身结构上运行<br>42<br>43<br>View of a Rational Agent<br>Environment<br>Agent<br>percepts<br>actions<br>?<br>Sensors<br>Effectors<br>How to design this?<br>Introduction to AI<br>44<br>不同智能体：例子<br>• 建造理性智能体的综合考虑: 任务环境<br>• PEAS (Performance, Environment, Actuators,<br>Sensors) 性能&#x2F;环境&#x2F;执行器&#x2F;传感器<br>• 例子<br>智能体<br>种类<br>性能度量<br>(量化目标)<br>环境 执行器 传感器<br>出租车<br>司机<br>安全,快速,<br>守法,舒适<br>的旅途,利<br>润最大化<br>道路,其他车<br>辆,行人,旅客<br>方向盘,加速<br>器,刹车,信<br>号灯,喇叭,<br>(显示器)<br>引擎传感器,<br>速度计,加速<br>计,里程计,<br>GPS,(声波传<br>感器,摄像头,<br>键盘)<br>Introduction to AI<br>45<br>智能体举例<br>智能体类型 性能度量 环境 执行器 传感器<br>医学诊断系<br>统<br>恢复健康的<br>病人,费用<br>最小化,最<br>少诉讼<br>病人,医院,<br>职员<br>显示:问题,<br>测试,诊断,<br>治疗,咨询<br>键盘输入,<br>症状,检查<br>结果,病人<br>回答<br>挑拣零件的<br>机器人<br>放进正确箱<br>子的零件的<br>百分比<br>载有零件的<br>传送带,箱<br>子<br>有关节的胳<br>膊和手<br>摄像头,关<br>节角度传感<br>器<br>交互式英语<br>教师<br>最大化学生<br>的测试成绩<br>学生集合,<br>测验机构<br>显示(语音<br>合成):练习,<br>建议,纠正<br>键盘输入<br>(语音识别)<br>Introduction to AI<br>46<br>智能体所处的任务环境<br>任务环境 可观察性 确定性 片段性 静态性 离散性 智能体数<br>出租车驾<br>驶<br>部分 随机的 延续式的 动态的 连续的 多<br>医学诊断<br>系统<br>部分 随机的 延续式的 动态的 连续的 单<br>选零件的<br>机器人<br>部分 随机的 片段式的 动态的 连续的 单<br>交互式英<br>语教师<br>部分 随机的 延续式的 动态的 离散的 多<br>纵横字谜<br>游戏<br>完全 确定的 延续式的 静态的 离散的 单<br>Introduction to AI<br>47<br>A Windshield Wiper (雨刷器) Agent<br>How do we design a agent that can wipe the windshields<br>when needed?<br>• Goals? Keep windshields clean &amp; maintain visibility<br>• Percepts？ Raining, Dirty<br>• Sensors？ Camera (moist sensor)<br>• Effectors？ Wipers (left, right, back)<br>• Actions？ Off, Slow, Medium, Fast<br>• Environment: Inner city, freeways, highways, weather …<br>Introduction to AI<br>Introduction to AI<br>智能体结构<br>• AI的任务是设计智能体程序<br>• 智能体程序要在某个具备实际传感器和<br>执行器的计算装置上运行, 该装置称为体<br>系结构<br>• 智能体 &#x3D; 体系结构 + 程序<br>• 智能处理过程：传感器输入→智能体程序→<br>行动→执行器<br>• 最典型：机器人<br>48<br>Introduction to AI<br>智能体类型<br>• 有4种类型的智能体程序(或部分程序)<br>• 简单反射型智能体<br>• 基于模型的反射型智能体<br>• 基于目标的智能体<br>• 基于效用的智能体<br>• 学习智能体，学习程序(模型&#x2F;系统)也是一<br>种智能体<br>49<br>50<br>简单反射型智能体<br>智能体 传感器<br>现在世界<br>是什么样的<br>环<br>境<br>现在我应该<br>采取什么行动<br>执行器<br>条件–行动规律<br>f : P→A f : IF-THEN<br>Introduction to AI<br>51<br>Example 1<br>• Agent: Mail sorting robot<br>• Environment: Conveyor belt of letters<br>• function simple-reflex-agent(percept)<br>• returns action<br>• static: rules, a set of condition-action rules<br>• state  interpret-input(percept)<br>• rule  rule-match(state, rules)<br>• action  rule-action[rule]<br>• return action<br>Introduction to AI<br>52<br>基于模型的反射型智能体<br>传感器<br>现在世界<br>是什么样的<br>现在我应该<br>采取什么行动<br>执行器<br>状 态<br>世界如何演变<br>我 的 行 动 产 生<br>什么效果<br>条件–行动规则<br>智能体<br>环<br>境<br>f : P+M→A f : IF+<br>-THEN<br>Introduction to AI<br>Introduction to AI<br>Example 2<br>• a breakfast robot<br>• Put mensurable (定量的) water to a pot<br>• taking two eggs out of a box and adding them to a<br>pot of water<br>• using a teaspoon to take two teaspoonfuls of salt<br>out of a jar and add it to a pot of water<br>• 模型应用于多步骤的行动<br>• 模型提供行动步骤的顺序<br>• 模型记录行动步骤的状态…<br>53<br>基于模型的Agent功能描述<br>• 模型：在当前状态下+行动→产生新状态<br>• 规则：当前状态下的规则<br>• 行动：已经匹配规则的行动部分<br>54<br>Introduction to AI<br>Model<br>• Why a model?<br>• the choice of appropriate action requires<br>maintaining some knowledge of the past in the<br>form of a model (维护知识，如机器学习建模)<br>• Significantly different states of the environment –<br>ones requiring different actions – may present the<br>agent with the same perceptual input (环境表示：<br>知识表示)<br>• Maintaining internal state may allow the agent to<br>distinguish between them (内部状态：参数)<br>55<br>56<br>大模型时代的Agent模型<br>自省&#x2F;自我修正<br>轨迹 语言模<br>型作用<br>Introduction to AI<br>3 Applied AI<br>人工智能应用<br>The scope of AI technology<br>AI for enterprises (+AI)：examples<br>Introduction to AI<br>AI技术应用范围<br>AI技术—对于人类行为的系统化建模方法<br>人类个人行为—感知世界、理解、推理、<br>求解、学习、<br>社会交流、创造、控制……<br>人类群体行为—经济活动、政治活动、<br>社会活动、文化活动、教育活动、军事<br>活动…… 国民经济行业<br>58<br>身边的AI：智能手机<br>59<br>智能<br>手机<br>语音识<br>别<br>手写<br>识别<br>道路<br>导航<br>点餐<br>推荐<br>购物<br>推荐<br>其他种种……<br>大语言模型时代（生成式AI）的便利？<br>• 写作文、写诗、作画……（文艺青年）：擅长<br>• 倒垃圾、做家务……（生活实务）：尚未普及<br>• 为什么？<br>• 脑力劳动 vs 体力劳动（智力指导下）<br>• 当前大模型是数字大脑，在感知认识和对物理<br>世界的操纵方面(这不是经典AI的领域)还有很<br>多欠缺—因此，对于类人智能体来说，体力方<br>面的增强落后于脑力方面的进展<br>• 需要大力加强人工体能研发！<br>60<br>Introduction to AI<br>国民经济行业+AI<br>国家标准：国民经济行业分类与代码<br>（GB&#x2F;T 4754-2017）<br>20门类97个大类473中类1380小类<br>每个行业类别（大类）中都有AI技术的<br>应用<br>AI技术与行业的深度融合，主要体现在<br>两个方面：一个是产品中应用AI，一个<br>是在制造产品的过程中应用AI<br>61<br>Introduction to AI<br>中国国务院规划<br>国务院2017年发布的《新一代人工智能发<br>展规划》指出：<br>人工智能研发攻关、产品应用和产业培育<br>‘三位一体’推进<br>培育高端高效的智能经济，提出了大力发<br>展人工智能新兴产业、加快推进产业智能<br>化升级、大力发展智能企业、打造人工智<br>能创新高地<br>62<br>63<br>行业AI：举例(1)<br>Introduction to AI<br>行业名称<br>及代码<br>所属门类<br>及代码<br>相关应用主题列举<br>农业01 农林牧渔<br>业 A<br>智能育种，农业生产管理智能化，农业专家模型，精<br>准农业（病虫害管理、田间管理），农业传感器芯片<br>林业02 同上 森林精准监控与管理，精准林木育种与抚育，森林火<br>灾智能预防<br>畜牧业03 同上 奶牛饲养智能化管理<br>渔业04 同上 渔情预报<br>煤炭开采<br>06<br>采矿业<br>B<br>煤矿生产仪器智能化，煤矿开采方案优化，煤矿井下<br>参数监控，煤矿救灾机器人；智慧矿山<br>石油和天<br>然气开采<br>07<br>同上 自动钻井系统，海底油气生产机器人<br>其他采矿业<br>08、09、10<br>同上 自动采矿系统<br>64<br>行业AI：举例(2)<br>Introduction to AI<br>行业名称及<br>代码<br>所属门类<br>及代码<br>相关应用主题列举<br>农副产品加工<br>13、食品制造<br>14、酒和饮料<br>制造15<br>制造业 C 基于数据挖掘的产品设计，基于计算机视觉的产品<br>制造，产品质量监控，生产过程智能化，产品虚拟<br>助理（根据自动收集的数据回答相关问题）<br>烟草制品16 同上 烟草仓库智能监控<br>纺织业17、服<br>装业18、皮革<br>业19<br>同上 智能装备—数字化工厂，智能穿戴，智能家居，智<br>能产品检测，智能化工厂；智能针织产业园<br>木材等加工20、<br>家具制造21、<br>造纸22<br>同上 基于专家系统的智能制造，模糊控制，质量监控，<br>智能家居<br>印刷业23 同上 制版机器人，智能印刷，智能印刷工厂<br>文体娱乐用<br>品制造24<br>同上 机器人玩具，智能音箱<br>燃料加工25 同上 核废料智能管理；核电站智能化管理<br>65<br>行业AI：举例(3)<br>Introduction to AI<br>行业名称及<br>代码<br>所属门类<br>及代码<br>相关应用主题列举<br>化学原料与制品<br>制造26、化学纤<br>维制造28、橡胶<br>塑料制造29<br>制造业<br>C<br>基于专家系统的化工制造过程故障诊断与预警；化工<br>知识自动化与生产过程结合，传感器与模式识别结<br>合<br>医药制造27 同上 基于数据挖掘的早期药物筛选，药物合成预测<br>非金属制品30 同上 智能雾化玻璃，新型材料发现，陶瓷配方专家系统，<br>窑炉工况智能监测<br>钢铁工业31 同上 制造过程中非金属杂物的自动监测，生产过程智能<br>化管理，能源智能化调配，钢铁企业全流程大数据<br>建模，智能诊断维护钢铁工业智能制造<br>有色金属32 同上 金属板材制造、轧机智能控制，电解过程智能控制；<br>带有计算机视觉的冶金生产线，冶金机器人<br>金属制品33 同上 工业机器人<br>通用设备制造<br>业34<br>同上 自动化生产线集成，工业机器人，数控机床，工业<br>物联网<br>66<br>行业AI：举例(4)<br>Introduction to AI<br>行业名称及<br>代码<br>所属门类及<br>代码<br>相关应用主题列举<br>水上运输业<br>55<br>交通运输、仓<br>储、邮政业 G<br>智能航运系统，智能港口，船舶自动驾驶；智能船舶<br>航空运输业<br>56<br>同上 订票问答系统，智能身份识别系统<br>管道运输业<br>57<br>同上 水下管道安装机器人<br>装卸搬运和<br>仓储59<br>同上 仓储机器人，无人运输机，无人配送车<br>邮政业60 同上 智能分拣系统，智能仓库，窗口服务机器人，智能<br>客服<br>教育83 教育 P 智能教室，智能化教务管理<br>卫生84 卫生和社会<br>工作 Q<br>医疗专家系统，医学图像识别，导诊机器人<br>Introduction to AI<br>行业AI应用的价值<br>代替或辅助人类从事危险工作、减轻人<br>类劳动量、替代人类完成脏活累活<br>提升劳动生产率，创造更大生产价值&#x2F;利润<br>降低成本，制造出更多物美价廉产品供广<br>大消费者使用<br>遵从行业核心价值，而不是跟风、炒作、制<br>造噱头<br>67<br>Introduction to AI<br>AI早期成功的例子：规划（1991）<br>• Planning后勤规划：1991年海湾战争中美<br>国军队配备了一个动态分析和重规划工<br>具DART, 用于自动后勤规划与运输调度<br>• 该系统同时涉及50000个车辆、货物和人，<br>而且要考虑起点、目的地、路径，解决所有<br>参数之间的冲突。使用AI技术使规划在几小<br>时内完成，而传统方法需要几个星期<br>• DARPA称就此一项投资足以补偿DARPA在<br>AI方面30年的投资<br>• NASA’s Remote Agent program (Mars<br>exploration Rovers)<br>68<br>Introduction to AI<br>AI早期成功例子：博弈—国际象棋<br>（1997）<br>• Game playing 博弈：IBM公司的“深蓝”<br>成为第一个在国际象棋比赛中战胜世界<br>冠军的计算机程序<br>• 1997年，一次公开赛中3.5&#x2F;2.5比分战胜卡<br>斯帕罗夫，他说从棋盘对面感到了“一<br>种新智能”<br>• （但是，“深蓝”的设计者不认为用了多么<br>高深的AI技术）<br>69<br>Introduction to AI<br>AI近期成功例子：AlphaGo (2016)<br>• AlphaGo主要由4个部分组成:(田渊栋，2016)<br>（1）走棋网络 (Policy network), 给定当前局面,<br>预测&#x2F;采样下一步的走棋.<br>（2）快速走子 (Fast rollout), 目标和走棋网络一<br>样, 但在适当牺牲走棋质量的条件下, 速度要比<br>走棋网络快1000倍.<br>（3）估值网络 (Value network), 给定当前局面,<br>估计是白胜还是黑胜.<br>（4）蒙特卡罗树搜索 (Monte Carlo tree search,<br>MCTS), 把以上这三个部分连起来, 形成一个完<br>整的系统<br>70<br>Introduction to AI<br>4 AI Progress<br>人工智能简史<br>the contributions to the forming and developing<br>of AI discipline from 8 disciplines<br>AI pioneers &amp; Turing Award for AI<br>AI brief history （三次浪潮）<br>Introduction to AI<br>Disciplines given contributions to AI<br>• 哪些学科、哪些思想和哪些人物给予AI以贡献?<br>• Philosophy 哲学(BC428<del>现在)<br>• Mathematics 数学(800</del>现在)<br>• Economics 经济学(1776<del>现在)<br>• Neurocience 神经科学(1861</del>现在)<br>• Psychology 心理学(1879<del>现在)<br>• Computer engineering 计算机工程(1940</del>现在)<br>• Control theory and cybernetics 控制论(1948<del>现<br>在)<br>• Linguistics 语言学(1957</del>现在)<br>72<br>73<br>哲学的贡献<br>• 哲学(BC428<del>现在)贡献的思想:<br>• 问题1：形式化规则能用来抽取合理的结论<br>吗? Yes&#x2F;著名的三段论<br>• 问题2：精神的意识是如何从物质的大脑产<br>生出来的? 存在2种结论：二元论和一元论<br>• 问题3：知识是从哪里来的? 培根：实践<br>• 问题4：知识是如何导致行动的? 知识用<br>于指导行动去达到目标<br>Introduction to AI<br>74<br>数学的贡献<br>• 数学(800</del>现在)贡献的思想:<br>• 什么是抽取合理结论的形式化规则? 逻辑<br>• 什么可以被计算? 计算理论(可计算性和算<br>法复杂性)<br>• 如何用不确定的知识进行推理? 贝叶斯<br>方法<br>• AI成为一门规范科学要求在三个基础领<br>域完成一定程度的数学形式化:<br>• 逻辑、计算、概率<br>Introduction to AI<br>Introduction to AI<br>计算机工程的贡献<br>• 计算机工程(1940<del>现在)的贡献:<br>• 如何才能制造出“能干”的计算机?<br>• 计算机被视为智能和人工制品的结合<br>• 1945年在宾夕法尼亚大学(UPenn)开发出来<br>的ENIAC被公认为现代计算机最有影响的先<br>驱, 研制者包括John Mauchly和John Eckert<br>• 计算机软件技术为AI提供了操作系统、程序<br>设计语言、工具软件等；AI反过来也对主流计<br>算机科学产生了影响<br>75<br>Introduction to AI<br>各学科的贡献<br>• 哲学—逻辑&#x2F;推理方法&#x2F;智能作为一种物理系<br>统&#x2F;理性的基础<br>• 数学—形式表示与证明&#x2F;算法&#x2F;可计算性&#x2F;可操<br>作性&#x2F;概率性<br>• 心理学—自适应性&#x2F;感知和控制的现象<br>• 语言学—知识表示&#x2F;语法<br>• 神经科学—智能活动的物理基础(substrate)<br>• 控制理论—自我平衡系统&#x2F;稳定性&#x2F;优化设计<br>• 计算机工程—计算机硬件和软件系统<br>• 经济学—复杂系统中的决策&#x2F;验证环境<br>76<br>Introduction to AI<br>推动AI发展的动力<br>• 上述学科对于各种问题的探索, 由此激发的认识、<br>思想、成就都成为推动AI发展的动力，或许人类<br>对于技术成果改变生活的持续追求是最大的动力<br>• 人工智能&#x3D;人造物(计算机)+智能(特殊程序)<br>• 从智能体角度, 有2类智能体: 人类&#x2F;计算机<br>• 人造智能体, 人们期待计算机智能体&#x2F;人工智能在<br>越来越多领域里解决问题，并且达到专家水平；；；；；；；；；；；；；；；;<br>并且要发展出一个整体上超过普通人的超级智能<br>体<br>77<br>Introduction to AI<br>图灵的论文<br>• 图灵1950年的论文第一<br>个清晰地描绘出AI的完<br>整图像(Computing<br>Machinery and<br>Intelligence)<br>• 提出了图灵测试、机器<br>学习、遗传算法、增量<br>学习<br>78<br>79<br>图灵与苹果<br>• Alan Mathison Turing 1912.6.23—1954.6.7<br>• 1936年，提出“图灵机”的构想(24岁)<br>• 1940年-1942年，成功破译了德军U-潜艇密码，主要<br>贡献者<br>• 1947年-1948年，同时在神经网络和人工智能领域做<br>出开创性的理论研究<br>• 1950年，发表论文“计算机器与智能”，人工<br>智能科学的开创性构思 &#x2F; 提出著名的“图灵测试”<br>理论<br>• 1951年，从事生物的非线性理论研究 &#x2F; 当选英国<br>皇家学会会员(或应称为会士)，时年39岁<br>• 1952年曾被捕入狱<br>• 1953-54年，从事物理和生物学研究<br>Introduction to AI<br>Introduction to AI<br>人工智能的诞生(1956)<br>• 1956年夏天, AI正式诞生于达特茅斯大学<br>• John McCarthy(麦卡锡)自普林斯顿大学毕<br>业以后去了达特茅斯大学, 他说服了另外2<br>个人帮助召开了为期2个月的研讨会<br>• 会议组织者4人: 麦卡锡、Minsky(明斯基)、<br>Claude Shannon(香侬)、IBM的Nathaniel<br>Rochester(罗切斯特), 参加者共10人<br>• 其他6位是：普林斯顿大学Trenchard More、<br>IBM的Arthur Samuel(塞缪尔)、MIT的Ray<br>Solomonoff和Oliver Selfridge、CMU的纽厄<br>尔和西蒙<br>80<br>AI的奠基者—图灵奖获得者<br>81<br>麦卡锡(1927</del>2011) 闵斯基(1927<del>2016) 西蒙(1916</del>2001) 纽厄尔(1927<del>1992)<br>1971年获奖 1969年获奖 1975年两人共同获奖<br>82<br>国际计算机界对AI成就的肯定<br>Introduction to AI<br>获奖年份 图灵奖获奖者 主要贡献 时代<br>1969 Marvin Minsky AI奠基者, 机器思维概念、<br>Agent等<br>第1次AI浪潮<br>1971 John McCarthy AI奠基者, AI程序设计语<br>言<br>同上<br>1975 Hebert Simon, Allen<br>Newell<br>AI奠基者, 通用问题求解 同上<br>1994 Edward Feigenbaum,<br>Raj Reddy<br>知识工程 第2次AI浪潮<br>2010 Leslie Valiant 计算学习理论 机器学习发展<br>期<br>2011 Judea Pearl 不确定性推理 同上<br>2018 Geoffrey Hinton, Yoshua<br>Bengio, Yann LeCun<br>神经网络模型（深度学习） 第3次浪潮<br>2024 Andrew Barto, Richard<br>Sutton<br>强化学习 第3次浪潮<br>AI第3次浪潮<br>83<br>84<br>了解AI最新进展：人工智能学会(美)网站<br>• AAAI：conference of Association for the<br>Advancement of Artificial Intelligence<br>• 网站： <a href="https://www.aaai.org/">https://www.aaai.org</a><br>Introduction to AI<br>关于AI方面的世界报道，以小时为间隔更新<br><a href="https://aitopics.org/search">https://aitopics.org/search</a> 网站<br>AITopics: 2025-08-23<br>85<br>AI topics（网站:<a href="https://aitopics.org/%EF%BC%89">https://aitopics.org/）</a><br>• AAAI官方出版物：全球AI进展报道—今天的新闻，明<br>天的历史<br>86<br>浏览时间 报道数量 头条 top 3<br>2025-08-23 698792 使用AI技术跟踪野生动物；；；；；; Meta将有<br>关AI技术用于其产品；; NASA从200万<br>英里以外小行星采集岩石样品<br>2024-10-28<br>12:37<br>669884 AI art related<br>Apple’s smart room<br>Google’s new AI browser<br>2023-11-01<br>08:30<br>503412 英国AI医疗、AI重塑IT产业、特斯拉<br>车祸<br>2022-10-26<br>09:30<br>437331 Metaverse(元宇宙)<br>Harvard’s Robot<br>AITopics2024起由i2kConnect维护<br>87<br>Introduction to AI<br>了解AI最新进展：IJCAI年会<br>• IJCAI：International Joint Conference on<br>Artificial Intelligence<br>• 网站：<a href="http://www.ijcai.org/">http://www.ijcai.org/</a><br>• AAAI：conference of Association for the<br>Advancement of Artificial Intelligence<br>• 网站： <a href="https://www.aaai.org/">https://www.aaai.org</a><br>88<br>89<br>• IJCAI is the International Joint Conference on Artificial<br>Intelligence, the main international gathering of<br>researchers in AI. Held biennially in odd-numbered<br>years since 1969, IJCAI is sponsored jointly by IJCAI<br>and the national AI sociatie(s) of the host nation(s).<br>• <a href="http://www.ijcai.org/">http://www.ijcai.org/</a> (online proceedings)<br>• First conference – IJCAI-69: Washington, D.C., USA<br>• 2013-08-03</del>09, Beijing<br>• 2015起，IJCAI改为每年举办一次<br>• 2019-08-10<del>16, Macao; 2025-08-16</del>22, Montreal<br>Introduction to AI<br>IJCAI<br>IJCAI-2023,2023-08-19<del>25, Macao<br>本届大会论文主题（部分）：<br> Machine Learning 12 Natural Language Processing 4 Computer<br>Vision 6 ML: Federated Learning 3 Agent-based and Multi-agent<br>Systems 4 Planning and Scheduling 3 Data Mining 3<br>Knowledge Representation and Reasoning 4<br> CV: Vision and Language 2 CV: 3D Computer Vision 3 CV:<br>Recognition 3 CV: Segmentation 2 ML: Deep reinforcement<br>Learning 2 Constraint Satisfaction and Optimization 2<br> AI Ethics, Trust, Fairness 3 Game Theory and Economic<br>Paradigms 2<br> NLP: Information Extraction, AI for Social Good – Ethics, trust,<br>fairness, S: Heuristic Search, Search, AI and Arts: Sound and<br>Music, Robotics 90<br>Introduction to AI<br>IJCAI-2024, 2024-08-03</del>09, Jeju<br>Conference Main Track<br>91<br>Introduction to AI<br>主题 Session<br>数量<br>主题 Session<br>数量<br>MTA: Multidisciplinary<br>Topics and applications<br>7 ETF: AI Ethics, Trust,<br>Fairness<br>7<br>DM: data mining 10 S: search 4<br>GTEP: game theory<br>and economic<br>paradigms<br>6 NLP 10<br>CV: computer vision 17 ROB: intelligent robotics 2<br>ML 30 AI for social good 5<br>KRR: K repre &amp; rea.. 6 CSO: Constraint optim… 3<br>Introduction to AI<br>5 AI：The State of The Art<br>（SOTA）<br>人工智能发展现状：<br>大语言模型时代<br>AlphaGo (2016)<br>大语言模型Large Language Models (2022~)<br>大语言模型Large Language Models蓬勃发展<br>93<br>大语言模型LLMs是一种数字大脑(语言类)<br>ChatGPT表现出来的类人智能：数字大脑（语言类）<br> Kosinski（斯坦福大学心理学家）指出*<br>：ChatGPT解决了<br>93%的“心智理论”（Theory of Mind, ToM）任务测试（给<br>定故事上下文，测试其推理能力），达到了9岁孩童的能<br>力—大模型自动涌现（spontaneously emerged）了一种人<br>类具有的智力<br> 说明：语言中存在着未知的规则或者规律，能够用来求解智<br>力问题（ToM）而无须引入显式的心理测试形式，因此需要<br>对深度神经网络&#x2F;模型进行心理学研究<br> 作者明确提出：当AI模型（即大模型） 学习如何解决各类问<br>题时，他可能就在发展一种与人类大脑类似的机制……研究<br>AI模型在心理学测试问题上的性能、探索使能力得以呈现的<br>大规模神经网络结构，就能不仅推进我们对于AI的理解，也<br>能推进对人脑的理解</li><li>Michal Kosinski, Theory of Mind May Have Spontaneously Emerged in Large Language Models, 94<br>arXiv:2302.02083<br>数字大脑（语言集合）储存了人类全部知识<br>数字大脑：语言集合存储了人类的全部知识<br> 大模型的类人智能来自哪里？来自<br>语言学习<br> 人类语言作为工具承载了三大功能：<br>个人思维、人际交流、知识传承<br> 世界上最大的知识库就是全部语言<br>（为主）内容集合（数字或非数字<br>形式：所有的书籍、期刊、网<br>页……）<br> 一旦大模型存储了大规模语言内容<br>并建立了语言语义（以词汇为单元）<br>之间的联系，可以说他就具备了人<br>类的大多数知识<br>95<br>数字大脑的分区*<br>96<br>Introduction to AI</li><li>arXiv: 2310.14928<br>主要研究结果：语言能力核心区占大模型参数1%；LLaMA2-13B<br>模型仅修改130亿参数中的一个就导致模型的语言能力完全丧失<br>类人智能<br>97<br>Introduction to AI<br>类人智能（Human-Like&#x2F;Level Artificial Intelligence,<br>HLAI）并无正式的定义或描述，这个名称来自2022一<br>篇文章*<br>该文声称：AI pioneer Nils Nilsson noted that “achieving<br>real human-level AI would necessarily imply that most of<br>the tasks that humans perform for pay could be automated.”<br>(人类为了糊口而干活的那些任务都被替代) ；同时写到<br>“achieving human-level AI or ‘strong AI’ （强人工智能）<br>remains the ultimate goal for some researchers” 比较<br>“weak AI” which seeks to “build machines that help<br>humans.”—替代人类 vs 帮助人类</li><li>Erik Brynjolfsson, The Turing Trap: The Promise &amp; Peril of Human-Like<br>Artificial Intelligence, 2022<br>LLMs智能的表现：涌现<br>98<br> LLMs的涌现能力（emergence）是什么？[1][2]<br>（1）to produce long stretches of coherent text（长文连贯性）<br>（2）do things they weren’t trained on（未经训练的回复）<br>（3）engage (to some extent) in topics of conversation that were<br>thought to be off-limits for computers（谈论起原本是计算机禁区<br>的话题）<br> UC Berkeley教授Steinhardt定义涌现：“when quantitative<br>changes in a system result in qualitative changes in behavior”（量变<br>引起质变）<br>斯坦福大学博士生Bommasani定义为：“not present in smaller<br>models but are present in larger models”（小模型中没有，大模型中<br>有）解释：过了临界点，性能从随机变好；不是平滑增长的<br>[1] Ben Dickson, Blog, AI scientists are studying the “emergent” abilities of large<br>language models - TechTalks (bdtechtalks.com),<br><a href="https://bdtechtalks.com/2022/08/22/llm-emergent-abilities">https://bdtechtalks.com/2022/08/22/llm-emergent-abilities</a><br>[2] Jason Wei, et al., Emergent Abilities of Large Language Models, Trans. on<br>Machine Learning Research, 2022&#x2F;08<br>涌现能力从何而来：多任务微调<br>LLM诞生之前是PLMs(Pre-trained Language Models)，参数量最大<br>也达到了千亿量级(100B+)，但是并没有展现出ChatGPT那样令人<br>惊艳的表现<br>多任务微调（instruction tuning on many tasks）*是ChatGPT的基础<br>FLAN(Finetuned LAnguage Net)<br>99</li><li><a href="https://blog.csdn.net/">https://blog.csdn.net/</a> qq_39388410&#x2F;article&#x2F;details&#x2F;128265846<br>Introduction to AI<br>LLMs智能的来源：结构<br>多层神经网络能够逼近任何函数（万能逼近理论），即理论<br>上能够学习任何函数[1]（1989年发表于Neural Network期刊，<br>知乎上详细中文解释参见[2]）；当然，我们不能很容易找到一<br>个给定问题的最优权重！实际上，在合理的时间内训练一个精<br>确模型取决于许多因素，如网络结构、参数数量<br>神经网络时代的NLP（语言理解与生成）是一个函数映射过<br>程：输入&#x3D;向量，输出&#x3D;向量，函数&#x3D;多级映射<br>该文的主要结论[2]：深度神经网络作为一个函数, 不管用哪<br>个squashing function作为激活函数、不管在哪个有界度量的意<br>义下, 都可以用来逼近任意Borel可测函数<br>[1] Kurt Hornic, et al. Multilayer Feedforward Networks are Universal<br>Approximators, Neural Network, V2, pp359-366, 1989<br>[2] 知乎：深度神经网络可以逼近Borel可测函数，<a href="https://zhuanlan.zhihu.com/p/">https://zhuanlan.zhihu.com/p/</a> 100<br>458006332<br>LLMs智能的来源：机理<br>101<br>Introduction to AI<br>相变机制[1]：当AI系统的拓扑连接规模越过某个阈值时，AI系<br>统中互不连接的部分构成了连贯结构（1987）<br>这就可以解释：为什么LLMs能够组合知识片段而生成流畅的<br>输出（长文连贯性）—生成了原来没有见过的句子<br>最新研究（2023-07）证明了深层神经网络中存在吸收相变（<br>absorbing phase transition）的过程[2]<br>the purpose of the present work is to demonstrate that the notion<br>of absorbing phase transition is a promising tool for theoretical<br>understanding of the deep neural networks<br>[1] Huberman &amp; Hogg, Phase transitions in artificial intelligence systems, AI 1987<br>[2] Tamai, et al., Absorbing Phase Transitions in Artificial Deep Neural<br>Networks, CoRR，2023-07<br>认知能力：<br>来自德国、意大利、英国、美国的研究者获得新研究成果：2024<br>102<br>ToM: Theory of Mind<br>103<br> Theory of Mind (ToM)通常译为心智理论（或可称为智力论），也称为<br>读心术（mind reading）指的是一个人认识别人智力行为（如因饿而<br>开冰箱）的能力，是hot cognition（情感认知）研究中一个关键组成<br>部分*<br> ToM能力： The ability of putting yourself in somebody else‘s shoes （设<br>身处地为他人着想）is a crucial evolutionary advantage for humans, for it<br>allows us to better interact with our environment and cooperate more<br>effectively with our peers<br> 大模型已经自发地涌现了心智&#x2F;智力论能力，也就是说他开始能够<br>“理解”人类所说（这个理解不同于之前NLU理解技术，是来自于涌<br>现而非单纯技术实现）</li><li>F. Cuzzolin, et al., Knowing me, knowing you: theory of mind in AI (2020),<br><a href="https://www.cambridge.org/">https://www.cambridge.org/</a> core&#x2F;journals&#x2F;psychological￾medicine&#x2F;article&#x2F;knowing-me-knowing-you-theory-of-mind-in-ai<br>动态：Nature子刊<br> Nature子刊《自然·人类行为》的一篇最新研究采用非常严谨的试验<br>，证明GPT-4表现居然位于人类水平之上，能够比人类更好地检测出<br>讽刺和暗示，其弱点来自于不表达观点的护栏<br> 想象一下，当你站在一扇关闭的窗户附近，听到朋友说「这里有点热」，你就<br>会意识到，她不仅仅是在评论温度，而是礼貌地请求你打开窗户。这种追踪他<br>人心理状态的能力被称为心智理论，这是人类心理学的一个核心概念<br> 测试共分为5个项目（错误信念、反讽、失言、暗示、奇怪故事）<br> 测试结果表明：GPT-4在5项测试中有3项的表现明显优于人类（反讽、暗示、<br>奇怪故事），1项（错误信念）与人类持平，仅在失言测试中落于下风<br> 研究人员又发现，GPT-4并非不擅于识别失言，而是因为它非常保守，不会轻<br>易给出确定性的意见<br>这里采用： 新智元 2024-05-26 报道<br>104<br>各个测试项目（错误信念、反讽、失言、暗示、奇怪故事）的得分分布<br>105<br>中国自主研发的大模型DeepSeek<br>DeepSeek为什么火了？<br>豆包<br>文心一言<br>星火<br>106<br>DeepSeek三大标签：高性能、开源、国产<br>✓ 高性能：大模型的“高性能”本质上是<br>其规模（参数量、数据量、计算量）与先<br>进架构（如Transformer）结合后，在通用<br>性、生成质量、任务适应性等方面的综合<br>体现<br>107<br>DeepSeek三大标签：高性能、开源、国产<br>✓ 开源：大模型开源是AI平等的重要推手<br>，通过降低技术壁垒、促进协作创新，让<br>更多人参与AI变革；其价值不仅在于技术<br>本身，更在于激发全球智慧解决复杂问题<br>，推动AI向更开放、普惠的方向发展<br>108<br>DeepSeek三大标签：高性能、开源、国产<br>109<br>✓ 国产化大模型的意义：大模型国产化<br>的核心优势在于政策支持下的规模化应用、<br>垂直场景的精准赋能、技术自主可控的创<br>新突破，以及生态共建带来的协同效应。<br>这些优势不仅助力国内产业智能化转型，<br>还为中国在全球AI竞争中占据主动地位奠<br>定基础。未来，随着商业化模式的成熟与<br>伦理治理的完善，国产大模型有望在更多<br>领域释放潜力，推动经济高质量发展<br>➢ 以上回复均来自DeepSeek<br>Introduction to AI<br>6 On Reasoning<br>关于推理<br>推理方法一览<br>推理的重要性<br>111<br>Introduction to AI<br>推理是什么？<br>• To reason is to draw inferences appropriate to the<br>situation. (合适地应用推理步骤以获得结论)<br>Inferences are classified as either deductive (演绎)<br>or inductive (归纳)：[britannica.com]<br>• The reasoning is the mental process of deriving<br>logical conclusion and making predictions from<br>available knowledge, facts, and beliefs. Or we can<br>say, “Reasoning is a way to infer facts from existing<br>data.” It is a general process of thinking rationally, to<br>find valid conclusions. [javatpoint.com]<br>112<br>113<br>区分reasoning和inference*<br>• 推理（reasoning）：是一种模型工作机制（处理<br>方法） ， 定义如下：由一个或几个已知的判断<br>（前提）推出新判断（结论）；推理没有唯一的<br>方式，只要处理方法符合定义，即能给出证据链<br>（预测过程有理可依），即可视为推理<br>• 推断（inference）：可以理解成一种基于充分信<br>息量的预测过程；通常指模型训练（learning）结<br>束后，使用训练好的模型做预测（predict）的过程<br>如online inference, variational inference；或者给定<br>X 取值，观测Y的过程，如causal inference<br>Introduction to AI</li><li>知乎 <a href="https://www.zhihu.com/question/405941421/answer/1586030490">https://www.zhihu.com/question/405941421/answer/1586030490</a><br>114<br>典型的推理方法*<br>• Deductive reasoning 演绎推理 <br>• Inductive reasoning 归纳推理 机器学习<br>• Abductive reasoning 溯因推理； <br>• Common Sense Reasoning 常识推理<br>• Monotonic Reasoning 单调推理<br>• Non-monotonic Reasoning 非单调推理<br>Introduction to AI</li><li><a href="https://www.javatpoint.com/reasoning-in-artificial-intelligence">https://www.javatpoint.com/reasoning-in-artificial-intelligence</a><br>Introduction to AI<br>Deductive reasoning 演绎推理<br>• Deductive reasoning is deducing new information<br>from logically related known information. It is the<br>form of valid reasoning, which means the<br>argument’s conclusion must be true when the<br>premises are true. In deductive reasoning, the truth<br>of the premises guarantees the truth of the<br>conclusion.<br>115<br>Introduction to AI<br>Inductive reasoning 归纳推理<br>• Inductive reasoning is a form of reasoning to arrive at<br>a conclusion using limited sets of facts by the process<br>of generalization. It starts with the series of specific<br>facts or data and reaches to a general statement or<br>conclusion.<br>• Machine Learning<br>• premises provide probable supports to the conclusion,<br>so the truth of premises does not guarantee the truth<br>of the conclusion.<br>116<br>117<br>Abductive reasoning 溯因推理<br>• Abductive reasoning is a form of logical reasoning<br>which starts with single or multiple observations<br>then seeks to find the most likely explanation or<br>conclusion for the observation.<br>• the premises do not guarantee the conclusion.<br>Introduction to AI<br>解释<br>推理模型<br>观察 观察<br>Introduction to AI<br>Commonsense Reasoning 常识推理<br>• Commonsense reasoning is an informal form of<br>reasoning, which can be gained through experiences.<br>• It relies on good judgment rather than exact logic and<br>operates on heuristic knowledge and heuristic rules.<br>• Example:<br>• One person can be at one place at a time.<br>• If I put my hand in a fire, then it will burn.<br>118<br>119<br>Monotonic Reasoning 单调推理<br>• In monotonic reasoning, once the conclusion is taken, then it<br>will remain the same even if we add some other information to<br>existing information in our knowledge base. Here, adding<br>knowledge does not decrease the set of prepositions that can be<br>derived. We can derive the valid conclusion from the available<br>facts only, and it will not be affected by new facts.（结论不因<br>新事实增加而改变）<br>• Monotonic reasoning is not useful (不是很有用) for the real￾time systems, as in real time, facts get changed, so we cannot<br>use monotonic reasoning.<br>• A logic-based system is monotonic. Any theorem proving is an<br>example of monotonic reasoning.<br>• Example: Earth revolves around the Sun.<br>Introduction to AI<br>Introduction to AI<br>单调推理优势与劣势<br>• Advantages of Monotonic Reasoning:优势<br>• In monotonic reasoning, each old proof will always remain valid.<br>• If we deduce some facts from available facts, then it will remain<br>valid for always. (事实增减不影响结论)<br>• Disadvantages of Monotonic Reasoning:劣势<br>• We cannot represent the real world scenarios using Monotonic<br>reasoning. (很难表示真实场景—情况变了，结果也要跟着变)<br>• Hypothesis knowledge cannot be expressed with monotonic<br>reasoning, which means facts should be true. (必须保证事实为真<br>—实际上这点在现实中无法保证，有假象)<br>• Since we can only derive conclusions from the old proofs, so new<br>knowledge from the real world cannot be added. (限制了新知识<br>的产生—封闭性)<br>120<br>Introduction to AI<br>Non-monotonic Reasoning非单调推理<br>• In Non-monotonic reasoning, some conclusions<br>may be invalidated if we add some more<br>information to our knowledge base. (增加新信息<br>导致原来某些结论不成立)<br>• Logic will be said as non-monotonic if some<br>conclusions can be invalidated by adding more<br>knowledge into our knowledge base.<br>• Non-monotonic reasoning deals with incomplete<br>and uncertain models. (用于建立不完整和不确定<br>模型)<br>121<br>Introduction to AI<br>非单调推理例子<br>• Example: Let suppose the knowledge base contains the<br>following knowledge:<br>✓Birds can fly<br>✓Penguins cannot fly (鸟纲、企鹅目)<br>✓Pitty is a bird (一只叫Pitty的鸟)<br>• So from the above sentences, we can conclude that Pitty can<br>fly.<br>• However, if we add one another sentence into knowledge base<br>“Pitty is a penguin”（增加了Pitty是企鹅）, which concludes<br>“Pitty cannot fly”, so it invalidates the above conclusion. (使<br>结论不成立)<br>122<br>Introduction to AI<br>非单调推理的优势与劣势<br>• Advantages of Non-monotonic reasoning:<br>• For real-world systems such as Robot navigation(机器<br>人导航), we can use non-monotonic reasoning.<br>• In Non-monotonic reasoning, we can choose<br>probabilistic facts (概率事实) or can make<br>assumptions. (提出假设)<br>• Disadvantages of Non-monotonic Reasoning:<br>• In non-monotonic reasoning, the old facts may be<br>invalidated by adding new sentences. (旧事实失效)<br>• It cannot be used for theorem proving. (不能应用于定<br>理证明)<br>123<br>Introduction to AI<br>自然语言推理 Natural Language Inference<br> 自然语言是推理过程的解释手段，解释本身实际<br>上也可以视作一个推理过程—而且是最自然的推理<br>狭义的自然语言推理（Natural Language Inference,<br>NLI）也是自然语言理解（Natural Language Unders<br>tanding，NLU）的另一种形式&#x2F;称谓，主要任务包<br>括*：<br>指代消解REFERENCE RESOLUTION<br>问答QUESTION ANSWERING<br>文本蕴涵TEXTUAL ENTAILMENT<br>；可能性推理PLAUSIBLE INFERENCE—类似于溯因<br>推理等<br>124<br>Introduction to AI<br>基于自然语言的推理：NL-based Inference<br>随着大语言模型（Large Language Models, LLMs）的<br>出现，直接使用自然语言作为推理手段已经开始出<br>现，例如CoT：Chain-of-Thought（思维链）<br>125<br>Introduction to AI<br>Reasoning研究现状（2023-11-01）<br>• Aitopics上相关文献<br>(包括arXiv中的文章)<br>• 全部503412篇<br>• 其中机器学习方向<br>268294篇，列第一<br>位<br>• 表示与推理97496篇<br>列第二位<br>126<br>Introduction to AI<br>Reasoning研究现状（2024-10-28）<br>• 全部：669884<br>• Top 5<br>• Machine Learning<br>408185<br>• Representation &amp;<br>Reasoning 144323<br>• Natural Language<br>119813<br>• Vision 33280<br>• Issues 20023<br>127<br>最新现状：2025-08-23<br>比去年增长了17000<br>多篇<br>128<br>Introduction to AI<br>Summary<br>小结<br>Introduction to AI<br>小结<br>• AI发展在中国<br>• AI是什么？简言之：人类行为&#x2F;功能建模方法；；； &#x2F;<br>图灵测试基本上达成目标<br>• AI技术的一般&#x2F;抽象模型形式：Agent￾Environment交互<br>• AI应用—各行各业，需要时可以深入调研<br>• AI进展及SOTA—每天都在进步中：参见<br>Aitopics及AI顶会网站<br>• 大语言模型开启了人类迈向超级智能的时代<br>• 推理方法概览<br>130<br>Introduction to AI<br>We can see only a short<br>distance ahead, but we<br>can see that much<br>remains to be done.<br>— Alan Turing<br>131<br>Introduction to AI<br>References (1)<br>• Stuart Russell &#x2F; Peter Norvig: AIMA 第1章 &#x2F;第2<br>章 &#x2F;第26章 &#x2F; 第27章<br>• 陆汝钤 编著: 人工智能(上册) 引言<br>• Micheal Wooldridge，An introduction to multi￾agent systems，石纯一等译：多Agent系统引论，<br>电子工业出版社，2003<br>• IJCAI网址—<a href="http://ijcai.org/">http://ijcai.org/</a><br>• Aitopics网站—<a href="http://aitopics.org/">http://aitopics.org/</a><br>• 王飞跃，陆汝钤，曾大军，人工智能在中国，<br>中国计算机学会通讯，2008年第8期<br>132<br>133<br>References (2)<br>• Ruqian Lu，Daniel Zeng, Feiyue Wang, AI Resea<br>rch in China: 50 Years down the Road, IEEE Intell<br>igent Systems, Vol. 21, 2006, pp91-93<br>• 于剑，语言与图灵测试，自动化学报，2016，<br>第5期<br>• 田渊栋，阿法狗围棋系统的简要分析，自动化<br>学报，2016，第5期<br>• 周志华， AlphaGo专题介绍，自动化学报，<br>2016，第5期<br>• 郑南宁，人工智能面临的挑战，自动化学报，<br>2016，第5期<br>Introduction to AI<br>欢迎提出批评和建议！<br><a href="mailto:&#x74;&#106;&#122;&#104;&#x61;&#111;&#64;&#x68;&#105;&#x74;&#46;&#101;&#100;&#117;&#46;&#99;&#x6e;">&#x74;&#106;&#122;&#104;&#x61;&#111;&#64;&#x68;&#105;&#x74;&#46;&#101;&#100;&#117;&#46;&#99;&#x6e;</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Principle-and-Applications-of-Artificial-Intelligence&quot;&gt;&lt;a href=&quot;#Principle-and-Applications-of-Artificial-Intelligence&quot; class=&quot;heade</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>六级</title>
    <link href="https://example.com/2025/09/30/%E5%85%AD%E7%BA%A7/"/>
    <id>https://example.com/2025/09/30/%E5%85%AD%E7%BA%A7/</id>
    <published>2025-09-30T02:05:00.351Z</published>
    <updated>2025-09-30T02:15:44.126Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_01.png"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_02.png" alt="六级_02"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_03.png" alt="六级_03"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_04.png" alt="六级_04"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_05.png" alt="六级_05"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_06.png" alt="六级_06"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_07.png" alt="六级_07"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_08.png" alt="六级_08"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_09.png" alt="六级_09"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_10.png" alt="六级_10"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_11.png" alt="六级_11"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_12.png" alt="六级_12"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_13.png" alt="六级_13"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_14.png" alt="六级_14"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_15.png" alt="六级_15"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_16.png" alt="六级_16"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_17.png" alt="六级_17"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_18.png" alt="六级_18"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_19.png" alt="六级_19"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_20.png" alt="六级_20"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_21.png" alt="六级_21"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_22.png" alt="六级_22"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_23.png" alt="六级_23"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_24.png" alt="六级_24"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_25.png" alt="六级_25"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_26.png" alt="六级_26"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_27.png" alt="六级_27"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_28.png" alt="六级_28"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_29.png" alt="六级_29"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_30.png" alt="六级_30"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_31.png" alt="六级_31"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_32.png" alt="六级_32"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_33.png" alt="六级_33"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_34.png" alt="六级_34"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_35.png" alt="六级_35"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_36.png" alt="六级_36"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_37.png" alt="六级_37"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_38.png" alt="六级_38"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_39.png" alt="六级_39"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_40.png" alt="六级_40"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_41.png" alt="六级_41"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_42.png" alt="六级_42"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_43.png" alt="六级_43"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_44.png" alt="六级_44"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_45.png" alt="六级_45"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_46.png" alt="六级_46"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_47.png" alt="六级_47"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_48.png" alt="六级_48"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_49.png" alt="六级_49"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_50.png" alt="六级_50"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_51.png" alt="六级_51"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_52.png" alt="六级_52"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_53.png" alt="六级_53"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_54.png" alt="六级_54"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_55.png" alt="六级_55"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_56.png" alt="六级_56"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_57.png" alt="六级_57"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_58.png" alt="六级_58"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_59.png" alt="六级_59"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_60.png" alt="六级_60"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_61.png" alt="六级_61"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_62.png" alt="六级_62"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_63.png" alt="六级_63"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_64.png" alt="六级_64"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_65.png" alt="六级_65"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_66.png" alt="六级_66"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_67.png" alt="六级_67"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_68.png" alt="六级_68"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_69.png" alt="六级_69"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_70.png" alt="六级_70"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_71.png" alt="六级_71"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_72.png" alt="六级_72"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_73.png" alt="六级_73"></p><p><img src="/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_74.png" alt="六级_74"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/09/30/%E5%85%AD%E7%BA%A7/%E5%85%AD%E7%BA%A7_0</summary>
      
    
    
    
    <category term="英语" scheme="https://example.com/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="六级" scheme="https://example.com/tags/%E5%85%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>项目</title>
    <link href="https://example.com/2025/03/19/PROJECT/"/>
    <id>https://example.com/2025/03/19/PROJECT/</id>
    <published>2025-03-19T13:51:59.038Z</published>
    <updated>2025-03-20T04:06:36.576Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/19/PROJECT/PROJECT.png"></p><p><img src="/2025/03/19/PROJECT/PROJECT2.png" alt="PROJECT2"></p><p><img src="/2025/03/19/PROJECT/PROJECT3.png" alt="PROJECT3"></p>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="项目" scheme="https://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>MACHINE</title>
    <link href="https://example.com/2025/03/19/report/"/>
    <id>https://example.com/2025/03/19/report/</id>
    <published>2025-03-19T13:26:38.939Z</published>
    <updated>2025-10-24T11:55:01.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Final-Project"><a href="#Final-Project" class="headerlink" title="Final Project"></a>Final Project</h1><h2 id="Team-Info"><a href="#Team-Info" class="headerlink" title="Team  Info"></a>Team  Info</h2><table><thead><tr><th>English Name</th><th>Chinese Name</th><th>ID</th></tr></thead><tbody><tr><td>Jing Shuji</td><td>荆树吉</td><td>202000130199</td></tr><tr><td>Zeng Junhao</td><td>曾俊豪</td><td>202000130222</td></tr></tbody></table><h2 id="Dataset1-Bank-Marketing（classification"><a href="#Dataset1-Bank-Marketing（classification" class="headerlink" title="Dataset1: Bank Marketing（classification)"></a>Dataset1: Bank Marketing（classification)</h2><h3 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a>Assignment1</h3><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>​       Based on the classic marketing dataset of banks, the user characteristics and the current status of bank deposit business are analyzed to formulate bank marketing strategies. Major domestic banks and Internet wealth management institutions can learn from the marketing of bank deposit products.These data are related to the marketing activities of Portuguese banking institutions. These marketing campaigns are based on phone calls, and the bank’s customer service staff is required to contact the customer at least once to confirm whether the customer will subscribe to the bank’s products (fixed deposits)</p><h4 id="Data-description"><a href="#Data-description" class="headerlink" title="Data description"></a>Data description</h4><p>​       The data is related with direct marketing campaigns of a Portuguese banking institution. The marketing campaigns were based on phone calls. Often, more than one contact to the same client was required, in order to access if the product (bank term deposit) would be (‘yes’) or not (‘no’) subscribed. </p><p>There are four datasets: </p><ol><li><p>bank-additional-full.csv with all examples (41188) and 20 inputs, ordered by date (from May 2008 to November 2010), very close to the data analyzed in [Moro et al., 2014] </p></li><li><p>bank-additional.csv with 10% of the examples (4119), randomly selected from 1), and 20 inputs. </p></li><li><p>bank-full.csv with all examples and 17 inputs, ordered by date (older version of this dataset with less inputs). </p></li><li><p>bank.csv with 10% of the examples and 17 inputs, randomly selected from 3 (older version of this dataset with less inputs). The smallest datasets are provided to test more computationally demanding machine learning algorithms (e.g., SVM).</p></li></ol><p>​       The classification goal is to predict if the client will subscribe (yes&#x2F;no) a term deposit (variable y).</p><p>We only use bank full. csv to segment into training and testing sets</p><p>​       Among all the Y attributes, the majority of customers did not complete their fixed deposit subscription in the end, and over 88% of customers did not choose to subscribe. The remaining 11% of customers chose not to subscribe to fixed deposits, as shown in the following figure.</p><p><img src="/2025/03/19/report/image-20231229205914231.png" alt="image-20231229205914231"></p><h4 id="Data-preprocessing"><a href="#Data-preprocessing" class="headerlink" title="Data preprocessing"></a>Data preprocessing</h4><h5 id="Remove-missing-values"><a href="#Remove-missing-values" class="headerlink" title="Remove missing values"></a>Remove missing values</h5><p>​       Through the corresponding introduction of the website where the data is located, it can be known that there are no missing values in the corresponding data. After verifying the integrity of the data through code, it is also known that there are no missing values in the attributes of the data.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(bank_data.isnull().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p><img src="/2025/03/19/report/image-20231229211152814.png" alt="image-20231229211152814"></p><h5 id="Remove-outliers"><a href="#Remove-outliers" class="headerlink" title="Remove outliers"></a>Remove outliers</h5><p>​       For all non character attributes of continuity in data, through the analysis of the boxplot, we can see that there are many outliers in the four attributes of Campaign, Balance, Duration, and Pdays. Therefore, it is necessary to remove outliers, and the corresponding outliers are shown in the following figure.</p><p><img src="/2025/03/19/report/image-20231229213414496.png" alt="image-20231229213414496"></p><p>​       Therefore, Python code is used to process the corresponding data with outliers, using 3 σ Method to filter outliers.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_outliers</span>(<span class="params">df, column</span>):</span><br><span class="line">    mean = df[column].mean()</span><br><span class="line">    std = df[column].std()</span><br><span class="line">    df = df[(df[column] &gt; mean - <span class="number">3</span> * std) &amp; (df[column] &lt; mean + <span class="number">3</span> * std)]</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><p>​       After processing, the box diagrams for Y and Campaign, Balance, Duration, and Pdays are shown below</p><p><img src="/2025/03/19/report/image-20231229214807962.png" alt="image-20231229214807962"></p><p>​       It can be seen that this method has great effectiveness.</p><h5 id="Data-normalization"><a href="#Data-normalization" class="headerlink" title="Data normalization"></a>Data normalization</h5><p>​       Since all data contains different ranges and not all data can be digitized, we need to normalize the data. Therefore, we need to perform a normalization operation: <strong>normalize&#x3D;lambda x: (x-x.mean())&#x2F;(x.max() - x.min())</strong> . Namely, mean normalization. Corresponding to the formula shown in the following figure:</p><p><img src="/2025/03/19/report/image-20231228234155051.png"></p><h4 id="Analyze-the-data"><a href="#Analyze-the-data" class="headerlink" title="Analyze the data"></a>Analyze the data</h4><p>​       Due to the need for classification methods, all data should be considered, not just numerical data. So we will analyze the relationship between education and loan.Explore the corresponding debt situation at each learning stage, as debt situation has a significant impact on whether to apply for fixed deposits.The relationship between the two is shown in the following figure.</p><p><img src="/2025/03/19/report/image-20231229223427026.png" alt="image-20231229223427026"></p><p>​       Among them, the number of people with a secondary education background is the highest, and they are easily in debt. Nearly 20% of them still have outstanding loans, while the number of people who choose not to fill in their education background is the lowest, and less than 8% of them have outstanding loans.</p><p>​       When it comes to corresponding liabilities, the relationship between age savings and education cannot be avoided.</p><p><img src="/2025/03/19/report/image-20231229230243866.png" alt="image-20231229230243866"></p><p>​       It can be seen that people with a primary school diploma usually have less savings, as the corresponding dataset for primary school is located closer to the X-axis.</p><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p>​       Firstly, we analyzed the distribution range of corresponding Y. Afterwards, we analyzed the relationship between the attributes of the numerical part and Y, identified outliers through the corresponding boxplot of the distribution, and utilized 3 σ The method solves the problem of outliers and verifies it. Afterwards, we discovered some simple relationships between education, age, and wage debt.</p><h3 id="Assignment-2"><a href="#Assignment-2" class="headerlink" title="Assignment 2"></a>Assignment 2</h3><h4 id="Attribute-selection"><a href="#Attribute-selection" class="headerlink" title="Attribute selection"></a>Attribute selection</h4><p>​       We need to choose several excellent selection methods to select several excellent attributes. If we adopt the importance ranking mechanism for corresponding attributes, we will choose the top five. The following are six corresponding situations. They are respectively</p><p><strong>BestFirst+CfsSubsetEval(forward,backward,bi-directional)</strong></p><p><strong>Ranker+InfoGainAttributeEval</strong></p><p><strong>Ranker+GainRatioAttributeEval</strong></p><p><strong>GreedyStepwise+WrapperSubsetEval</strong></p><p>​       And evaluate with J48 with the same parameters</p><p><img src="/2025/03/19/report/image-20231230165342652.png"><img src="/2025/03/19/report/image-20231230165433780.png"></p><p><img src="/2025/03/19/report/image-20231230165524240.png"></p><p><img src="/2025/03/19/report/image-20231230165611478.png"></p><p><img src="/2025/03/19/report/image-20231230165710064.png"></p><p><img src="/2025/03/19/report/image-20231230170013793.png"></p><p>​       The corresponding six methods have 4 different attribute choices, and the accuracy of J48 corresponding to the same parameter is shown in the table below：</p><table><thead><tr><th>method</th><th>accuracy</th></tr></thead><tbody><tr><td><strong>BestFirst+CfsSubsetEval(forward,backward,bi-directional)</strong></td><td>90.8482%</td></tr><tr><td><strong>Ranker+InfoGainAttributeEval</strong></td><td>91.0979%</td></tr><tr><td><strong>Ranker+GainRatioAttributeEval</strong></td><td>90.7447 %</td></tr><tr><td><strong>GreedyStepwise+WrapperSubsetEval</strong></td><td>91.588 %</td></tr></tbody></table><p>​       So our selection method is the last one<strong>GreedyStepwise+WrapperSubsetEval</strong></p><p>​       The final attribute selection is shown in the following table</p><table><thead><tr><th>Attributes</th><th>If we choose</th></tr></thead><tbody><tr><td>age</td><td>False</td></tr><tr><td>job</td><td>True</td></tr><tr><td>marital</td><td>True</td></tr><tr><td>education</td><td>False</td></tr><tr><td>default</td><td>False</td></tr><tr><td>balance</td><td>False</td></tr><tr><td>housing</td><td>False</td></tr><tr><td>loan</td><td>False</td></tr><tr><td>contact</td><td>True</td></tr><tr><td>day</td><td>True</td></tr><tr><td>month</td><td>True</td></tr><tr><td>duration</td><td>True</td></tr><tr><td>campaign</td><td>False</td></tr><tr><td>pdays</td><td>False</td></tr><tr><td>previous</td><td>False</td></tr><tr><td>poutcome</td><td>True</td></tr></tbody></table><h4 id="Learn-scheme"><a href="#Learn-scheme" class="headerlink" title="Learn scheme"></a>Learn scheme</h4><p>​       This dataset is only used for classification, and WEKA contains many classification ：method models. We ultimately chose <strong>OneR, Naive Bayesian,J48,  KNN, and stacking</strong>,We ultimately chose an 8:2 ratio between the training and testing sets。</p><h5 id="OneR"><a href="#OneR" class="headerlink" title="OneR"></a>OneR</h5><p>​       OneR is the meaning of One Rule, which is a rule that only looks at one feature of a certain thing and then predicts its category (selecting a feature with a low error rate).<br>​        By testing the processed dataset, we achieved an accuracy of 90.492%.</p><p><img src="/2025/03/19/report/image-20231230170510166.png"></p><p>​       Adjusting minBuchetSize does not change the corresponding accuracy, so the default corresponding result is the optimal OneR result. It can be seen that even the simplest OneR method can achieve significant accuracy.</p><h5 id="Naive-Bayesian"><a href="#Naive-Bayesian" class="headerlink" title="Naive Bayesian"></a>Naive Bayesian</h5><p>​       Naive Bayesian algorithm is one of the most widely used classification algorithms.<br>The Naive Bayesian method is a simplification of the Bayesian algorithm, which assumes that the attributes are conditionally independent of each other when the target value is given. That is to say, no attribute variable has a significant proportion to the decision result, and no attribute variable has a small proportion to the decision result. Although this simplification approach reduces the classification performance of Bayesian classification algorithms to a certain extent, it greatly simplifies the complexity of Bayesian methods in practical application scenarios.</p><h6 id="Algorithm-principle"><a href="#Algorithm-principle" class="headerlink" title="Algorithm principle"></a>Algorithm principle</h6><p>​       <strong>Assumption of characteristic conditions</strong>Assuming there is no connection between each feature, given a training dataset where each sample<img src="https://latex.csdn.net/eq?x" alt="x">all include n-dimensional features，即<img src="https://latex.csdn.net/eq?x%20=%20(%7Bx_1%7D,%7Bx_2%7D,%20%5Ccdots%20,%7Bx_n%7D)" alt="x = ({x_1},{x_2}, \cdots ,{x_n})">，Class tag set contains K categories，assume<img src="/2025/03/19/report/eq.png"></p><p>​       For a given new sample<img src="https://latex.csdn.net/eq?x" alt="x">，To determine which category it belongs to, according to Bayesian theorem, one can obtain<img src="https://latex.csdn.net/eq?x" alt="x">belong <img src="https://latex.csdn.net/eq?%7By_k%7D" alt="{y_k}"> Probability <img src="https://latex.csdn.net/eq?P(%7By_k%7D%7Cx)" alt="P({y_k}|x)"></p><p>![P({y_k}|x) &#x3D; \frac</p>]]></content>
    
    
    <summary type="html">机器学习</summary>
    
    
    
    <category term="机器学习" scheme="https://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Machine learning" scheme="https://example.com/tags/Machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>（hexo github）搭建云平台</title>
    <link href="https://example.com/2025/03/19/ok/"/>
    <id>https://example.com/2025/03/19/ok/</id>
    <published>2025-03-19T12:58:46.784Z</published>
    <updated>2025-09-01T03:44:49.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学实验报告3-1"><a href="#山东大学实验报告3-1" class="headerlink" title="山东大学实验报告3-1"></a>山东大学实验报告3-1</h1><h2 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h2><h2 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h2><table><thead><tr><th align="left"><strong>学号：202000130199  |姓名：荆树吉 |  班级：20数据</strong></th></tr></thead><tbody><tr><td align="left"><strong>实验题目：利用云平台搭建个人博客</strong></td></tr><tr><td align="left">**实验学时：2|<strong>实验日期： 2023.3.15</strong></td></tr><tr><td align="left"><strong>实验目的：熟悉个人博客系统的搭建。<br>具体包括：<br>参考方案：注册Github账号，搭建Hexo环境并实现个人博客搭建，撰写实验报告。</strong></td></tr><tr><td align="left"><strong>硬件环境： <br>联网的计算机一台</strong></td></tr><tr><td align="left">**软件环境：<br>Windows **</td></tr><tr><td align="left"><strong>实验步骤与内容：</strong></td></tr><tr><td align="left">•    1.安装Git<br>•<strong>windows：</strong>到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。<br>•2.安装Node.js<br>•<strong>windows：</strong>下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。<br>•3.安装Hexo<br>•前面git和nodejs安装好后，就可以安装hexo了，可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）<br>•定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，无视它就行<br>•npm install -g hexo-cli<br>•安装完后输入hexo -v验证是否安装成功。<br>•<br>•至此hexo就安装完了。<br>hexo init<br>这个Hexo可以自己取什么名字都行，然后，接着输入npm install安装必备的组件。<br><br>新建完成后，指定文件夹Hexo目录下有：<br><br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题**<br>_config.yml: 博客的配置文件**<br>这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，<br> <br><img src="/2025/03/19/ok/1.png" alt="初始">•4.GitHub创建个人仓库<br>•打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93New">https://github.com/，新建一个项目仓库New</a> repository，如下所示：<br>• <br><img src="/2025/03/19/ok/2.png" alt="建仓库"><br>•生成SSH添加到GitHub，连接Github与本地。<br>•右键打开git bash，然后输入下面命令：<br>•git config –global user.name “yourname”<br>•git config –global user.email “youremail”<br>•注意：第一次使用git后需要将用户名和邮箱进行初始化<br>•<br>•这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。例如<br>•git config –global user.name “jsj12345”<br>•git config –global user.email “<a href="mailto:&#x32;&#x31;&#x31;&#53;&#53;&#50;&#x35;&#x38;&#x33;&#x32;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;">&#x32;&#x31;&#x31;&#53;&#53;&#50;&#x35;&#x38;&#x33;&#x32;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;</a>”<br>•可以用以下两条，检查一下你有没有输对<br>•git config user.name<br>•git config user.email<br>•然后创建SSH,一路回车<br>•ssh-keygen -t rsa -C “youremail”<br>•cat ~&#x2F;.ssh&#x2F;id_rsa.pub<br>•打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图：<br>• <br><img src="/2025/03/19/ok/3.png" alt="密钥">)在git bash输入ssh -T <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>，如果如下图所示，出现你的用户名，那就成功了。<br>•6.将hexo部署到GitHub<br>•这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息<br>•修改最后一行的配置：<br>• deploy:<br>•  type: git<br>•  repository: <a href="https://github.com/jsj12345/jsj12345.github.io.git">https://github.com/jsj12345/jsj12345.github.io.git</a><br>•  branch: master<br>•repository修改为你自己的github项目地址即可就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。<br>•<br>•这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br>•npm install hexo-deployer-git –save<br>•hexo clean<br>•hexo generate<br>•hexo deploy<br>•<br>•7.设置个人域名<br>•可省略因为需要花钱，且意义不明显<br>•8.发布文章<br>•首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。<br>•<br>•然后输入hexo new post “我的第一篇博客”，新建一篇文章。<br>•<br>•然后打开D:\Hexo\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>•你可以会直接在vscode里面编写markdown文件，可以实时预览，也可以用用其他编辑md文件的软件的工具编写。<br>•编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。<br>•<br>•到这儿基本第一部分就完成了，已经完整搭建起一个比较简陋的个人博客了，接下来我们就可以对我们的博客进行个性化定制了。<br>个性化定制暂略</td></tr><tr><td align="left">结论分析与体会：Hexo是高效的静态网站生成框架，它基于Node.js，快速，简单且功能强大，是搭建博客的首选框架。通过Hexo，我们可以直接使用Markdown语法来撰写博客</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">实验报告3-1</summary>
    
    
    
    <category term="云计算" scheme="https://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云平台搭建" scheme="https://example.com/tags/%E4%BA%91%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://example.com/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://example.com/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2024-11-08T09:38:54.817Z</published>
    <updated>2025-03-19T12:43:46.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a><strong>第一章 绪论</strong></h1><h2 id="1-0数据结构在学什么"><a href="#1-0数据结构在学什么" class="headerlink" title="1.0数据结构在学什么"></a>1.0数据结构在学什么</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108174722732.png" alt="image-20241108174722732"></p><p>数据结构在学什么？</p><h2 id="1-1数据结构的基本概念"><a href="#1-1数据结构的基本概念" class="headerlink" title="1.1数据结构的基本概念"></a>1.1数据结构的基本概念</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108174919164.png" alt="image-20241108174919164"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108175451336.png" alt="image-20241108175451336"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108175525061.png" alt="image-20241108175525061"></p><h2 id="1-2算法和算法评价"><a href="#1-2算法和算法评价" class="headerlink" title="1.2算法和算法评价"></a>1.2算法和算法评价</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108175701029.png" alt="image-20241108175701029"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180051207.png" alt="image-20241108180051207"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180158724.png" alt="image-20241108180158724"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180432547.png" alt="image-20241108180432547"></p><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1线性表的定义和基本操作"><a href="#2-1线性表的定义和基本操作" class="headerlink" title="2.1线性表的定义和基本操作"></a>2.1线性表的定义和基本操作</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180646358.png" alt="image-20241108180646358"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108180813550.png" alt="image-20241108180813550"></p><h2 id="2-2线性表的顺序表示"><a href="#2-2线性表的顺序表示" class="headerlink" title="2.2线性表的顺序表示"></a>2.2线性表的顺序表示</h2><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181153520.png" alt="image-20241108181153520"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181556403.png" alt="image-20241108181556403"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181804317.png" alt="image-20241108181804317"></p><h2 id="2-3顺序表的链式表示"><a href="#2-3顺序表的链式表示" class="headerlink" title="2.3顺序表的链式表示"></a>2.3顺序表的链式表示</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108181937655.png" alt="image-20241108181937655"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182046854.png" alt="image-20241108182046854"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182232557.png" alt="image-20241108182232557"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182311322.png" alt="image-20241108182311322"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182544821.png" alt="image-20241108182544821"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108182823312.png" alt="image-20241108182823312"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183145884.png" alt="image-20241108183145884"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183440275.png" alt="image-20241108183440275"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183621669.png" alt="image-20241108183621669"></p><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108183932454.png" alt="image-20241108183932454"></p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><img src="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241108184320710.png" alt="image-20241108184320710"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义双链表</span></span><br><span class="line"><span class="keyword">typedef</span> sturct dnode&#123;            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    elemtype data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dnode</span> *prior,*next;   <span class="comment">//前驱与后继指针</span></span><br><span class="line">&#125;dnode, *dlinklist;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initdlinklist</span><span class="params">(dlinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (dnode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(dnode));    <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    l-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testdlinklist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    dlinklist L;</span><br><span class="line">    <span class="built_in">initdlinklist</span>(L);</span><br><span class="line">    <span class="comment">//后续代码...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断双链表是否为空(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(dlinklist L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//双链表的插入</span></span><br><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insertnextdnode</span><span class="params">(dnode *p, dnode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>)                <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next !=<span class="literal">NULL</span>)                    <span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-&gt;next-&gt;prior=s;</span><br><span class="line">    s-&gt;prior=p;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//双链表的删除</span></span><br><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deletenextdnode</span><span class="params">(dnode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    dnode *q = p-&gt;next;                    <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//p没有后继</span></span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next !=<span class="literal">NULL</span>)                    <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环单链表：最后一个节点的指针指向第一个节点</p><p>循环双链表：表头节点的前驱指向表尾结点；表尾结点的后继指向头结点</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义静态链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10            <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;          <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    elemtype data;            <span class="comment">//存储数据元</span></span><br><span class="line">    <span class="type">int</span> next;                 <span class="comment">//下一个元素的数组下标素</span></span><br><span class="line">&#125;slinklist[maxsize],slist;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1栈的定义"><a href="#3-1栈的定义" class="headerlink" title="3.1栈的定义"></a>3.1栈的定义</h2><p>栈：是只允许在一端进行插入或删除操作的线性表</p><p>栈顶：允许插入和删除的一方</p><p>栈底：不允许插入与删除的一方</p><p>栈的特点：先进后出</p><h2 id="3-2栈的基本操作"><a href="#3-2栈的基本操作" class="headerlink" title="3.2栈的基本操作"></a>3.2栈的基本操作</h2><p>InitStack(&amp;S) ： 初始化 栈。构造一个空栈 S ， 分配内存空间 。</p><p>DestroyStack(&amp;S) ： 销毁 栈。销毁并 释放 栈 S 所占用的 内存空间 。</p><p>Push(&amp;S,x) ： 进栈 ，若栈 S 未满，则将 x 加入使之成为新栈顶。</p><p>Pop(&amp;S,&amp;x) ： 出栈 ，若栈 S 非空，则弹出栈顶元素，并用 x 返回。</p><p>GetTop(S, &amp;x) ： 读栈顶元素 。若栈 S 非空，则用 x 返回栈顶元素</p><p>其他常用操作：</p><p>StackEmpty(S) ：判断一个栈 S 是否为空。若 S 为空，则返回 true ，否则返回 false 。</p><p>顺序栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序栈的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10                <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    elemtype data[maxsize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;sqstack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(sqstack &amp;s)</span></span>&#123;</span><br><span class="line">    s.top=<span class="number">-1</span>;                     <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">stackempty</span><span class="params">(sqstack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)                <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(sqstack &amp;s, elemtype x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==maxsize<span class="number">-1</span>)          <span class="comment">//栈满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s.top=s.top+<span class="number">1</span>;</span><br><span class="line">    s.data[s.top]=x;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(sqstack &amp;s,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)                <span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=s.data[s.top--];           <span class="comment">//栈顶元素出栈，指针减一</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gettop</span><span class="params">(sqstack s,elemtype &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)                  <span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=s.data[s.top];                <span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义共享栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10                <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    elemtype data[maxsize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;shstack</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initstack</span><span class="params">(shstack &amp;s)</span></span>&#123;</span><br><span class="line">    s.top0=<span class="number">-1</span>;                    <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    s.top1=maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链栈的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">linknode</span>&#123;</span><br><span class="line">    elemtype data;                <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linknode</span> *next;        <span class="comment">//指针域</span></span><br><span class="line">&#125; *listack;                       <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="数据结构" scheme="https://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>nlp05</title>
    <link href="https://example.com/2024/10/01/nlp05/"/>
    <id>https://example.com/2024/10/01/nlp05/</id>
    <published>2024-10-01T01:58:39.754Z</published>
    <updated>2025-03-19T12:39:10.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验5-词向量"><a href="#实验5-词向量" class="headerlink" title="实验5 词向量"></a>实验5 词向量</h2><h4 id="1-One-hot编码实验"><a href="#1-One-hot编码实验" class="headerlink" title="1.One-hot编码实验"></a>1.One-hot编码实验</h4><h5 id="1-1-实验介绍"><a href="#1-1-实验介绍" class="headerlink" title="1.1 实验介绍"></a>1.1 实验介绍</h5><p>One-hot编码也称之为独热编码，是NLP里的经常在预处理数据的时候使用的技术。通常是需要将离散型特征或者标签用One-hot编码。比如房价预测中，出现房屋朝向的特征，一共有南、东南、西南、东、东北、北、西北和西8个方向，那么这样的离散特征是需要One-hot编码的，比如“南”的one-hot编码为[1,0,0,0,0,0,0,0]，“东南”的One-hot编码为[0,1,0,0,0,0,0,0]…依此类推。</p><h4 id="1-2-实验要求"><a href="#1-2-实验要求" class="headerlink" title="1.2 实验要求"></a>1.2 实验要求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="string">&#x27;体育&#x27;</span>, <span class="string">&#x27;军事&#x27;</span>, <span class="string">&#x27;娱乐&#x27;</span>, <span class="string">&#x27;教育&#x27;</span>, <span class="string">&#x27;文化&#x27;</span>, <span class="string">&#x27;时尚&#x27;</span>, <span class="string">&#x27;科技&#x27;</span>, <span class="string">&#x27;财经&#x27;</span>]</span><br><span class="line">onehot_encode(x)</span><br></pre></td></tr></table></figure><p>编写onehot_encode函数，生成效果如下：</p><p><img src="/2024/10/01/nlp05/image-20210304202934556.png" alt="image-20210304202934556"></p><p><strong>提示</strong>：可以使用sklearn.preprocessing中的OneHotEncoder</p><h5 id="1-3-思考题"><a href="#1-3-思考题" class="headerlink" title="1.3 思考题"></a>1.3 思考题</h5><p>从one-hot编码结果来看，one-hot编码的缺点是什么？</p><h4 id="2-Word2vec词向量训练"><a href="#2-Word2vec词向量训练" class="headerlink" title="2.Word2vec词向量训练"></a>2.Word2vec词向量训练</h4><p>Word2vec是Google在2013年开源的一款用于词向量计算的工具，一经发布就引起了工业界和学术界的关注。首先，Word2vec可以在百万数量级的词典和上亿的数据集上进行高效地训练；其次，该工具训练得到的词向量（word embedding），可以很好地度量词与词之间的相似性。Word2vec不是一种深度学习算法，其后面只是一个浅层神经网络，包含两种模型：CBOW模型和Skip-gram模型。</p><p>本实验主要是基于Python和gensim框架实现Word2vec在Wikipedia语料集上面的应用，并且获取词的词向量以及寻找相近词。</p><h5 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1 数据集"></a>2.1 数据集</h5><p>数据来源于维基语料</p><p>数据链接：<a href="https://icloud.qd.sdu.edu.cn:7777/link/28AA675BD5725B6D09B317234579B273">https://icloud.qd.sdu.edu.cn:7777/link/28AA675BD5725B6D09B317234579B273</a><br>有效期限：2021-05-20</p><p>共计33w条数据，数据太大，可以取10w条（或5w，数据量太小容易导致训练结果不佳）进行实验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据处理部分</span></span><br><span class="line"><span class="keyword">from</span> gensim.corpora <span class="keyword">import</span> WikiCorpus</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> word2vec</span><br><span class="line"><span class="keyword">import</span> zhconv <span class="comment">#繁体字简体字转换</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">input_file_name = <span class="string">&#x27;zhwiki-latest-pages-articles.xml.bz2&#x27;</span></span><br><span class="line">output_file_name = <span class="string">&#x27;corpus_cn.txt&#x27;</span></span><br><span class="line"><span class="comment">#加载数据</span></span><br><span class="line">input_file = WikiCorpus(input_file_name, lemmatize=<span class="literal">False</span>, dictionary=&#123;&#125;)</span><br><span class="line"><span class="comment">#将lemmatize设置为False的主要目的是不使用pattern模块来进行英文单词的词干化处理，无论你的电脑#是否已经安装了pattern，因为使用pattern会严重影响这个处理过程，变得很慢</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(output_file_name, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> output_file:</span><br><span class="line"><span class="comment">#使用WikiCorpus类中的get_texts()方法读取文件，每篇文章转换为一行文本，并去掉标签符号等内容</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> input_file.get_texts():</span><br><span class="line">        output_file.write(<span class="string">&#x27; &#x27;</span>.join(text) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;已处理%d条数据&#x27;</span> % count)            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;处理完成！&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#查看处理结果</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;corpus_cn.txt&#x27;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.readlines()[:<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h5 id="2-2-基本步骤"><a href="#2-2-基本步骤" class="headerlink" title="2.2 基本步骤"></a>2.2 基本步骤</h5><ol><li><p><strong>预处理</strong>：包括繁体-&gt;简体转换，分词，去除非中文词等主要步骤。</p></li><li><p><strong>训练词向量</strong>：使用gensim训练并保存model。</p></li><li><p><strong>加载模型并测试效果</strong>：如查看词汇的词向量，获取与某词汇最相关的n个词。</p></li></ol><p>例如：<img src="/2024/10/01/nlp05/image-20210304213009944.png" alt="image-20210304213009944"></p>]]></content>
    
    
    <summary type="html">8</summary>
    
    
    
    <category term="nlp" scheme="https://example.com/categories/nlp/"/>
    
    
    <category term="词向量" scheme="https://example.com/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>KVM环境配置</title>
    <link href="https://example.com/2024/10/01/KVM/"/>
    <id>https://example.com/2024/10/01/KVM/</id>
    <published>2024-10-01T01:58:39.751Z</published>
    <updated>2025-03-19T12:38:32.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h2 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h2><table><thead><tr><th>学号：</th><th>姓名：</th><th>班级：</th></tr></thead><tbody><tr><td>202000130199</td><td>荆树吉</td><td>20数据</td></tr></tbody></table><table><thead><tr><th>实验题目：虚拟化技术练习三KVM</th><th></th></tr></thead><tbody><tr><td>实验学时：2</td><td>实验日期：  2023.4.8</td></tr></tbody></table><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>在Linux环境下，熟悉KVM虚拟化环境。</p><p>具体包括：了解KVM虚拟化环境的配置和部署，完成实验环境及实验工具的熟悉，撰写实验报告。</p><h3 id="硬件环境："><a href="#硬件环境：" class="headerlink" title="硬件环境："></a>硬件环境：</h3><p>联网的计算机一台</p><h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3><p>Linux</p><h3 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h3><h4 id="一．先决条件"><a href="#一．先决条件" class="headerlink" title="一．先决条件"></a>一．先决条件</h4><p>要运行带有2 GB以上RAM的guest虚拟机，对应的虚拟环境必须拥有64位主机系统</p><p>再继续安装之前，要确保对应的ubundu虚拟机支持KVM虚拟化，系统应具有VT-x(vmx)的Intel处理器或具有AMD-V(svm)技术的AMD处理器。</p><p>以下grep命令以验证您的处理器支持硬件虚拟化：</p><p>grep -Eoc ‘(vmx|svm)’ &#x2F;proc&#x2F;cpuinfo</p><p>如果CPU支持硬件虚拟化，则该命令将输出一个大于零的数字，即CPU核心的数量。否则，如果输出是，0则表示CPU不支持硬件虚拟化。比如我对应的输出结果就是4</p><p>在某些计算机上，制造商可能会在BIOS中禁用虚拟技术扩展。</p><p>要检查BIOS中是否启用了VT，请使用kvm-ok软件包中随附的工具。以超级用户或具 有sudo特权的用户身份输入以下命令来安装cpu-checker包含该kvm-ok命令的软件包：</p><p>   sudo apt update</p><p>sudo apt install cpu-checker</p><p>安装完成后，检查我的系统是否可以运行硬件加速的KVM虚拟机：</p><p>kvm-ok</p><p>如果未在BIOS中禁用处理器虚拟化功能，则输出将如下所示：</p><p>INFO: &#x2F;dev&#x2F;kvm exists</p><p>KVM acceleration can be used</p><h4 id="二．在Ubuntu-20-04上安装KVM"><a href="#二．在Ubuntu-20-04上安装KVM" class="headerlink" title="二．在Ubuntu 20.04上安装KVM"></a>二．在Ubuntu 20.04上安装KVM</h4><p>运行以下命令以安装KVM和其他虚拟化管理软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager</span><br></pre></td></tr></table></figure><p>qemu-kvm -为KVM管理程序提供硬件仿真的软件。</p><p>libvirt-daemon-system -用于将libvirt守护程序作为系统服务运行的配置文件。</p><p>libvirt-clients -用于管理虚拟化平台的软件。</p><p>bridge-utils -一组用于配置以太网桥的命令行工具。</p><p>virtinst -一组用于创建虚拟机的命令行工具。</p><p>virt-manager -易于使用的GUI界面和支持命令行工具，用于通过libvirt管理虚拟机。</p><p>安装软件包后，libvirt守护程序将自动启动。您可以通过键入以下内容进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl is-active libvirtd</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">active</span><br></pre></td></tr></table></figure><p>为了能够创建和管理虚拟机，需要将用户添加到“ libvirt”和“ kvm”组中。为此，请输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG libvirt <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line">sudo usermod -aG kvm <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>$USER 是一个环境变量，其中包含当前登录用户的名称。</p><p>注销并重新登录，以便刷新组成员身份。</p><h4 id="三．网络设置"><a href="#三．网络设置" class="headerlink" title="三．网络设置"></a>三．网络设置</h4><p>在安装过程中会创建一个名为“ virbr0”的网桥。该设备使用NAT将来宾计算机连接到外界。</p><p>可以使用该brctl工具列出当前网桥及其连接的接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brctl show</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="/2024/10/01/KVM/clip_image002.png" alt="img"></p><p>“ virbr0”网桥未添加任何物理接口。“ virbr0-nic”是虚拟设备，没有流量通过该虚拟设备。该设备的唯一目的是避免更改“ virbr0”网桥的MAC地址。</p><p>此网络设置适用于大多数Ubuntu桌面用户，但有局限性。如果要从本地网络外部访问来宾，则需要创建一个新的网桥并对其进行配置，以便来宾计算机可以通过主机物理接口连接到外部世界</p><h4 id="四．创建虚拟机"><a href="#四．创建虚拟机" class="headerlink" title="四．创建虚拟机"></a>四．创建虚拟机</h4><p>现在，我的Ubuntu桌面上已安装了KVM，您可以创建第一个VM。可以从命令行或使用virt-manager应用程序完成此操作。</p><p>下载要安装的操作系统的ISO映像，然后按照以下步骤创建虚拟机：</p><p>  我所选择的对应的ISO映像是</p><p>  CentOS-7.5-x86_64-DVD-1804.iso</p><ol><li><p>使用virt-manager打开对应的应用程序</p></li><li><p>启动应用程序后，从顶部菜单中单击“File”-&gt;“New Virtual Machine”：<img src="/2024/10/01/KVM/clip_image002-1681637740764-2.png" alt="img"></p></li><li><p>将会出现一个新窗口。选择“Local install media(ISO image or CDROM”，然后单击“Forward”按钮。<img src="/2024/10/01/KVM/clip_image004.png" alt="img"></p></li><li><p>提供ISO映像路径，然后单击“Forward”按钮。</p></li><li><p>在下一个屏幕中，选择VM的内存和CPU设置。单击前进。由于我的linux环境是对应的虚拟机，所以对应的内存我就没做具体设置，没有分配磁盘空间</p></li><li><p>接下来，选择“为虚拟机创建磁盘映像”，然后选择VM的磁盘空间大小。单击前进</p></li><li><p>输入您的虚拟机名称的名称，然后单击“完成”。</p></li><li><p>VM将启动，并打开一个新窗口：对应的KVM虚拟机是可以和一般的centos系统进行相同的操作，以下为对应的centos系统配置结果</p></li></ol><p><img src="/2024/10/01/KVM/clip_image002-1681637784065-5.png" alt="img"></p><p>KVM配置完成。</p><h3 id="结论分析与体会："><a href="#结论分析与体会：" class="headerlink" title="结论分析与体会："></a>结论分析与体会：</h3><p>对应的虚拟机的apt安装是需要设置一下的</p><p>KVM（基于内核的虚拟机）是内置在Linux内核中的开源虚拟化技术。本实验结果提供有关如何在Ubuntu 20.04桌面上安装和配置KVM的说明。我们还将向您展示如何创建可用作不同应用程序开发环境的虚拟机。</p><p>KVM（基于内核的虚拟机）是内置在Linux内核中的开源虚拟化技术。用KVM运行多个Linux或Windows来宾虚拟机。每个来宾都彼此完全隔离，并具有自己的操作系统和专用的虚拟硬件，例如CPU，内存，网络接口和存储。</p><p>本实验提供有关如何在Ubuntu 20.04桌面上安装和配置KVM的说明。</p>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="https://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="KVM" scheme="https://example.com/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境配置</title>
    <link href="https://example.com/2024/10/01/Docker/"/>
    <id>https://example.com/2024/10/01/Docker/</id>
    <published>2024-10-01T01:58:39.748Z</published>
    <updated>2024-10-02T11:30:15.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h1 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h1><table><thead><tr><th>学号：202000130199</th><th>姓名： 荆树吉</th><th>班级： 20 数据</th></tr></thead><tbody><tr><td>实验题目：虚拟化技术练习四Docker</td><td></td><td></td></tr><tr><td>实验学时：2</td><td>实验日期：  2023.4.15</td><td></td></tr></tbody></table><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><p>熟悉Docker虚拟化环境。</p><p>具体包括：了解Docker虚拟化环境的配置和部署，完成实验环境及实验工具的熟悉，包括使用官方镜像运行容器，以及借助官方镜像构建、运行自己的镜像和容器，撰写实验报告。</p><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境:"></a>硬件环境:</h2><p> 联网的计算机一台</p><h2 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h2><p>.15.0-69-generic #76~20.04.1-Ubuntu SMP Mon Mar 20 15:54:19 UTC 2023 x86_64 x86_64 x86_64 GNU&#x2F;Linux</p><h2 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h2><ol><li><h3 id="了解Docker虚拟化环境的配置和部署"><a href="#了解Docker虚拟化环境的配置和部署" class="headerlink" title="了解Docker虚拟化环境的配置和部署"></a>了解Docker虚拟化环境的配置和部署</h3><p>sudo apt-get -y install docker.io</p><p>安装完成后执行 docker，表明安装成功。</p><p>sudo docker pull ubuntu</p><p>安装完成之后默认会启动docker服务，如果没有启动和正常服务一样启动就好</p><p>docker version</p><p><img src="/2024/10/01/Docker/clip_image002.png" alt="docker version"></p></li><li><h3 id="使用官方镜像运行容器"><a href="#使用官方镜像运行容器" class="headerlink" title="使用官方镜像运行容器"></a>使用官方镜像运行容器</h3><p>查看下载到本地的所有镜像</p><p>docker images</p><p><img src="/2024/10/01/Docker/clip_image002-1681821166374-16.png" alt="docker images"></p><p> 查看容器</p><p> docker ps -a</p><p><img src="/2024/10/01/Docker/clip_image004.png" alt="查看容器"></p><p>删除镜像</p><p>docker rmi +镜像名</p><p>docker rmi +镜像标签</p><p><img src="/2024/10/01/Docker/clip_image006.png" alt="删除镜像"></p><p>下载镜像</p><p>docker pull +镜像名</p><p><img src="/2024/10/01/Docker/clip_image008.png" alt="下载镜像"></p><p>查看是否拉入镜像</p><p><img src="/2024/10/01/Docker/clip_image010.png" alt="查看是否拉入镜像"></p><p>已拉入</p><p>创建容器</p><p>docker create -it cengos:7 &#x2F;bin&#x2F;bash  &#x2F;&#x2F;创建一个新的容器但不启动它 #&#x2F;bin&#x2F;bash 交互   对应的镜像名</p><p>#选项：</p><p>-i ：  让容器的标准输入保持打开</p><p>-t ：  分配一个伪终端</p><p>-d ：  后台守护进程的方式运行</p><p>#去查询容器会发现状态为Created</p><p><img src="/2024/10/01/Docker/clip_image012.png" alt="查看容器"></p><p>启动容器</p><p>docker start 容器ID</p><p>打开刚刚创建的容器</p><p><img src="/2024/10/01/Docker/clip_image014.png" alt="启动容器"></p><p>停止容器</p><p>docker stop 容器id</p><p>停止刚刚打开的容器</p><p><img src="/2024/10/01/Docker/clip_image016.png" alt="停止容器"></p><p>容器已经被停止</p></li><li><h3 id="借助官方镜像构建、运行自己的镜像和容器"><a href="#借助官方镜像构建、运行自己的镜像和容器" class="headerlink" title="借助官方镜像构建、运行自己的镜像和容器"></a>借助官方镜像构建、运行自己的镜像和容器</h3><h4 id="①-建立dockerfile文件"><a href="#①-建立dockerfile文件" class="headerlink" title="① 建立dockerfile文件"></a>① 建立dockerfile文件</h4><p>（1） 新建工作目录dockertest，并新建Dockerfile。使用的命令如下：</p><p>mkdir dockertest</p><p>cd dockertest</p><p>touch Dockerfile </p><p>​       使用ls查看当前目录下的文件</p><p>​        <img src="/2024/10/01/Docker/clip_image002-1681821353211-25.png" alt="查看当前文件"></p><p>（2） 使用vim编辑Dockerfile</p><p><img src="/2024/10/01/Docker/clip_image004-1681821353212-26.png" alt="vim编辑Dockerfile"></p><p>其中，</p><p>  FROM ：定制的镜像都是基于 FROM 的镜像，也就是说，你的docker容器的系统。这里用的是ubuntu:latest，详细用法不再这里介绍，你可以在dockerhub上找其他的镜像。</p><p>  WORKDIR：你的工作目录，当你运行容器后，是一个ubuntu系统，在根目录会建立一个Mydata的目录。</p><p>  RUN：你可以暂且理解为制定镜像时，为ubuntu系统配置环境，安装一些包的命令执行过程。这里的run是我要配置一个opencv环境所要进行的操作，你可以按照你自己的需求来。</p><p>  CMD：执行docker run时默认执行的命令，docker在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat &#x2F;etc&#x2F;os-release。这就是用 cat &#x2F;etc&#x2F;os-release 命令替换了默认的 &#x2F;bin&#x2F;bash 命令了，输出了系统版本信息。</p><h4 id="②-制作docker镜像"><a href="#②-制作docker镜像" class="headerlink" title="② 制作docker镜像"></a>② 制作docker镜像</h4><p>在有Dockfile的这个目录下，执行该命令:</p><p>​    sudo docker build -t ubuntudocker:new .</p><p>​    由于自建的镜像较大，故只提供部分截图</p><p>​    <img src="/2024/10/01/Docker/clip_image002-1681821409004-29.png" alt="建立镜像"></p><p>​     可以使用下面的命令浏览有哪些镜像：</p><p><img src="/2024/10/01/Docker/clip_image004-1681821409005-30.png" alt="浏览镜像"></p><h4 id="③运行docker容器"><a href="#③运行docker容器" class="headerlink" title="③运行docker容器"></a>③运行docker容器</h4><p><img src="/2024/10/01/Docker/clip_image002-1681821468607-33.png" alt="运行并使用容器"></p><p>内部容器已经可以使用python3.10.6环境</p><p>打包镜像同上</p></li></ol><h2 id="结论分析与体会："><a href="#结论分析与体会：" class="headerlink" title="结论分析与体会："></a>结论分析与体会：</h2><p>docker是一种轻量级的虚拟机，docker是一个用于开发、交付、和运行应用程序的开放平台。</p><p>在linux容器里运行的开源工具：容器引擎，让开发者可以打包大量的应用及依赖包到一个可移植的镜像中，然后发布到任何流行的linux或者window机器中</p><p>进行实验的过程中需要不断的安装新的环境，要注意环境的兼容性</p><p>自己镜像的创建很费时间</p><p>docker引擎统一了基础设施环境–docker环境</p><p>docker引擎统一了程序打包（装箱）方式，docker镜像（把引擎放在镜像中，带着经i选哪个到处跑</p><p>docker引擎统一了程序部署（运行）方式–docker容器（利用引擎把这个镜像再去运行为之前的一摸一样的容器）</p>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="https://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="Docker" scheme="https://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机网络配置和共享文件夹</title>
    <link href="https://example.com/2024/10/01/4/"/>
    <id>https://example.com/2024/10/01/4/</id>
    <published>2024-10-01T01:58:39.743Z</published>
    <updated>2025-03-19T12:32:54.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h1 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h1><table><thead><tr><th align="center">学号：202000130199</th><th>姓名： 荆树吉</th><th>班级： 20数据</th><th></th></tr></thead><tbody><tr><td align="center">实验题目：虚拟化技术练习一VMware</td><td></td><td></td><td></td></tr><tr><td align="center">实验学时：2</td><td>实验日期：</td><td></td><td></td></tr><tr><td align="center">实验目的：在Linux环境下，熟悉VMware虚拟化环境。  具体包括：了解VMware虚拟化环境的配置和部署，并配置网络连接，使其能够与本地计算机互相通信；在虚拟机中创建一个共享文件夹，使得本地计算机能够访问该共享文件夹，撰写实验报告。</td><td></td><td></td><td></td></tr><tr><td align="center">硬件环境：   联网的计算机一台</td><td></td><td></td><td></td></tr><tr><td align="center">软件环境：  Linux</td><td></td><td></td><td></td></tr><tr><td align="center">实验步骤与内容：  1. 安装VWware Workstation  官方正版VMware下载（16 pro）：我用的是阿里云盘传输下载，速度较快    下载Linux系统镜像，来源同上    安装：选一下安装地址，一直下一步即可。  <img src="/2024/10/01/4/clip_image002.jpg" alt="img">  新建虚拟机  现在我们就相当于买电脑，先把电脑配置整好。什么cpu啊内存条啊硬盘啊什么乱七八糟的，先不着急装系统。  Linux版本选的是GenOS7 64位。  一路默认  地址选在D盘  安装操作系统 选择镜像位置然后确认  打开虚拟机 读完秒后  选择简体中文  修改安装方式 选择GNOME桌面然后点完成  然后加一个默认的安装位置  开启网络连接  设置root密码和用户名密码  安装后重启 接受协议  安装配置进入界面  2. 并配置网络连接，使其能够与本地计算机互相通信  打开虚拟网络编辑器打开NAT模式  <img src="/2024/10/01/4/clip_image004.png" alt="img">  在面板-》虚拟机-》配置（一定要选择某台虚拟机，否则设置会变为灰色）  <img src="/2024/10/01/4/clip_image006.png" alt="img">  虚拟机内设置IP&#x2F;静态&#x2F;网关&#x2F;DNS  主机VMnet8的IP  <img src="/2024/10/01/4/clip_image008.png" alt="img">  主机连接网络的DNS(软件网络服务)     <img src="/2024/10/01/4/clip_image010.png" alt="img">  虚拟机内IP相关配置设置  vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33  例如：  6.重启network服务,配置生效  双方可ping通  网络连接完成     3.设置共享文件夹  选择待处理虚拟机，右键设置  在虚拟机设置 窗口：选择 选项–》点击 共享文件夹；文件夹共享 选择总是启用     在文件夹 ：添加共享目录； 弹出窗口 点击下一步–》设置共享文件夹目录 地址、共享文件夹名称 —》启用此共享 –》完成。 虚拟机设置完成。  <img src="/2024/10/01/4/clip_image012.png" alt="img">  3. 挂载  上述步骤完毕后，CentOS6会自动在&#x2F;mnt目录下挂载共享目录，但是CentOS7需要手动挂载。     1、在Centos 桌面打开终端（或者使用 XShell ：直接连接上就好)     2、查看共享目录情况  命令： vmware-hgfsclient  如果这是第一次设置共享目录， centos 7 需要创建文件夹在 &#x2F;mnt 下创建 &#x2F;hgfs  自动挂载：让虚拟机系统每次启动完成，自动挂载虚拟机已经设置的共享目录。在&#x2F;etc&#x2F;fstab文件中添加挂载目录  在打开的文件中 添加 ：  .host:&#x2F;共享文件名  &#x2F;mnt&#x2F;hgfs fuse.vmhgfs-fuse allow_other,defaults 0 0　  mount -a生效</td><td></td><td></td><td></td></tr><tr><td align="center">结论分析与体会：  采用ubundu虚拟机会找不到对应的  网络配置的文件ens33  应该选择cento的linux系统  方可实现主机和虚拟机之间的联系</td><td></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="https://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="VM" scheme="https://example.com/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境基本操作练习</title>
    <link href="https://example.com/2024/10/01/1/"/>
    <id>https://example.com/2024/10/01/1/</id>
    <published>2024-10-01T01:58:39.740Z</published>
    <updated>2025-03-19T12:32:14.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学实验报告-1"><a href="#山东大学实验报告-1" class="headerlink" title="山东大学实验报告 1"></a>山东大学实验报告 1</h1><h2 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h2><h2 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h2><p><strong>学号：202000130199  |姓名：荆树吉 |  班级：20数据</strong></p><h3 id="实验题目：Linux环境基本操作练习"><a href="#实验题目：Linux环境基本操作练习" class="headerlink" title="实验题目：Linux环境基本操作练习"></a>实验题目：Linux环境基本操作练习</h3><h3 id="实验学时：2"><a href="#实验学时：2" class="headerlink" title="实验学时：2"></a>实验学时：2</h3><h3 id="实验日期：-2023-2-25"><a href="#实验日期：-2023-2-25" class="headerlink" title="实验日期：  2023.2.25"></a>实验日期：  2023.2.25</h3><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>在Linux环境下，熟悉基本的文件操作和命令</p><p>具体包括：了解Linux，浏览文件、创建文件、安装一个程序、了解Python、C++等常用编程环境</p><h3 id="硬件环境："><a href="#硬件环境：" class="headerlink" title="硬件环境："></a>硬件环境：</h3><p>计算机一台</p><h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3><p>Linux</p><h3 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h3><h4 id="1-了解linux"><a href="#1-了解linux" class="headerlink" title="1.了解linux"></a>1.了解linux</h4><p>Linux，全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。</p><h4 id="2-浏览文件和创建文件"><a href="#2-浏览文件和创建文件" class="headerlink" title="2.浏览文件和创建文件"></a>2.浏览文件和创建文件</h4><p>ls可以浏览当前文件夹的所有文件vi可以浏览文件之间的具体内容</p><p><img src="/2024/10/01/1/1.png" alt="1.浏览文件夹内容"></p><p>vi test</p><p><img src="/2024/10/01/1/2.png" alt="2.浏览文件内容"></p><h4 id="3-安装程序"><a href="#3-安装程序" class="headerlink" title="3.安装程序"></a>3.安装程序</h4><h5 id="一、-源码编译安装（二进制安装）"><a href="#一、-源码编译安装（二进制安装）" class="headerlink" title="一、 源码编译安装（二进制安装）"></a>一、 源码编译安装（二进制安装）</h5><p>程序：由开发人员写代码一个一个单词敲出来的</p><p>源码：编写好的.c.java文件</p><p>编译：将人类写的代码翻译成二进制语言</p><p>安装：将二进制保存在键盘上</p><p>缺点：</p><p> 如果编译出了问题，你不懂源代码，无法解决</p><p>安装过程复杂</p><p>没有统一的管理人员</p><p>优点：</p><p> 契合系统，兼容性强</p><p>如果你可以看懂源代码，修改新增功能</p><p>比较自由</p><h5 id="二、rpm安装（安装包管理工具）"><a href="#二、rpm安装（安装包管理工具）" class="headerlink" title="二、rpm安装（安装包管理工具）"></a>二、rpm安装（安装包管理工具）</h5><p>优点：</p><p> 统一的安装包格式</p><p>已经帮你编译完成</p><p>使用简单</p><p>缺点：</p><p> 有依赖关系（安装 a ，就需要先安装别的）</p><p>查询（对已安装程序查询）</p><p>查看系统已安装的所有软件（-qa）</p><h4 id="4-c-和python的利用-vscode"><a href="#4-c-和python的利用-vscode" class="headerlink" title="4 .c++,和python的利用 vscode"></a>4 .c++,和python的利用 vscode</h4><h5 id="1-c-代码"><a href="#1-c-代码" class="headerlink" title="1.c++代码"></a>1.c++代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,X,Y;</span><br><span class="line"><span class="type">int</span> x[<span class="number">202</span>],y[<span class="number">202</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">d</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis;</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d node[<span class="number">202</span>];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;X&gt;&gt;Y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">        node[i].dis=(x[i]-X)*(x[i]-X)+(y[i]-Y)*(y[i]-Y);</span><br><span class="line">        node[i].no=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t,k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((node[i].dis&gt;node[j].dis)||((node[i].dis==node[j].dis)&amp;&amp;(node[i].no&gt;node[j].no)))</span><br><span class="line">            &#123;</span><br><span class="line">               t=node[i].dis;</span><br><span class="line">               node[i].dis=node[j].dis;</span><br><span class="line">               node[j].dis=t;</span><br><span class="line">               k=node[i].no;</span><br><span class="line">               node[i].no=node[j].no;</span><br><span class="line">               node[j].no=k;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;node[i].dis&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node[i].no&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;node[<span class="number">0</span>].no+<span class="number">1</span>&lt;&lt;endl&lt;&lt;node[<span class="number">1</span>].no+<span class="number">1</span>&lt;&lt;endl&lt;&lt;node[<span class="number">2</span>].no+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给出一个点的坐标和其他的点的个数</p><p>再给出几个对应的点的坐标</p><p>判断里这个点最近的三个点</p><p>三个点的顺序由序号越小对应的距离就越近</p><h5 id="2-python-代码"><a href="#2-python-代码" class="headerlink" title="2.python 代码"></a>2.python 代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#读入文件</span></span><br><span class="line">file_path = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">df = pd.read_table(file_path, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 x  y变量</span></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义颜色变量</span></span><br><span class="line">color = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;w&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#用for循环将文件中的值赋值给x，y</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df[<span class="number">0</span>])):</span><br><span class="line">    x.append(<span class="built_in">int</span>(df[<span class="number">0</span>][i].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>]))</span><br><span class="line">    y.append(<span class="built_in">int</span>(df[<span class="number">0</span>][i].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line">plt.scatter(x, y, c=color[<span class="number">2</span>], edgecolors=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">画一个散点图</span><br><span class="line">数据如下</span><br><span class="line"><span class="number">151</span>,<span class="number">54</span></span><br><span class="line"><span class="number">137</span>,<span class="number">55</span></span><br><span class="line"><span class="number">95</span>,<span class="number">66</span></span><br><span class="line"><span class="number">156</span>,<span class="number">91</span></span><br><span class="line"><span class="number">193</span>,<span class="number">101</span></span><br><span class="line"><span class="number">58</span>,<span class="number">104</span></span><br><span class="line"><span class="number">133</span>,<span class="number">105</span></span><br><span class="line"><span class="number">120</span>,<span class="number">118</span></span><br><span class="line"><span class="number">167</span>,<span class="number">136</span></span><br><span class="line"><span class="number">110</span>,<span class="number">149</span></span><br><span class="line"><span class="number">96</span>,<span class="number">174</span></span><br><span class="line"><span class="number">22</span>,<span class="number">184</span></span><br><span class="line"><span class="number">60</span>,<span class="number">193</span></span><br><span class="line"><span class="number">88</span>,<span class="number">198</span></span><br><span class="line"><span class="number">177</span>,<span class="number">202</span></span><br><span class="line"><span class="number">213</span>,<span class="number">235</span></span><br><span class="line"><span class="number">133</span>,<span class="number">249</span></span><br><span class="line"><span class="number">127</span>,<span class="number">255</span></span><br><span class="line"><span class="number">70</span>,<span class="number">257</span></span><br><span class="line"><span class="number">40</span>,<span class="number">273</span></span><br><span class="line"><span class="number">64</span>,<span class="number">271</span></span><br><span class="line"><span class="number">168</span>,<span class="number">286</span></span><br><span class="line"><span class="number">126</span>,<span class="number">325</span></span><br><span class="line"><span class="number">132</span>,<span class="number">335</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结论分析与体会"><a href="#结论分析与体会" class="headerlink" title="结论分析与体会"></a>结论分析与体会</h3><p>Linux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux不仅仅是被网络运维人员当作服务器使用，甚至当作网络防火墙，这是Linux的一大亮点。</p><p>Linux具有开放源码、没有版权、技术社区用户多等特点，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。</p><p>Linux的基本思想有两点：第一，一切都是文件；第二，每个文件都有确定的用途。其中第一条详细来讲就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近。</p>]]></content>
    
    
    <summary type="html">7</summary>
    
    
    
    <category term="云计算" scheme="https://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="linux 操作" scheme="https://example.com/tags/linux-%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>openVZ</title>
    <link href="https://example.com/2023/10/28/openVZ/"/>
    <id>https://example.com/2023/10/28/openVZ/</id>
    <published>2023-10-28T04:40:01.997Z</published>
    <updated>2025-03-19T12:40:35.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山东大学-计算机科学与技术-学院"><a href="#山东大学-计算机科学与技术-学院" class="headerlink" title="山东大学  计算机科学与技术  学院"></a>山东大学  计算机科学与技术  学院</h1><h1 id="云计算技术-课程实验报告"><a href="#云计算技术-课程实验报告" class="headerlink" title="云计算技术  课程实验报告"></a>云计算技术  课程实验报告</h1><table><thead><tr><th>学号：202000130199</th><th>姓名： 荆树吉</th><th>班级： 20数据</th></tr></thead></table><table><thead><tr><th>实验题目：操作系统虚拟化  OpenVZ</th></tr></thead></table><table><thead><tr><th>实验学时：2</th><th>实验日期： 2023.4.18</th></tr></thead></table><table><thead><tr><th>实验目的：在Linux环境下，熟悉OpenVZ虚拟化。  具体包括：自行了解OpenVZ虚拟化技术，完成实验环境及实验工具的熟悉，包括安装和配置OpenVZ，了解如何创建容器等，撰写实验报告。</th></tr></thead></table><table><thead><tr><th>硬件环境： 联网的计算机一台</th></tr></thead></table><table><thead><tr><th>软件环境：Linux</th></tr></thead></table><h2 id="实验步骤与内容："><a href="#实验步骤与内容：" class="headerlink" title="实验步骤与内容："></a>实验步骤与内容：</h2><h3 id="1-添加源"><a href="#1-添加源" class="headerlink" title="1.添加源"></a>1.添加源</h3><p>vim &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;openvz.list</p><p>写入下面内容保存</p><p>如果需要,可以视情况改动注释.</p><p>deb <a href="http://download.openvz.org/debian">http://download.openvz.org/debian</a> wheezy main</p><p># deb <a href="http://download.openvz.org/debian">http://download.openvz.org/debian</a> wheezy-test main</p><h3 id="2-导入key后更新"><a href="#2-导入key后更新" class="headerlink" title="2.导入key后更新"></a>2.导入key后更新</h3><p>wget <a href="http://ftp.openvz.org/debian/archive.key">http://ftp.openvz.org/debian/archive.key</a></p><p>apt-key add archive.key</p><p>apt update</p><h3 id="3-配置内核参数"><a href="#3-配置内核参数" class="headerlink" title="3. 配置内核参数"></a>3. 配置内核参数</h3><p>vim &#x2F;etc&#x2F;sysctl.conf</p><p>配置这些项:</p><p># On Hardware Node we generally need</p><p># packet forwarding enabled and proxy arp disabled</p><p>net.ipv4.ip_forward &#x3D; 1</p><p>net.ipv6.conf.default.forwarding &#x3D; 1</p><p>net.ipv6.conf.all.forwarding &#x3D; 1</p><p>net.ipv4.conf.default.proxy_arp &#x3D; 0</p><p># Enables source route verification</p><p>net.ipv4.conf.all.rp_filter &#x3D; 1</p><p># Enables the magic-sysrq key</p><p>kernel.sysrq &#x3D; 1</p><p># We do not want all our interfaces to send redirects</p><p>net.ipv4.conf.default.send_redirects &#x3D; 1</p><p>net.ipv4.conf.all.send_redirects &#x3D; 0</p><h3 id="4-让修改立刻生效"><a href="#4-让修改立刻生效" class="headerlink" title="4.让修改立刻生效:"></a>4.让修改立刻生效:</h3><p>sysctl -p</p><h3 id="5-安装64位系统用这个"><a href="#5-安装64位系统用这个" class="headerlink" title="5.安装64位系统用这个"></a>5.安装64位系统用这个</h3><p>apt install -y linux-image-openvz-amd64 vzctl vzquota ploop vzstats</p><h3 id="6-进入openvz内核"><a href="#6-进入openvz内核" class="headerlink" title="6.进入openvz内核"></a>6.进入openvz内核</h3><p>重启,在grub中选择”advance options for ubuntu”进入后可找到带着openvz的行(有可能不止一个,选第一个就是了)</p><h3 id="7-使用"><a href="#7-使用" class="headerlink" title="7.使用"></a>7.使用</h3><p>① 创建并初始化虚拟机</p><p>创建虚拟机需要下载系统模板</p><p>#创建虚拟机,编号102 参数是:虚拟机编号 –ostemplate 系统模板</p><p>vzctl create 102 –ostemplate debian-7.0-x86-minimal</p><p>#设置主机名称</p><p>vzctl set 102 –hostname “vz102” –save</p><p>#限制CPU</p><p>vzctl set 102 –cpuunits 1000 –cpulimit 50 –save</p><p>#限制I&#x2F;O</p><p>vzctl set 102 –iolimit 5M –save</p><p>#设置内存和swap</p><p>vzctl set 102 –ram 64M –swap 0G –save</p><p>#设置硬盘大小 参数:编号 –diskspace 软限制:硬限制 –save</p><p>vzctl set 102 –diskspace 64M:5G –save</p><p>#设置ip</p><p>vzctl set 102 –ipadd 192.168.0.2 –save</p><p>#设定dns服务器</p><p>vzctl set 102 –nameserver 8.8.8.8 –nameserver 8.8.4.4 –save</p><p>#设置root用户密码(需要Cgroup)</p><p>vzctl set 102 –userpasswd root:passwd</p><p>#主机开机时自动运行虚拟机,酌情使用</p><p>vzctl set 102 –onboot yes –save</p><p>② 启动</p><p>vzctl restart 102</p><p>③ 关闭</p><p>vzctl stop 102</p><p>④ 删除</p><p>vzctl destroy 102</p><p>⑤ 查看资源占用</p><p>vzcalc -v 102</p><h3 id="8-网络配置"><a href="#8-网络配置" class="headerlink" title="8.网络配置"></a>8.网络配置</h3><p>#Clear All configure</p><p>iptables -F</p><p>iptables -F -t nat</p><p>#let the computer can to forward data</p><p>iptables -A FORWARD -j ACCEPT</p><p>#这行是打通nat功能,让vps能通过host的ip发送数据到外网,外网也能返回数据,要改两个地方:网卡和最后的ip</p><p>iptables -t nat -A POSTROUTING -o eth0 -j SNAT –to 主机对外的ip</p><p>#这行是端口转发,把ssh端口打通一下</p><p>iptables -t nat -A PREROUTING -p tcp -m tcp –dport 10222 -j DNAT –to-destination 192.168.0.2:22</p><h2 id="结论分析与体会："><a href="#结论分析与体会：" class="headerlink" title="结论分析与体会："></a>结论分析与体会：</h2><p>优势：外面卖的这种类型，许可的内存都超大，CPU也强劲，而且卖家很多，可比性也很强。性价比超高。</p><p>劣势：超卖，没有不超卖的，导致各种石头盘，钻石盘。连带的cpu也被过度分割导致性能升值不如其标明的1&#x2F;10。再有就是内存，基本上OpenVZ技术没有独占的，都是共享，别人多了你就少了，而且这种技术最大的劣势就是内存下来后直接就是当机。还有开设vpn各种不方便</p>]]></content>
    
    
    <summary type="html">有关openVZ</summary>
    
    
    
    <category term="云计算" scheme="https://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="openVZ" scheme="https://example.com/tags/openVZ/"/>
    
  </entry>
  
</feed>
